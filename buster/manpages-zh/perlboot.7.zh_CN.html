<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>perlboot(7) — manpages-zh — Debian buster — Debian Manpages</title>
<style type="text/css">
@font-face {
  font-family: 'Inconsolata';
  src: local('Inconsolata'), url(/Inconsolata.woff2) format('woff2'), url(/Inconsolata.woff) format('woff');
}

@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 400;
  src: local('Roboto'), local('Roboto Regular'), local('Roboto-Regular'), url(/Roboto-Regular.woff2) format('woff2'), url(/Roboto-Regular.woff) format('woff');
}

body {
	color: #000;
	background-color: white;
	background-image: linear-gradient(to bottom, #d7d9e2, #fff 70px);
	background-position: 0 0;
	background-repeat: repeat-x;
	font-family: sans-serif;
	font-size: 100%;
	line-height: 1.2;
	letter-spacing: 0.15px;
	margin: 0;
	padding: 0;
}

#header {
	padding: 0 10px 0 52px;
}

#logo {
	position: absolute;
	top: 0;
	left: 0;
	border-left: 1px solid transparent;
	border-right: 1px solid transparent;
	border-bottom: 1px solid transparent;
	width: 50px;
	height: 5.07em;
	min-height: 65px;
}

#logo a {
	display: block;
	height: 100%;
}

#logo img {
	margin-top: 5px;
	position: absolute;
	bottom: 0.3em;
	overflow: auto;
	border: 0;
}

p.section {
	margin: 0;
	padding: 0 5px 0 5px;
	font-size: 13px;
	line-height: 16px;
	color: white;
	letter-spacing: 0.08em;
	position: absolute;
	top: 0px;
	left: 52px;
	background-color: #c70036;
}

p.section a {
	color: white;
	text-decoration: none;
}

.hidecss {
	display: none;
}

#searchbox {
	text-align:left;
	line-height: 1;
	margin: 0 10px 0 0.5em;
	padding: 1px 0 1px 0;
	position: absolute;
	top: 0;
	right: 0;
	font-size: .75em;
}

#navbar {
	border-bottom: 1px solid #c70036;
}

#navbar ul {
	margin: 0;
	padding: 0;
	overflow: hidden;
}

#navbar li {
	list-style: none;
	float: left;
}

#navbar a {
	display: block;
	padding: 1.75em .5em .25em .5em;
	color: #0035c7;
	text-decoration: none;
	border-left: 1px solid transparent;
	border-right: 1px solid transparent;
}

#navbar a:hover
, #navbar a:visited:hover {
	background-color: #f5f6f7;
	border-left: 1px solid  #d2d3d7;
	border-right: 1px solid #d2d3d7;
	text-decoration: underline;
}

a:link {
	color: #0035c7;
}

a:visited {
	color: #54638c;
}

#breadcrumbs {
	line-height: 2;
	min-height: 20px;
	margin: 0;
	padding: 0;
	font-size: 0.75em;
	background-color: #f5f6f7;
	border-bottom: 1px solid #d2d3d7;
}

#breadcrumbs:before {
	margin-left: 0.5em;
	margin-right: 0.5em;
}

#content {
    margin: 0 10px 0 52px;
    display: flex;
    flex-direction: row;
}

.paneljump {
    background-color: #d70751;
    padding: 0.5em;
    border-radius: 3px;
    margin-right: .5em;
    display: none;
}

.paneljump a,
.paneljump a:visited,
.paneljump a:hover,
.paneljump a:focus {
    color: white;
}

@media all and (max-width: 800px) {
    #content {
	flex-direction: column;
	margin: 0.5em;
    }
    .paneljump {
	display: block;
    }
}

.panels {
    display: block;
    order: 2;
}

.maincontent {
    width: 100%;
    max-width: 80ch;
    order: 1;
}

.mandoc {
    font-family: monospace;
    font-size: 1.04rem;
}

.mandoc pre {
    white-space: pre-wrap;
}

#footer {
	border: 1px solid #dfdfe0;
	border-left: 0;
	border-right: 0;
	background-color: #f5f6f7;
	padding: 1em;
	margin: 1em 10px 0 52px;
	font-size: 0.75em;
	line-height: 1.5em;
}

hr {
	border-top: 1px solid #d2d3d7;
	border-bottom: 1px solid white;
	border-left: 0;
	border-right: 0;
	margin: 1.4375em 0 1.5em 0;
	height: 0;
	background-color: #bbb;
}

#content p {
    padding-left: 1em;
}

 

a, a:hover, a:focus, a:visited {
    color: #0530D7;
    text-decoration: none;
}

 
.panel {
  padding: 15px;
  margin-bottom: 20px;
  background-color: #ffffff;
  border: 1px solid #dddddd;
  border-radius: 4px;
  -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
          box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
}

.panel-heading, .panel details {
  margin: -15px -15px 0px;
  background-color: #d70751;
  border-bottom: 1px solid #dddddd;
  border-top-right-radius: 3px;
  border-top-left-radius: 3px;
}

.panel-heading, .panel summary {
  padding: 5px 5px;
  font-size: 17.5px;
  font-weight: 500;
  color: #ffffff;
  outline-style: none;
}

.panel summary {
    padding-left: 7px;
}

summary, details {
    display: block;
}

.panel details ul {
  margin: 0;
}

.panel-footer {
  padding: 5px 5px;
  margin: 15px -15px -15px;
  background-color: #f5f5f5;
  border-top: 1px solid #dddddd;
  border-bottom-right-radius: 3px;
  border-bottom-left-radius: 3px;
}
.panel-info {
  border-color: #bce8f1;
}

.panel-info .panel-heading {
  color: #3a87ad;
  background-color: #d9edf7;
  border-color: #bce8f1;
}


.list-group {
  padding-left: 0;
  margin-bottom: 20px;
  background-color: #ffffff;
}

.list-group-item {
  position: relative;
  display: block;
  padding: 5px 5px 5px 5px;
  margin-bottom: -1px;
  border: 1px solid #dddddd;
}

.list-group-item > .list-item-key {
  min-width: 27%;
  display: inline-block;
}
.list-group-item > .list-item-key.versions-repository {
  min-width: 40%;
}
.list-group-item > .list-item-key.versioned-links-version {
  min-width: 40%
}


.versioned-links-icon {
  margin-right: 2px;
}
.versioned-links-icon a {
  color: black;
}
.versioned-links-icon a:hover {
  color: blue;
}
.versioned-links-icon-inactive {
  opacity: 0.5;
}

.list-group-item:first-child {
  border-top-right-radius: 4px;
  border-top-left-radius: 4px;
}

.list-group-item:last-child {
  margin-bottom: 0;
  border-bottom-right-radius: 4px;
  border-bottom-left-radius: 4px;
}

.list-group-item-heading {
  margin-top: 0;
  margin-bottom: 5px;
}

.list-group-item-text {
  margin-bottom: 0;
  line-height: 1.3;
}

.list-group-item:hover {
  background-color: #f5f5f5;
}

.list-group-item.active a {
  z-index: 2;
}

.list-group-item.active {
  background-color: #efefef;
}

.list-group-flush {
  margin: 15px -15px -15px;
}
.panel .list-group-flush {
  margin-top: -1px;
}

.list-group-flush .list-group-item {
  border-width: 1px 0;
}

.list-group-flush .list-group-item:first-child {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}

.list-group-flush .list-group-item:last-child {
  border-bottom: 0;
}

 

.panel {
float: right;
clear: right;
min-width: 200px;
}

.toc {
     
    width: 200px;
}

.toc li {
    font-size: 98%;
    letter-spacing: 0.02em;
    display: flex;
}

.otherversions {
     
    width: 200px;
}

.otherversions li,
.otherlangs li {
    display: flex;
}

.otherversions a,
.otherlangs a {
    flex-shrink: 0;
}

.pkgversion,
.pkgname,
.toc a {
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
}

.pkgversion,
.pkgname {
    margin-left: auto;
    padding-left: 1em;
}

 

.mandoc {
     
    overflow: hidden;
    margin-top: .5em;
    margin-right: 45px;
}
table.head, table.foot {
    width: 100%;
}
.head-vol {
    text-align: center;
}
.head-rtitle {
    text-align: right;
}

 
.spacer, .Pp {
    min-height: 1em;
}

pre {
    margin-left: 2em;
}

.anchor {
    margin-left: .25em;
    visibility: hidden;
}

h1:hover .anchor,
h2:hover .anchor,
h3:hover .anchor,
h4:hover .anchor,
h5:hover .anchor,
h6:hover .anchor {
    visibility: visible;
}

h1, h2, h3, h4, h5, h6 {
    letter-spacing: .07em;
    margin-top: 1.5em;
    margin-bottom: .35em;
}

h1 {
    font-size: 150%;
}

h2 {
    font-size: 125%;
}

@media print {
    #header, #footer, .panel, .anchor, .paneljump {
	display: none;
    }
    #content {
	margin: 0;
    }
    .mandoc {
	margin: 0;
    }
}

 
 

.Bd { }
.Bd-indent {	margin-left: 3.8em; }

.Bl-bullet {	list-style-type: disc;
		padding-left: 1em; }
.Bl-bullet > li { }
.Bl-dash {	list-style-type: none;
		padding-left: 0em; }
.Bl-dash > li:before {
		content: "\2014  "; }
.Bl-item {	list-style-type: none;
		padding-left: 0em; }
.Bl-item > li { }
.Bl-compact > li {
		margin-top: 0em; }

.Bl-enum {	padding-left: 2em; }
.Bl-enum > li { }
.Bl-compact > li {
		margin-top: 0em; }

.Bl-diag { }
.Bl-diag > dt {
		font-style: normal;
		font-weight: bold; }
.Bl-diag > dd {
		margin-left: 0em; }
.Bl-hang { }
.Bl-hang > dt { }
.Bl-hang > dd {
		margin-left: 5.5em; }
.Bl-inset { }
.Bl-inset > dt { }
.Bl-inset > dd {
		margin-left: 0em; }
.Bl-ohang { }
.Bl-ohang > dt { }
.Bl-ohang > dd {
		margin-left: 0em; }
.Bl-tag {	margin-left: 5.5em; }
.Bl-tag > dt {
		float: left;
		margin-top: 0em;
		margin-left: -5.5em;
		padding-right: 1.2em;
		vertical-align: top; }
.Bl-tag > dd {
		clear: right;
		width: 100%;
		margin-top: 0em;
		margin-left: 0em;
		vertical-align: top;
		overflow: auto; }
.Bl-compact > dt {
		margin-top: 0em; }

.Bl-column { }
.Bl-column > tbody > tr { }
.Bl-column > tbody > tr > td {
		margin-top: 1em; }
.Bl-compact > tbody > tr > td {
		margin-top: 0em; }

.Rs {		font-style: normal;
		font-weight: normal; }
.RsA { }
.RsB {		font-style: italic;
		font-weight: normal; }
.RsC { }
.RsD { }
.RsI {		font-style: italic;
		font-weight: normal; }
.RsJ {		font-style: italic;
		font-weight: normal; }
.RsN { }
.RsO { }
.RsP { }
.RsQ { }
.RsR { }
.RsT {		text-decoration: underline; }
.RsU { }
.RsV { }

.eqn { }
.tbl { }

.HP {		margin-left: 3.8em;
		text-indent: -3.8em; }

 

table.Nm { }
code.Nm {	font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Fl {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Cm {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ar {		font-style: italic;
		font-weight: normal; }
.Op {		display: inline; }
.Ic {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ev {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }
.Pa {		font-style: italic;
		font-weight: normal; }

 

.Lb { }
code.In {	font-style: normal;
		font-weight: bold;
		font-family: inherit; }
a.In { }
.Fd {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ft {		font-style: italic;
		font-weight: normal; }
.Fn {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Fa {		font-style: italic;
		font-weight: normal; }
.Vt {		font-style: italic;
		font-weight: normal; }
.Va {		font-style: italic;
		font-weight: normal; }
.Dv {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }
.Er {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }

 

.An { }
.Lk { }
.Mt { }
.Cd {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ad {		font-style: italic;
		font-weight: normal; }
.Ms {		font-style: normal;
		font-weight: bold; }
.St { }
.Ux { }

 

.Bf {		display: inline; }
.No {		font-style: normal;
		font-weight: normal; }
.Em {		font-style: italic;
		font-weight: normal; }
.Sy {		font-style: normal;
		font-weight: bold; }
.Li {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }

</style>
<script type="text/javascript">
if (!!document['fonts']) {
        var r = "body{font-family:'Roboto',sans-serif;}";
        var i = ".mandoc,.mandoc pre,.mandoc code,p.section{font-family:'Inconsolata',monospace;}";
        var l = function(m) {
                if (!document.body) {
                        document.write("<style>"+m+"</style>");
                } else {
                        document.body.innerHTML+="<style>"+m+"</style>";
                }
        };
         
        new FontFace('Roboto', "local('Roboto'), local('Roboto Regular'), local('Roboto-Regular'), url(/Roboto-Regular.woff2) format('woff2'), url(/Roboto-Regular.woff) format('woff')")
                .load().then(function() { l(r); });
        new FontFace('Inconsolata', "local('Inconsolata'), url(/Inconsolata.woff2) format('woff2'), url(/Inconsolata.woff) format('woff')")
                .load().then(function() { l(i); });
} else {
        var l = document.createElement('link');
        l.rel = 'preload';
        l.href = '/fonts-woff.css';
        l.as = 'style';
        l.onload = function() { this.rel = 'stylesheet'; };
        document.head.appendChild(l);
}
</script>
<link rel="search" title="Debian manpages" type="application/opensearchdescription+xml" href="../../opensearch.xml">
<noscript>
  <style type="text/css">
    body { font-family: 'Roboto', sans-serif; }
    .mandoc, .mandoc pre, .mandoc code, p.section { font-family: 'Inconsolata', monospace; }
  </style>
</noscript>
<link rel="alternate" href="../../buster/manpages-zh/perlboot.7.zh_CN.html" hreflang="zh-CN">
<link rel="alternate" href="../../buster/manpages-zh/perlboot.7.zh_TW.html" hreflang="zh-TW">
</head>
<body>
<div id="header">
   <div id="upperheader">
   <div id="logo">
  <a href="../../" title="Debian Home"><img src="../../openlogo-50.svg" alt="Debian" width="50" height="61"></a>
  </div>
  <p class="section"><a href="../../">MANPAGES</a></p>
  <div id="searchbox">
    <form action="../../jump" method="get">
      <input type="hidden" name="suite" value="buster">
      <input type="hidden" name="binarypkg" value="manpages-zh">
      <input type="hidden" name="section" value="7">
      <input type="hidden" name="language" value="zh_CN">
      <input type="text" name="q" placeholder="manpage name" required>
      <input type="submit" value="Jump">
    </form>
  </div>
 </div>
<div id="navbar">
<p class="hidecss"><a href="#content">Skip Quicknav</a></p>
<ul>
   <li><a href="../../">Index</a></li>
   <li><a href="../../about.html">About Manpages</a></li>
   <li><a href="../../faq.html">FAQ</a></li>
   <li><a href="../../manpages.debian.org">Service Information</a></li>
</ul>
</div>
   <p id="breadcrumbs">&nbsp;
     
     &#x2F; <a href="../../contents-buster.html">buster</a>
     
     
     
     &#x2F; <a href="../../buster/manpages-zh/index.html">manpages-zh</a>
     
     
     
     &#x2F; perlboot(7)
     
     </p>
</div>
<div id="content">


<div class="panels" id="panels">
<div class="panel" role="complementary">
<div class="panel-heading" role="heading">
links
</div>
<div class="panel-body">
<ul class="list-group list-group-flush">
<li class="list-group-item">
<a href="../../buster/manpages-zh/perlboot.7">language-indep link</a>
</li>
<li class="list-group-item">
<a href="../../pkg/manpages-zh">package tracker</a>
</li>
<li class="list-group-item">
<a href="../../buster/manpages-zh/perlboot.7.zh_CN.gz">raw man page</a>
</li>
</ul>
</div>
</div>

<div class="panel toc" role="complementary" style="padding-bottom: 0">
<details>
<summary>
table of contents
</summary>
<div class="panel-body">
<ul class="list-group list-group-flush">

<li class="list-group-item">
  <a class="toclink" href="#NAME" title="NAME">NAME</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#DESCRIPTION_%E6%8F%8F%E8%BF%B0" title="DESCRIPTION 描述">DESCRIPTION 描述</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#SEE_ALSO_%E5%8F%82%E8%A7%81" title="SEE ALSO 参见">SEE ALSO 参见</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#COPYRIGHT" title="COPYRIGHT">COPYRIGHT</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E4%B8%AD%E6%96%87%E7%89%88%E7%BB%B4%E6%8A%A4%E4%BA%BA" title="中文版维护人">中文版维护人</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%80%E6%96%B0%E6%9B%B4%E6%96%B0" title="中文版最新更新">中文版最新更新</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C%E9%A1%B5%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92" title="中文手册页翻译计划">中文手册页翻译计划</a>
</li>

</ul>
</div>
</details>
</div>

<div class="panel otherversions" role="complementary">
<div class="panel-heading" role="heading">
other versions
</div>
<div class="panel-body">
<ul class="list-group list-group-flush">

<li class="list-group-item active">
<a href="../../buster/manpages-zh/perlboot.7.zh_CN.html">buster</a> <span class="pkgversion" title="1.6.3.3-1">1.6.3.3-1</span>
</li>

<li class="list-group-item">
<a href="../../testing/manpages-zh/perlboot.7.zh_CN.html">testing</a> <span class="pkgversion" title="1.6.3.3-2">1.6.3.3-2</span>
</li>

<li class="list-group-item">
<a href="../../unstable/manpages-zh/perlboot.7.zh_CN.html">unstable</a> <span class="pkgversion" title="1.6.3.3-2">1.6.3.3-2</span>
</li>

</ul>
</div>
</div>


<div class="panel otherlangs" role="complementary">
<div class="panel-heading" role="heading">
other languages
</div>
<div class="panel-body">
<ul class="list-group list-group-flush">

<li class="list-group-item active">
<a href="../../buster/manpages-zh/perlboot.7.zh_CN.html" title="Chinese (zh_CN)">中文 (zh-CN)</a>

</li>

<li class="list-group-item">
<a href="../../buster/manpages-zh/perlboot.7.zh_TW.html" title="Chinese (zh_TW)">繁體中文 (zh-TW)</a>

</li>

</ul>
</div>
</div>



<div class="panel" role="complementary">
<div class="panel-heading" role="heading">
other sections
</div>
<div class="panel-body">
<ul class="list-group list-group-flush">

<li class="list-group-item">
<a href="../../buster/perl-doc/perlboot.1.en.html">1 (<span title="Executable programs or shell commands">progs</span>)</a>
</li>

<li class="list-group-item active">
<a href="../../buster/manpages-zh/perlboot.7.zh_CN.html">7 (<span title="Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)">misc</span>)</a>
</li>

</ul>
</div>
</div>



</div>

<div class="maincontent">
<p class="paneljump"><a href="#panels">Scroll to navigation</a></p>
<div class="mandoc">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">PERLBOOT(7)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLBOOT(7)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME">NAME<a class="anchor" href="#NAME">¶</a></h1>
perlboot -
  初学者的面向对象教程
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION_描述">DESCRIPTION 描述<a class="anchor" href="#DESCRIPTION_%E6%8F%8F%E8%BF%B0">¶</a></h1>
如果你对其他语言中的对象并不熟悉的话,
  那么其他有关perl对象的文件可能使你感到恐惧,
  比如 perlobj ,
  这是基础性的参考文件,
  和 perltoot,
  这是介绍perl对象的特性的教程.
<p class="Pp">所以,
    让我们走另一条路,假定你没有任何关于对象的概念.
    你需要了解子程序 (perlsub),
    引用 (perlref et. seq.), 和
    包(或模块) (perlmod),
    如果还不清楚的话,先把他们搞清楚.
  <br/>
</p>
<p class="Pp"><b>If we could talk to the
    animals...如果我们能和动物交谈</b></p>
<p class="Pp">让我们让动物讲会儿话:</p>
<p class="Pp"></p>
<pre>    sub Cow::speak {
      print &#34;a Cow goes moooo!\n&#34;;
    }
    sub Horse::speak {
      print &#34;a Horse goes neigh!\n&#34;;
    }
    sub Sheep::speak {
      print &#34;a Sheep goes baaaah!\n&#34;
    }
</pre>
<p class="Pp"></p>
<pre>    Cow::speak;
    Horse::speak;
    Sheep::speak;
</pre>
<p class="Pp">结果是:</p>
<p class="Pp"></p>
<pre>    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!
</pre>
<p class="Pp">没什么特别的.
    只是简单的子程序,
    虽然来自不同的包,
    并用完整的包名来调用.
    那么让我们建立一个完整的牧场吧:</p>
<p class="Pp"></p>
<pre>    # Cow::speak, Horse::speak, Sheep::speak 与上同
    @pasture = qw(Cow Cow Horse Sheep Sheep);
    foreach $animal (@pasture) {
      &amp;{$animal.&#34;::speak&#34;};
    }
</pre>
<p class="Pp">结果是:</p>
<p class="Pp"></p>
<pre>    a Cow goes moooo!
    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!
    a Sheep goes baaaah!
</pre>
<p class="Pp">嗯.
    这里的符号代码引用有些不太好.
    我们正依赖于 <span class="Li">&#34;no
    strict subs&#34;</span> 模式,
    在稍大些的程序中应尽量避免.
    那为什么要这样呢?
    因为我们要调用的子程序和它所在的包似乎是不可分的.</p>
<p class="Pp">真的是这样吗?
  <br/>
</p>
<p class="Pp"><b>Introducing the method invocation arrow
    调用方法时的箭头符号</b></p>
<p class="Pp">现在,我们说
    <span class="Li">&#34;Class-&gt;method&#34;</span>
    是调用了包(或模块)<span class="Li">&#34;Class&#34;</span>中的
    <span class="Li">&#34;method&#34;</span> 方法。(Here,
    &#34;Class&#34; is used in its &#34;category&#34; meaning, not its
    &#34;scholastic&#34; meaning.)
    不是很准确,不过我们会一步一步的来做.
    现在,可以这样做:</p>
<p class="Pp"></p>
<pre>    # Cow::speak, Horse::speak, Sheep::speak as before
    Cow-&gt;speak;
    Horse-&gt;speak;
    Sheep-&gt;speak;
</pre>
<p class="Pp">输出为:</p>
<p class="Pp"></p>
<pre>    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!
</pre>
<p class="Pp">还不是很有趣.
    一样的字符,常量,没有变量.
    但是,
    不同部分可以分开了.
    请看:</p>
<p class="Pp"></p>
<pre>    $a = &#34;Cow&#34;;
    $a-&gt;speak; # invokes Cow-&gt;speak
</pre>
<p class="Pp">哇!
    现在包名与子程序名可以分开了,
    我们可以用变量来表示包名.
    这样,在使用 <span class="Li">&#34;use strict
    refs&#34;</span>
    预编译指令时也可以正常工作了.
  <br/>
</p>
<p class="Pp"><b>Invoking a barnyard
    创建一个牲口棚</b></p>
<p class="Pp">现在让我们把箭头用到牲口棚的例子中，范例:</p>
<p class="Pp"></p>
<pre>    sub Cow::speak {
      print &#34;a Cow goes moooo!\n&#34;;
    }
    sub Horse::speak {
      print &#34;a Horse goes neigh!\n&#34;;
    }
    sub Sheep::speak {
      print &#34;a Sheep goes baaaah!\n&#34;
    }
</pre>
<p class="Pp"></p>
<pre>    @pasture = qw(Cow Cow Horse Sheep Sheep);
    foreach $animal (@pasture) {
      $animal-&gt;speak;
    }
</pre>
<p class="Pp">现在我们所有的动物都能说话了,
    而且不用使用代码引用.</p>
<p class="Pp">不过注意到那些相同的代码.
    每个 <span class="Li">&#34;speak&#34;</span>
    子程序的结构是相同的:
    一个 <span class="Li">&#34;print&#34;</span>
    操作符和一个基本相同的字符串，只有两个词不同.
    如果我们可以析出相同的部分就更好了，如果将来要把
    <span class="Li">&#34;goes&#34;</span> 替换为
    <span class="Li">&#34;says&#34;</span>
    时就简单得多了</p>
<p class="Pp">实际上这并不困难,
    不过在这之前我们应该对箭头符号了解的更多一些.
  <br/>
</p>
<p class="Pp"><b>The extra parameter of method invocation
    方法调用时的额外参数</b></p>
<p class="Pp">语句:</p>
<p class="Pp"></p>
<pre>    Class-&gt;method(@args)
</pre>
<p class="Pp">这样调用函数
    <span class="Li">&#34;Class::method&#34;</span>：</p>
<p class="Pp"></p>
<pre>    Class::method(&#34;Class&#34;, @args);
</pre>
<p class="Pp">(如果子程序找不到,&#34;继承，inheritance&#34;
    开始起作用,这在后面会讲到).
    这意味着我们得到的第一个参数是类名(如果没有给出其他参数，它就是调用时的唯一参数).所以我们可以象这样重写
    <span class="Li">&#34;Sheep&#34;</span> speaking
  子程序:</p>
<p class="Pp"></p>
<pre>    sub Sheep::speak {
      my $class = shift;
      print &#34;a $class goes baaaah!\n&#34;;
    }
</pre>
<p class="Pp">另外的动物与此类似:</p>
<p class="Pp"></p>
<pre>    sub Cow::speak {
      my $class = shift;
      print &#34;a $class goes moooo!\n&#34;;
    }
    sub Horse::speak {
      my $class = shift;
      print &#34;a $class goes neigh!\n&#34;;
    }
</pre>
<p class="Pp">每次 <span class="Li">$class</span>
    都会得到与子程序相关的正确的值.
    但是,还是有很多相似的结构.
    可以再简单些吗? 是的.
    可以通过在一个类中调用其它的方法来实现.
  <br/>
</p>
<p class="Pp"><b>Calling a second method to simplify things
    调用另一个方法以简化操作</b></p>
<p class="Pp">我们在 <span class="Li">&#34;speak&#34;</span>
    中调用 <span class="Li">&#34;sound&#34;</span>.
    这个方法提供声音的内容.</p>
<p class="Pp"></p>
<pre>    { package Cow;
      sub sound { &#34;moooo&#34; }
      sub speak {
        my $class = shift;
        print &#34;a $class goes &#34;, $class-&gt;sound, &#34;!\n&#34;
      }
    }
</pre>
<p class="Pp">现在, 当我们调用
    <span class="Li">&#34;Cow-&gt;speak&#34;</span> 时,
    我们在 <span class="Li">&#34;speak&#34;</span>
    中得到 <span class="Li">&#34;Cow&#34;</span>
    的类 <span class="Li">$class</span>.
    他会选择
    <span class="Li">&#34;Cow-&gt;sound&#34;</span> 方法,
    然后返回 <span class="Li">&#34;moooo&#34;</span>.
    那如果是 <span class="Li">&#34;Horse&#34;</span>
    呢?</p>
<p class="Pp"></p>
<pre>    { package Horse;
      sub sound { &#34;neigh&#34; }
      sub speak {
        my $class = shift;
        print &#34;a $class goes &#34;, $class-&gt;sound, &#34;!\n&#34;
      }
    }
</pre>
<p class="Pp">仅仅包名和声音有变化.
    因此我们可以在Cow和Horse中共用
    <span class="Li">&#34;speak&#34;</span> 吗?
    是的,通过继承实现!
  <br/>
</p>
<p class="Pp"><b>Inheriting the windpipes
  继承气管</b></p>
<p class="Pp">我们创建一个公共函数包,命名为
    <span class="Li">&#34;Animal&#34;</span>,在其中定义
    <span class="Li">&#34;speak&#34;</span>:</p>
<p class="Pp"></p>
<pre>    { package Animal;
      sub speak {
        my $class = shift;
        print &#34;a $class goes &#34;, $class-&gt;sound, &#34;!\n&#34;
      }
    }
</pre>
<p class="Pp">然后,在每个动物那里
    &#34;继承，inherits&#34;
    <span class="Li">&#34;Animal&#34;</span> 类,
    同时赋予每个动物各自的声音:</p>
<p class="Pp"></p>
<pre>    { package Cow;
      @ISA = qw(Animal);
      sub sound { &#34;moooo&#34; }
    }
</pre>
<p class="Pp">注意增加的数组
    <span class="Li">@ISA</span> .
    我们马上讲到它.</p>
<p class="Pp">现在当我们调用
    <span class="Li">&#34;Cow-&gt;speak&#34;</span>
    时会发生什么?</p>
<p class="Pp">首先,
    Perl构造参数列表.
    在这种情况下, 只有
    <span class="Li">&#34;Cow&#34;</span>. 然后Perl
    查找 <span class="Li">&#34;Cow::speak&#34;</span>.
    但是找不到,
    所以Perl检查继承数组
    <span class="Li">@Cow::ISA</span>. 找到了,
    那里只有一个
    <span class="Li">&#34;Animal&#34;</span></p>
<p class="Pp">Perl 然后在
    <span class="Li">&#34;Animal&#34;</span> 中查找
    <span class="Li">&#34;speak&#34;</span>,
    <span class="Li">&#34;Animal::speak&#34;</span>. 找到了,
    然后调用该子程序,
    参数在一开始就被固定了.</p>
<p class="Pp">在子程序
    <span class="Li">&#34;Animal::speak&#34;</span> 中,
    <span class="Li">$class</span> 是
    <span class="Li">&#34;Cow&#34;</span>
    (第一个参数).
    在我们调用
    <span class="Li">&#34;$class-&gt;sound&#34;</span> 时,
    首先寻找
    <span class="Li">&#34;Cow-&gt;sound&#34;</span> ,
    找到了, 因此不用查看
    <span class="Li">@ISA</span>. 成功!
  <br/>
</p>
<p class="Pp"><b>关于@ISA应该注意的几点问题</b></p>
<p class="Pp">神奇的 <span class="Li">@ISA</span>
    变量 (读作 &#34;is a&#34; 而不是
    &#34;ice-uh&#34;), 声明了
    <span class="Li">&#34;Cow&#34;</span> 是一个(&#34;is
    a&#34;) <span class="Li">&#34;Animal&#34;</span>。
    注意它是一个数组,而不是一个单值,
    因为在个别情况下,
    需要在几个父类中寻找方法.</p>
<p class="Pp">如果 <span class="Li">&#34;Animal&#34;</span>
    也有一个 <span class="Li">@ISA</span>,
    我们也要查看它.
    寻找是递归的,深度优先,在每个
    <span class="Li">@ISA</span>
    中从左到右寻找.
    一般地,每个 <span class="Li">@ISA</span>
    只有一个元素(多元素意味着多继承和多重的头痛),
    这样我们可以得到一个漂亮的继承树.</p>
<p class="Pp">如果使用 <span class="Li">&#34;use
    strict&#34;</span>, @ISA会引起抱怨,
    因为它不是含有显式包名的变量,
    也不是字典变量 (&#34;my&#34;).
    我们不能把它用做&#34;my&#34;变量(它必须属于所继承的包),但是也还是有几种解决的办法.</p>
<p class="Pp">最简单的办法是加上包名:</p>
<p class="Pp"></p>
<pre>    @Cow::ISA = qw(Animal);
</pre>
<p class="Pp">或者使用包声明:</p>
<p class="Pp"></p>
<pre>    package Cow;
    use vars qw(@ISA);
    @ISA = qw(Animal);
</pre>
<p class="Pp">如果你希望把包放到程序内,
    可以把:</p>
<p class="Pp"></p>
<pre>    package Cow;
    use Animal;
    use vars qw(@ISA);
    @ISA = qw(Animal);
</pre>
<p class="Pp">简写为:</p>
<p class="Pp"></p>
<pre>    package Cow;
    use base qw(Animal);
</pre>
<p class="Pp">这就精简多了.
  <br/>
</p>
<p class="Pp"><b>Overriding the methods 方法重载</b></p>
<p class="Pp">让我们添上一只老鼠,
    它的声音差不多听不到:</p>
<p class="Pp"></p>
<pre>    # Animal package from before
    { package Mouse;
      @ISA = qw(Animal);
      sub sound { &#34;squeak&#34; }
      sub speak {
        my $class = shift;
        print &#34;a $class goes &#34;, $class-&gt;sound, &#34;!\n&#34;;
        print &#34;[but you can barely hear it!]\n&#34;;
      }
    }
</pre>
<p class="Pp"></p>
<pre>    Mouse-&gt;speak;
</pre>
<p class="Pp">输出为:</p>
<p class="Pp"></p>
<pre>    a Mouse goes squeak!
    [but you can barely hear it!]
</pre>
<p class="Pp">在这里,
    <span class="Li">&#34;Mouse&#34;</span>
    有它自己的speak 函数,
    所以 <span class="Li">&#34;Mouse-&gt;speak&#34;</span>
    不会调用<span class="Li">&#34;Animal-&gt;speak&#34;</span>.
    这叫做重载 &#34;overriding&#34;.
    实际上,
    我们甚至不用说<span class="Li">&#34;Mouse&#34;</span>
    是 <span class="Li">&#34;Animal&#34;</span>, 因为
    <span class="Li">&#34;speak&#34;</span>
    所用到的所有方法在
    <span class="Li">&#34;Mouse&#34;</span>
    中都有定义.</p>
<p class="Pp">但是有些代码与
    <span class="Li">&#34;Animal-&gt;speak&#34;</span>
    的相同 ,
    这在程序维护时是个问题.
    我们能不能让
    <span class="Li">&#34;Mouse&#34;</span> 与其它
    <span class="Li">&#34;Animal&#34;</span>
    作相同的事,但是给它加上特殊的部分呢?
    可以!</p>
<p class="Pp">首先,我们可以直接调用
    <span class="Li">&#34;Animal::speak&#34;</span> 方法:</p>
<p class="Pp"></p>
<pre>    # Animal package from before
    { package Mouse;
      @ISA = qw(Animal);
      sub sound { &#34;squeak&#34; }
      sub speak {
        my $class = shift;
        Animal::speak($class);
        print &#34;[but you can barely hear it!]\n&#34;;
      }
    }
</pre>
<p class="Pp">注意我们必须使用
    <span class="Li">$class</span>
    (几乎肯定是<span class="Li">&#34;Mouse&#34;</span>)
    作为 <span class="Li">&#34;Animal::speak&#34;</span>
    的第一个参数,
    因为我们没有用箭头符号.
    那为什么不用呢? 嗯,
    如果我们在那儿调用
    <span class="Li">&#34;Animal-&gt;speak&#34;</span>,
    则第一个参数是
    <span class="Li">&#34;Animal&#34;</span> 而不是
    <span class="Li">&#34;Mouse&#34;</span> ,
    这样当调用
    <span class="Li">&#34;sound&#34;</span> 时,
    就找不到正确的函数了.</p>
<p class="Pp">虽然如此,直接调用
    <span class="Li">&#34;Animal::speak&#34;</span>
    确实不怎么好. 万一
    <span class="Li">&#34;Animal::speak&#34;</span> 不存在,
    而是继承自
    <span class="Li">@Animal::ISA</span>
    中的某个类呢?
    因为没有使用箭头符号,
    我们只有一次机会去调用正确的函数.</p>
<p class="Pp">还要注意到,现在类名
    <span class="Li">&#34;Animal&#34;</span>
    直接在子程序中使用.
    如果维护代码的人没有注意到这一点,
    改变了 &lt;Mouse&gt; 的
    <span class="Li">@ISA</span>，没有注意到
    <span class="Li">&#34;speak&#34;</span> 用到了
    <span class="Li">&#34;Animal&#34;</span>
    那就会出问题. 因此,
    这可能不是一个好方法.
  <br/>
</p>
<p class="Pp"><b>Starting the search from a different place
    从其它地方开始寻找</b></p>
<p class="Pp">较好的解决办法是让Perl从继承链的上一级开始寻找:</p>
<p class="Pp"></p>
<pre>    # same Animal as before
    { package Mouse;
      # same @ISA, &amp;sound as before
      sub speak {
        my $class = shift;
        $class-&gt;Animal::speak;
        print &#34;[but you can barely hear it!]\n&#34;;
      }
    }
</pre>
<p class="Pp">这就对了.
    使用这一语法, 我们从
    <span class="Li">&#34;Animal&#34;</span> 寻找
    <span class="Li">&#34;speak&#34;</span>,
    在找不到时寻找
    <span class="Li">&#34;Animal&#34;</span>
    的继承链.且第一个参数是
    <span class="Li">$class</span>, 所以
    <span class="Li">&#34;speak&#34;</span>
    和<span class="Li">&#34;Mouse::sound&#34;</span>
    都会被正确地调用.</p>
<p class="Pp">但这还不是最好的方法.我们还必须调整
    <span class="Li">@ISA</span> 的元素顺序.
    更糟糕的是, 如果
    <span class="Li">&#34;Mouse&#34;</span>
    有多个父类在
    <span class="Li">@ISA</span>,
    我们还要知道哪个类定义了
    <span class="Li">&#34;speak&#34;</span>.
    那么,有没有更好的办法呢?
  <br/>
</p>
<p class="Pp"><b>The SUPER way of doing things
    使用SUPER方法</b></p>
<p class="Pp">通过把
    <span class="Li">&#34;Animal&#34;</span> 改成
    <span class="Li">&#34;SUPER&#34;</span> 类,
    程序可以自动在所有父类中(<span class="Li">@ISA</span>):</p>
<p class="Pp"></p>
<pre>    # same Animal as before
    { package Mouse;
      # same @ISA, &amp;sound as before
      sub speak {
        my $class = shift;
        $class-&gt;SUPER::speak;
        print &#34;[but you can barely hear it!]\n&#34;;
      }
    }
</pre>
<p class="Pp"><span class="Li">&#34;SUPER::speak&#34;</span>
    意味着在当前包的
    <span class="Li">@ISA</span> 中寻找
    <span class="Li">&#34;speak&#34;</span>,
    调用第一个找到的函数。注意它不会查找
    <span class="Li">$class</span> 的 <span class="Li">@ISA</span>
  <br/>
</p>
<p class="Pp"><b>Where we&#39;re at so
    far...到现在为止我们学了些什么</b></p>
<p class="Pp">我们已经看到了箭头符号语法:</p>
<p class="Pp"></p>
<pre>  Class-&gt;method(@args);
</pre>
<p class="Pp">和它的等价形式:</p>
<p class="Pp"></p>
<pre>  $a = &#34;Class&#34;;
  $a-&gt;method(@args);
</pre>
<p class="Pp">它们构造这样一个参数列表:</p>
<p class="Pp"></p>
<pre>  (&#34;Class&#34;, @args)
</pre>
<p class="Pp">并调用</p>
<p class="Pp"></p>
<pre>  Class::method(&#34;Class&#34;, @Args);
</pre>
<p class="Pp">但是，如果找不到
    <span class="Li">&#34;Class::method&#34;</span>,
    程序会查看 <span class="Li">@Class::ISA</span>
    (递归的) 找到一个包含
    <span class="Li">&#34;method&#34;</span>
    的包,然后执行它.</p>
<p class="Pp">使用这种简单的语法,
    我们可以有类方法,(多)继承,重载,以及其它扩展.
    使用我们已经学到的东西,
    我们可以析出公共的代码,以各种不同的形式重用同一工具.
    这是对象能够提供的核心内容,
    但是对象还能够提供实例数据,
    这一点我们还没有涉及.
  <br/>
</p>
<p class="Pp"><b>A horse is a horse, of course of course -- or is it?
    马就是马——真的是这样吗?</b></p>
<p class="Pp">我们从
    <span class="Li">&#34;Animal&#34;</span> 和
    <span class="Li">&#34;Horse&#34;</span>
    类的代码开始:</p>
<p class="Pp"></p>
<pre>  { package Animal;
    sub speak {
      my $class = shift;
      print &#34;a $class goes &#34;, $class-&gt;sound, &#34;!\n&#34;
    }
  }
  { package Horse;
    @ISA = qw(Animal);
    sub sound { &#34;neigh&#34; }
  }
</pre>
<p class="Pp">这样使得我们调用
    <span class="Li">&#34;Horse-&gt;speak&#34;</span>，从而向上调用
    <span class="Li">&#34;Animal::speak&#34;</span>，然后调用
    <span class="Li">&#34;Horse::sound&#34;</span>
    来获得指定的声音，输出为:</p>
<p class="Pp"></p>
<pre>  a Horse goes neigh!
</pre>
<p class="Pp">但是我们所有的马都是相同的.
    如果我增加一个子程序,
    所有的马都会共享它.
    这在创建相同的马时确实不错,
    但是我们如何能够区分不同的马呢?
    比如,
    假设我想给我的第一匹马起个名字.
    应该有办法使得它的名字和别的马的名字不同.</p>
<p class="Pp">这可以通过创建一个
    &#34;实例,instance&#34; 来实现.
    实例是由类创建的.
    在Perl中,
    任何引用都可以是实例,
    就让我们从最简单的引用开始吧,一个标量引用:</p>
<p class="Pp"></p>
<pre>  my $name = &#34;Mr. Ed&#34;;
  my $talking = \$name;
</pre>
<p class="Pp">现在 <span class="Li">$talking</span>
    是指向实例特有数据(
    <span class="Li">$name</span>
    )的引用。把这个引用变成真正的实例的是一个特殊的操作符,叫做
    <span class="Li">&#34;bless&#34;</span>:</p>
<p class="Pp"></p>
<pre>  bless $talking, Horse;
</pre>
<p class="Pp">这个操作符把包名
    <span class="Li">&#34;Horse&#34;</span>
    中的所有信息存放到引用所指向的东西中.
    这时,我们说 <span class="Li">$talking</span>
    是 <span class="Li">&#34;Horse&#34;</span>
    的一个实例 . 也就是说,
    它是一匹独特的马.
    引用并没有改变,
    还可以用于间接引用操作符.
  <br/>
</p>
<p class="Pp"><b>Invoking an instance method
    调用实例方法</b></p>
<p class="Pp">箭头符号可以用于实例.
    那么, 听听 <span class="Li">$talking</span>
    的声音吧:</p>
<p class="Pp"></p>
<pre>  my $noise = $talking-&gt;sound;
</pre>
<p class="Pp">要调用
    <span class="Li">&#34;sound&#34;</span>, Perl
    首先注意到 <span class="Li">$talking</span>
    是一个 blessed 引用
    (因此是一个实例).
    它会构造一个参数列表,
    现在只有 <span class="Li">$talking</span>.
    (在后面我们会看到参数们在实例变量之后,
    与使用类时相似.)</p>
<p class="Pp">然后,是真正有意思的部分:
    Perl 查找实例所属的类,
    这里是 <span class="Li">&#34;Horse&#34;</span>,
    在其中寻找对应的方法.
    这里, <span class="Li">&#34;Horse::sound&#34;</span>
    直接可以找到(不用使用继承),
    最后这样调用:</p>
<p class="Pp"></p>
<pre>  Horse::sound($talking)
</pre>
<p class="Pp">注意这里的第一个参数还是实例本身,
    而不像前面我们学到的是类名.
    最后返回值是
    <span class="Li">&#34;neigh&#34;</span>,
    它被赋值给 <span class="Li">$noise</span>
    变量.</p>
<p class="Pp">如果找不到 Horse::sound,
    会在 <span class="Li">@Horse::ISA</span>
    列表中查找.
    类方法与实例方法的唯一区别是调用时的第一个参数是实例(一个blessed引用)还是一个类名(一个字符串).
  <br/>
</p>
<p class="Pp"><b>Accessing the instance data
    访问实例数据</b></p>
<p class="Pp">因为我们得到的第一个参数是实例,我们可以访问实例特有的数据.
    我们可以取得马的名字:</p>
<p class="Pp"></p>
<pre>  { package Horse;
    @ISA = qw(Animal);
    sub sound { &#34;neigh&#34; }
    sub name {
      my $self = shift;
      $$self;
    }
  }
</pre>
<p class="Pp">现在,我们调用名字:</p>
<p class="Pp"></p>
<pre>  print $talking-&gt;name, &#34; says &#34;, $talking-&gt;sound, &#34;\n&#34;;
</pre>
<p class="Pp">在 <span class="Li">&#34;Horse::name&#34;</span> 中,
    <span class="Li">@_</span> 数组仅含有
    <span class="Li">$talking</span>, shift 将
    <span class="Li">$talking</span> 赋给了
    <span class="Li">$self</span>.
    (传统上我们在处理实例方法时总是把第一个元素赋给
    <span class="Li">$self</span>,
    所以你也应该这么做,
    除非你有不这样做的充分理由.)
    然后, <span class="Li">$self</span>
    被标量化,成为 <span class="Li">&#34;Mr.
    Ed&#34;</span>, 这就行了.
  输出是:</p>
<p class="Pp"></p>
<pre>  Mr. Ed says neigh.
</pre>
<br/>
<p class="Pp"><b>How to build a horse
    如何创建一匹马</b></p>
<p class="Pp">当然啦,如果我们手工创建所有的马,
    我们会出很多错误.
    不仅如此,我们还亵渎了面向对象编程的特性,因为在那种情况下马的&#34;内脏&#34;也可见了.
    如果你是兽医的话,这倒正好,
    可是如果你仅仅是个爱马者呢?
    所以,我们让 Horse
    类来创建一匹新马:</p>
<p class="Pp"></p>
<pre>  { package Horse;
    @ISA = qw(Animal);
    sub sound { &#34;neigh&#34; }
    sub name {
      my $self = shift;
      $$self;
    }
    sub named {
      my $class = shift;
      my $name = shift;
      bless \$name, $class;
    }
  }
</pre>
<p class="Pp">现在,我们可以用
    <span class="Li">&#34;named&#34;</span>
    方法创建一匹马:</p>
<p class="Pp"></p>
<pre>  my $talking = Horse-&gt;named(&#34;Mr. Ed&#34;);
</pre>
<p class="Pp">注意到我们有回到了类方法,
    所以传递给
    <span class="Li">&#34;Horse::named&#34;</span>
    的两个参数是
    <span class="Li">&#34;Horse&#34;</span> 和
    <span class="Li">&#34;Mr. Ed&#34;</span>. &#34;bless&#34;
    操作符不仅将
    <span class="Li">$name</span> 实例化,
    且将指向 <span class="Li">$name</span>
    的引用作为返回值返回.
    这样,
    我们就创建了一匹马.</p>
<p class="Pp">这里,我们调用了构造器
    <span class="Li">&#34;named&#34;</span>,
    它的参数就是特定的
    <span class="Li">&#34;Horse&#34;</span> 的名字.
    你可以使用不同的构造器用不同的名字建立不同的对象(比如记录它的谱系或生日).
    但是,
    你会发现多数使用Perl的人更喜欢把构造器命名为
    <span class="Li">&#34;new&#34;</span>,
    并使用不同的方法解释
    <span class="Li">&#34;new&#34;</span> 的参数.
    两种都挺好,只要你能创建对象就行.
    (你会自己创建一个,对吗?)
  <br/>
</p>
<p class="Pp"><b>Inheriting the constructor
    继承构造器</b></p>
<p class="Pp">但是那个方法中有没有什么对于
    <span class="Li">&#34;Horse&#34;</span>
    来说比较特殊的东西呢?
    没有. 因此, 从
    <span class="Li">&#34;Animal&#34;</span>
    创建其它任何东西也可以使用相同的方法,我们来试试::</p>
<p class="Pp"></p>
<pre>  { package Animal;
    sub speak {
      my $class = shift;
      print &#34;a $class goes &#34;, $class-&gt;sound, &#34;!\n&#34;
    }
    sub name {
      my $self = shift;
      $$self;
    }
    sub named {
      my $class = shift;
      my $name = shift;
      bless \$name, $class;
    }
  }
  { package Horse;
    @ISA = qw(Animal);
    sub sound { &#34;neigh&#34; }
  }
</pre>
<p class="Pp">好了,
    但是以实例调用
    <span class="Li">&#34;speak&#34;</span>
    会产生什么结果呢?</p>
<p class="Pp"></p>
<pre>  my $talking = Horse-&gt;named(&#34;Mr. Ed&#34;);
  $talking-&gt;speak;
</pre>
<p class="Pp">我们得到的是:</p>
<p class="Pp"></p>
<pre>  a Horse=SCALAR(0xaca42ac) goes neigh!
</pre>
<p class="Pp">为什么?因为
    <span class="Li">&#34;Animal::speak&#34;</span>
    希望它的第一个参数是类名,
    而不是实例.
    当实例被传入时,我们希望使用的是字符串而不是实例本身,显示的结果不是我们所希望的.
  <br/>
</p>
<p class="Pp"><b>Making a method work with either classes or instances
    使方法同时支持类和实例</b></p>
<p class="Pp">我们需要做的是让方法检测它是被实例调用的还是被类调用的.
    最直接的方法是使用
    <span class="Li">&#34;ref&#34;</span> 操作符.
    它在参数是实例时返回字符串,在参数是类名时返回
    <span class="Li">&#34;undef&#34;</span>.
    我们首先改写
    <span class="Li">&#34;name&#34;</span> 方法:</p>
<p class="Pp"></p>
<pre>  sub name {
    my $either = shift;
    ref $either
      ? $$either # it&#39;s an instance, return name
      : &#34;an unnamed $either&#34;; # it&#39;s a class, return generic
  }
</pre>
<p class="Pp">在这儿, <span class="Li">&#34;?:&#34;</span>
    操作符决定是选择间接引用(dereference)还是派生字符串.
    现在我们可以同时使用类或实例了.
    注意我修改了第一个参数为
    <span class="Li">$either</span>
    来表示期望的变化:</p>
<p class="Pp"></p>
<pre>  my $talking = Horse-&gt;named(&#34;Mr. Ed&#34;);
  print Horse-&gt;name, &#34;\n&#34;; # prints &#34;an unnamed Horse\n&#34;
  print $talking-&gt;name, &#34;\n&#34;; # prints &#34;Mr Ed.\n&#34;
</pre>
<p class="Pp">我们可以改写
    <span class="Li">&#34;speak&#34;</span> :</p>
<p class="Pp"></p>
<pre>  sub speak {
    my $either = shift;
    print $either-&gt;name, &#34; goes &#34;, $either-&gt;sound, &#34;\n&#34;;
  }
</pre>
<p class="Pp">而 <span class="Li">&#34;sound&#34;</span>
    本来就可以工作.
    那么现在就一切完成了!
  <br/>
</p>
<p class="Pp"><b>Adding parameters to a method
    给方法加参数</b></p>
<p class="Pp">让我们训练动物们吃饭:</p>
<p class="Pp"></p>
<pre>  { package Animal;
    sub named {
      my $class = shift;
      my $name = shift;
      bless \$name, $class;
    }
    sub name {
      my $either = shift;
      ref $either
        ? $$either # it&#39;s an instance, return name
        : &#34;an unnamed $either&#34;; # it&#39;s a class, return generic
    }
    sub speak {
      my $either = shift;
      print $either-&gt;name, &#34; goes &#34;, $either-&gt;sound, &#34;\n&#34;;
    }
    sub eat {
      my $either = shift;
      my $food = shift;
      print $either-&gt;name, &#34; eats $food.\n&#34;;
    }
  }
  { package Horse;
    @ISA = qw(Animal);
    sub sound { &#34;neigh&#34; }
  }
  { package Sheep;
    @ISA = qw(Animal);
    sub sound { &#34;baaaah&#34; }
  }
</pre>
<p class="Pp">试试吧:</p>
<p class="Pp"></p>
<pre>  my $talking = Horse-&gt;named(&#34;Mr. Ed&#34;);
  $talking-&gt;eat(&#34;hay&#34;);
  Sheep-&gt;eat(&#34;grass&#34;);
</pre>
<p class="Pp">输出为:</p>
<p class="Pp"></p>
<pre>  Mr. Ed eats hay.
  an unnamed Sheep eats grass.
</pre>
<p class="Pp">有参数的实例方法调用时首先得到实例的引用，然后得到参数的列表。因此第一个调用实际上是这样的:</p>
<p class="Pp"></p>
<pre>  Animal::eat($talking, &#34;hay&#34;);
</pre>
<br/>
<p class="Pp"><b>More interesting instances
    更多有趣的实例</b></p>
<p class="Pp">如果实例需要更多的数据该怎么办呢?
    更多的项目产生更有趣的实例,
    每个项目可以是一个引用或者甚至是一个对象.
    最简单的方法是把它们存放到哈希中.
    哈希中的关键词叫做&#39;实例变量&#34;(instance
    variables)或者&#34;成员变量&#34;(member
    variables)，相应的值也就是变量的值。</p>
<p class="Pp">但是我们怎么把马放到哈希中呢?
    回忆到对象是被实例化(blessed)的引用.
    我们可以简单地创建一个祝福了的哈希引用,同时相关的的内容也作些修改就可以了.</p>
<p class="Pp">让我们创建一只有名字有颜色的绵羊：</p>
<p class="Pp"></p>
<pre>  my $bad = bless { Name =&gt; &#34;Evil&#34;, Color =&gt; &#34;black&#34; }, Sheep;
</pre>
<p class="Pp">那么
    <span class="Li">&#34;$bad-&gt;{Name}&#34;</span> 是
    <span class="Li">&#34;Evil&#34;</span>,
    <span class="Li">&#34;$bad-&gt;{Color}&#34;</span> 是
    <span class="Li">&#34;black&#34;</span>.
    但是我们想通过
    <span class="Li">&#34;$bad-&gt;name&#34;</span>
    存取绵羊的名字name,
    这有点的问题,因为现在它期望一个标量引用.
    别担心,因为修正它很简单:</p>
<p class="Pp"></p>
<pre>  ## in Animal
  sub name {
    my $either = shift;
    ref $either ?
      $either-&gt;{Name} :
      &#34;an unnamed $either&#34;;
  }
</pre>
<p class="Pp"><span class="Li">&#34;named&#34;</span>
    当然还是创建标量的绵羊,
    如下修正就好了:</p>
<p class="Pp"></p>
<pre>  ## in Animal
  sub named {
    my $class = shift;
    my $name = shift;
    my $self = { Name =&gt; $name, Color =&gt; $class-&gt;default_color };
    bless $self, $class;
  }
</pre>
<p class="Pp">默认颜色
    <span class="Li">&#34;default_color&#34;</span> 是什么?
    嗯, 如果 <span class="Li">&#34;named&#34;</span>
    只有一个参数name,
    我们还是希望有个颜色,
    所以我们设定一个类初始化颜色.
    对绵羊来说,
    白色比较好:</p>
<p class="Pp"></p>
<pre>  ## in Sheep
  sub default_color { &#34;white&#34; }
</pre>
<p class="Pp">为了避免为每个类定义颜色,
    我们可以在
    <span class="Li">&#34;Animal&#34;</span>
    中定义一个
    &#34;缺省的缺省，backstop&#34;
    的颜色:</p>
<p class="Pp"></p>
<pre>  ## in Animal
  sub default_color { &#34;brown&#34; }
</pre>
<p class="Pp">现在, 因为只有
    <span class="Li">&#34;name&#34;</span> 和
    <span class="Li">&#34;named&#34;</span> 与对象的
    &#34;结构，structure&#34; 相关,
    其余的部分可以保持不变,
    所以 <span class="Li">&#34;speak&#34;</span>
    工作正常.
  <br/>
</p>
<p class="Pp"><b>A horse of a different color
    一匹不同颜色的马</b></p>
<p class="Pp">但是如果所有的马都是棕色的,也挺烦人的.
    所以我们可以写个方法来改变马的颜色.</p>
<p class="Pp"></p>
<pre>  ## in Animal
  sub color {
    $_[0]-&gt;{Color}
  }
  sub set_color {
    $_[0]-&gt;{Color} = $_[1];
  }
</pre>
<p class="Pp">注意到存取参数的不同方法了吗:
    <span class="Li">$_[0]</span> 直接使用,
    而没有用 <span class="Li">&#34;shift&#34;</span>.
    (这在我们频繁存取时可以节省一些时间.)
    现在我们可以把Mr.
    Ed的颜色变过来:</p>
<p class="Pp"></p>
<pre>  my $talking = Horse-&gt;named(&#34;Mr. Ed&#34;);
  $talking-&gt;set_color(&#34;black-and-white&#34;);
  print $talking-&gt;name, &#34; is colored &#34;, $talking-&gt;color, &#34;\n&#34;;
</pre>
<p class="Pp">结果是:</p>
<p class="Pp"></p>
<pre>  Mr. Ed is colored black-and-white
</pre>
<br/>
<p class="Pp"><b>Summary 总结</b></p>
<p class="Pp">现在我们讲了类方法,构造器,实例方法,实例数据,甚至还有存取器(accessor).
    但是这些还仅仅是开始.
    我们还没有讲到以两个函数
    getters,setters
    形式出现的存取器，析构器(destructor),间接对象(indirect
    object notation),子类(subclasses that add instance
    data),per-class data,重载(overloading),&#34;isa&#34; 和
    &#34;can&#34;
    测试,公共类(<span class="Li">&#34;UNIVERSAL&#34;</span>
    class),等等.
    这有待其它文档去讲解了.
    无论如何,希望本文使你对对象有所了解.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO_参见">SEE ALSO 参见<a class="anchor" href="#SEE_ALSO_%E5%8F%82%E8%A7%81">¶</a></h1>
更多信息可参见 perlobj
  (这里有更多的Perl对象的细节,而本文的是基础),
  perltoot
  (面向对象的中级教程),
  perlbot (更多的技巧),
  以及书籍,比如Damian
  Conway的不错的书叫做《面向对象的Perl
  (<i>Object Oriented Perl</i>)》。
<p class="Pp">某些模块可能对你有用，它们是
    Class::Accessor, Class::Class, Class::Contract, Class::Data::Inheritable,
    Class::MethodMaker 还有 Tie::SecureHash</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT">COPYRIGHT<a class="anchor" href="#COPYRIGHT">¶</a></h1>
Copyright (c) 1999, 2000 by Randal L. Schwartz and Stonehenge Consulting
  Services, Inc. Permission is hereby granted to distribute this document intact
  with the Perl distribution, and in accordance with the licenses of the Perl
  distribution; derived documents must include this copyright notice intact.
<p class="Pp">Portions of this text have been derived from Perl Training
    materials originally appearing in the <i>Packages, References, Objects,
    and</i> <i>Modules</i> course taught by instructors for Stonehenge
    Consulting Services, Inc. and used with permission.</p>
<p class="Pp">Portions of this text have been derived from materials originally
    appearing in <i>Linux Magazine</i> and used with permission.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="中文版维护人">中文版维护人<a class="anchor" href="#%E4%B8%AD%E6%96%87%E7%89%88%E7%BB%B4%E6%8A%A4%E4%BA%BA">¶</a></h1>
<b>redcandle &lt;redcandle51@chinaren.com&gt;</b>
</section>
<section class="Sh">
<h1 class="Sh" id="中文版最新更新">中文版最新更新<a class="anchor" href="#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%80%E6%96%B0%E6%9B%B4%E6%96%B0">¶</a></h1>
<b>2001年12月9日星期日</b>
</section>
<section class="Sh">
<h1 class="Sh" id="中文手册页翻译计划">中文手册页翻译计划<a class="anchor" href="#%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C%E9%A1%B5%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92">¶</a></h1>
<b><a href="../..//cmpp.linuxforum.net</a></b>
<br/>
<p class="Pp"><b>跋</b></p>
<p class="Pp">本页面中文版由中文
    man 手册页计划提供。
  <br/>
  中文 man
    手册页计划：<b><a href="../../man-pages-zh/manpages-zh">../../man-pages-zh/manpages-zh</a></b></p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">2003-11-25</td>
    <td class="foot-os">perl v5.8.3</td>
  </tr>
</tbody></table>
</div>
</div>
</div>
<div id="footer">

<p><table>
<tr>
<td>
Source file:
</td>
<td>
perlboot.7.zh_CN.gz (from <a href="../../package/manpages-zh/1.6.3.3-1/">manpages-zh 1.6.3.3-1</a>)
</td>
</tr>

<tr>
<td>
Source last updated:
</td>
<td>
2018-04-28T10:54:36Z
</td>
</tr>

<tr>
<td>
Converted to HTML:
</td>
<td>
2019-10-28T03:40:56Z
</td>
</tr>
</table></p>

<hr>
<div id="fineprint">
<p>debiman HEAD, see <a
href="../../Debian/debiman/">github.com/Debian/debiman</a>.
Found a problem? See the <a href="../../faq.html">FAQ</a>.</p>
</div>
</div>
<script type="text/javascript">
(function(a){"use strict";var b=function(b,c,d){var e=a.document;var f=e.createElement("link");var g;if(c)g=c;else{var h=(e.body||e.getElementsByTagName("head")[0]).childNodes;g=h[h.length-1];}var i=e.styleSheets;f.rel="stylesheet";f.href=b;f.media="only x";function j(a){if(e.body)return a();setTimeout(function(){j(a);});}j(function(){g.parentNode.insertBefore(f,(c?g:g.nextSibling));});var k=function(a){var b=f.href;var c=i.length;while(c--)if(i[c].href===b)return a();setTimeout(function(){k(a);});};function l(){if(f.addEventListener)f.removeEventListener("load",l);f.media=d||"all";}if(f.addEventListener)f.addEventListener("load",l);f.onloadcssdefined=k;k(l);return f;};if(typeof exports!=="undefined")exports.loadCSS=b;else a.loadCSS=b;}(typeof global!=="undefined"?global:this));
(function(a){if(!a.loadCSS)return;var b=loadCSS.relpreload={};b.support=function(){try{return a.document.createElement("link").relList.supports("preload");}catch(b){return false;}};b.poly=function(){var b=a.document.getElementsByTagName("link");for(var c=0;c<b.length;c++){var d=b[c];if(d.rel==="preload"&&d.getAttribute("as")==="style"){a.loadCSS(d.href,d);d.rel=null;}}};if(!b.support()){b.poly();var c=a.setInterval(b.poly,300);if(a.addEventListener)a.addEventListener("load",function(){a.clearInterval(c);});if(a.attachEvent)a.attachEvent("onload",function(){a.clearInterval(c);});}}(this));
</script>

<script type="application/ld+json">
"{\"@context\":\"../../contents-buster.html\",\"name\":\"buster\"}},{\"@type\":\"ListItem\",\"position\":2,\"item\":{\"@type\":\"Thing\",\"@id\":\"/buster/manpages-zh/index.html\",\"name\":\"manpages-zh\"}},{\"@type\":\"ListItem\",\"position\":3,\"item\":{\"@type\":\"Thing\",\"@id\":\"\",\"name\":\"perlboot(7)\"}}]}"
</script>
