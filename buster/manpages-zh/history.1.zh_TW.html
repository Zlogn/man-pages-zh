<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>history(1) — manpages-zh — Debian buster — Debian Manpages</title>
<style type="text/css">
@font-face {
  font-family: 'Inconsolata';
  src: local('Inconsolata'), url(/Inconsolata.woff2) format('woff2'), url(/Inconsolata.woff) format('woff');
}

@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 400;
  src: local('Roboto'), local('Roboto Regular'), local('Roboto-Regular'), url(/Roboto-Regular.woff2) format('woff2'), url(/Roboto-Regular.woff) format('woff');
}

body {
	color: #000;
	background-color: white;
	background-image: linear-gradient(to bottom, #d7d9e2, #fff 70px);
	background-position: 0 0;
	background-repeat: repeat-x;
	font-family: sans-serif;
	font-size: 100%;
	line-height: 1.2;
	letter-spacing: 0.15px;
	margin: 0;
	padding: 0;
}

#header {
	padding: 0 10px 0 52px;
}

#logo {
	position: absolute;
	top: 0;
	left: 0;
	border-left: 1px solid transparent;
	border-right: 1px solid transparent;
	border-bottom: 1px solid transparent;
	width: 50px;
	height: 5.07em;
	min-height: 65px;
}

#logo a {
	display: block;
	height: 100%;
}

#logo img {
	margin-top: 5px;
	position: absolute;
	bottom: 0.3em;
	overflow: auto;
	border: 0;
}

p.section {
	margin: 0;
	padding: 0 5px 0 5px;
	font-size: 13px;
	line-height: 16px;
	color: white;
	letter-spacing: 0.08em;
	position: absolute;
	top: 0px;
	left: 52px;
	background-color: #c70036;
}

p.section a {
	color: white;
	text-decoration: none;
}

.hidecss {
	display: none;
}

#searchbox {
	text-align:left;
	line-height: 1;
	margin: 0 10px 0 0.5em;
	padding: 1px 0 1px 0;
	position: absolute;
	top: 0;
	right: 0;
	font-size: .75em;
}

#navbar {
	border-bottom: 1px solid #c70036;
}

#navbar ul {
	margin: 0;
	padding: 0;
	overflow: hidden;
}

#navbar li {
	list-style: none;
	float: left;
}

#navbar a {
	display: block;
	padding: 1.75em .5em .25em .5em;
	color: #0035c7;
	text-decoration: none;
	border-left: 1px solid transparent;
	border-right: 1px solid transparent;
}

#navbar a:hover
, #navbar a:visited:hover {
	background-color: #f5f6f7;
	border-left: 1px solid  #d2d3d7;
	border-right: 1px solid #d2d3d7;
	text-decoration: underline;
}

a:link {
	color: #0035c7;
}

a:visited {
	color: #54638c;
}

#breadcrumbs {
	line-height: 2;
	min-height: 20px;
	margin: 0;
	padding: 0;
	font-size: 0.75em;
	background-color: #f5f6f7;
	border-bottom: 1px solid #d2d3d7;
}

#breadcrumbs:before {
	margin-left: 0.5em;
	margin-right: 0.5em;
}

#content {
    margin: 0 10px 0 52px;
    display: flex;
    flex-direction: row;
}

.paneljump {
    background-color: #d70751;
    padding: 0.5em;
    border-radius: 3px;
    margin-right: .5em;
    display: none;
}

.paneljump a,
.paneljump a:visited,
.paneljump a:hover,
.paneljump a:focus {
    color: white;
}

@media all and (max-width: 800px) {
    #content {
	flex-direction: column;
	margin: 0.5em;
    }
    .paneljump {
	display: block;
    }
}

.panels {
    display: block;
    order: 2;
}

.maincontent {
    width: 100%;
    max-width: 80ch;
    order: 1;
}

.mandoc {
    font-family: monospace;
    font-size: 1.04rem;
}

.mandoc pre {
    white-space: pre-wrap;
}

#footer {
	border: 1px solid #dfdfe0;
	border-left: 0;
	border-right: 0;
	background-color: #f5f6f7;
	padding: 1em;
	margin: 1em 10px 0 52px;
	font-size: 0.75em;
	line-height: 1.5em;
}

hr {
	border-top: 1px solid #d2d3d7;
	border-bottom: 1px solid white;
	border-left: 0;
	border-right: 0;
	margin: 1.4375em 0 1.5em 0;
	height: 0;
	background-color: #bbb;
}

#content p {
    padding-left: 1em;
}

 

a, a:hover, a:focus, a:visited {
    color: #0530D7;
    text-decoration: none;
}

 
.panel {
  padding: 15px;
  margin-bottom: 20px;
  background-color: #ffffff;
  border: 1px solid #dddddd;
  border-radius: 4px;
  -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
          box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
}

.panel-heading, .panel details {
  margin: -15px -15px 0px;
  background-color: #d70751;
  border-bottom: 1px solid #dddddd;
  border-top-right-radius: 3px;
  border-top-left-radius: 3px;
}

.panel-heading, .panel summary {
  padding: 5px 5px;
  font-size: 17.5px;
  font-weight: 500;
  color: #ffffff;
  outline-style: none;
}

.panel summary {
    padding-left: 7px;
}

summary, details {
    display: block;
}

.panel details ul {
  margin: 0;
}

.panel-footer {
  padding: 5px 5px;
  margin: 15px -15px -15px;
  background-color: #f5f5f5;
  border-top: 1px solid #dddddd;
  border-bottom-right-radius: 3px;
  border-bottom-left-radius: 3px;
}
.panel-info {
  border-color: #bce8f1;
}

.panel-info .panel-heading {
  color: #3a87ad;
  background-color: #d9edf7;
  border-color: #bce8f1;
}


.list-group {
  padding-left: 0;
  margin-bottom: 20px;
  background-color: #ffffff;
}

.list-group-item {
  position: relative;
  display: block;
  padding: 5px 5px 5px 5px;
  margin-bottom: -1px;
  border: 1px solid #dddddd;
}

.list-group-item > .list-item-key {
  min-width: 27%;
  display: inline-block;
}
.list-group-item > .list-item-key.versions-repository {
  min-width: 40%;
}
.list-group-item > .list-item-key.versioned-links-version {
  min-width: 40%
}


.versioned-links-icon {
  margin-right: 2px;
}
.versioned-links-icon a {
  color: black;
}
.versioned-links-icon a:hover {
  color: blue;
}
.versioned-links-icon-inactive {
  opacity: 0.5;
}

.list-group-item:first-child {
  border-top-right-radius: 4px;
  border-top-left-radius: 4px;
}

.list-group-item:last-child {
  margin-bottom: 0;
  border-bottom-right-radius: 4px;
  border-bottom-left-radius: 4px;
}

.list-group-item-heading {
  margin-top: 0;
  margin-bottom: 5px;
}

.list-group-item-text {
  margin-bottom: 0;
  line-height: 1.3;
}

.list-group-item:hover {
  background-color: #f5f5f5;
}

.list-group-item.active a {
  z-index: 2;
}

.list-group-item.active {
  background-color: #efefef;
}

.list-group-flush {
  margin: 15px -15px -15px;
}
.panel .list-group-flush {
  margin-top: -1px;
}

.list-group-flush .list-group-item {
  border-width: 1px 0;
}

.list-group-flush .list-group-item:first-child {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}

.list-group-flush .list-group-item:last-child {
  border-bottom: 0;
}

 

.panel {
float: right;
clear: right;
min-width: 200px;
}

.toc {
     
    width: 200px;
}

.toc li {
    font-size: 98%;
    letter-spacing: 0.02em;
    display: flex;
}

.otherversions {
     
    width: 200px;
}

.otherversions li,
.otherlangs li {
    display: flex;
}

.otherversions a,
.otherlangs a {
    flex-shrink: 0;
}

.pkgversion,
.pkgname,
.toc a {
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
}

.pkgversion,
.pkgname {
    margin-left: auto;
    padding-left: 1em;
}

 

.mandoc {
     
    overflow: hidden;
    margin-top: .5em;
    margin-right: 45px;
}
table.head, table.foot {
    width: 100%;
}
.head-vol {
    text-align: center;
}
.head-rtitle {
    text-align: right;
}

 
.spacer, .Pp {
    min-height: 1em;
}

pre {
    margin-left: 2em;
}

.anchor {
    margin-left: .25em;
    visibility: hidden;
}

h1:hover .anchor,
h2:hover .anchor,
h3:hover .anchor,
h4:hover .anchor,
h5:hover .anchor,
h6:hover .anchor {
    visibility: visible;
}

h1, h2, h3, h4, h5, h6 {
    letter-spacing: .07em;
    margin-top: 1.5em;
    margin-bottom: .35em;
}

h1 {
    font-size: 150%;
}

h2 {
    font-size: 125%;
}

@media print {
    #header, #footer, .panel, .anchor, .paneljump {
	display: none;
    }
    #content {
	margin: 0;
    }
    .mandoc {
	margin: 0;
    }
}

 
 

.Bd { }
.Bd-indent {	margin-left: 3.8em; }

.Bl-bullet {	list-style-type: disc;
		padding-left: 1em; }
.Bl-bullet > li { }
.Bl-dash {	list-style-type: none;
		padding-left: 0em; }
.Bl-dash > li:before {
		content: "\2014  "; }
.Bl-item {	list-style-type: none;
		padding-left: 0em; }
.Bl-item > li { }
.Bl-compact > li {
		margin-top: 0em; }

.Bl-enum {	padding-left: 2em; }
.Bl-enum > li { }
.Bl-compact > li {
		margin-top: 0em; }

.Bl-diag { }
.Bl-diag > dt {
		font-style: normal;
		font-weight: bold; }
.Bl-diag > dd {
		margin-left: 0em; }
.Bl-hang { }
.Bl-hang > dt { }
.Bl-hang > dd {
		margin-left: 5.5em; }
.Bl-inset { }
.Bl-inset > dt { }
.Bl-inset > dd {
		margin-left: 0em; }
.Bl-ohang { }
.Bl-ohang > dt { }
.Bl-ohang > dd {
		margin-left: 0em; }
.Bl-tag {	margin-left: 5.5em; }
.Bl-tag > dt {
		float: left;
		margin-top: 0em;
		margin-left: -5.5em;
		padding-right: 1.2em;
		vertical-align: top; }
.Bl-tag > dd {
		clear: right;
		width: 100%;
		margin-top: 0em;
		margin-left: 0em;
		vertical-align: top;
		overflow: auto; }
.Bl-compact > dt {
		margin-top: 0em; }

.Bl-column { }
.Bl-column > tbody > tr { }
.Bl-column > tbody > tr > td {
		margin-top: 1em; }
.Bl-compact > tbody > tr > td {
		margin-top: 0em; }

.Rs {		font-style: normal;
		font-weight: normal; }
.RsA { }
.RsB {		font-style: italic;
		font-weight: normal; }
.RsC { }
.RsD { }
.RsI {		font-style: italic;
		font-weight: normal; }
.RsJ {		font-style: italic;
		font-weight: normal; }
.RsN { }
.RsO { }
.RsP { }
.RsQ { }
.RsR { }
.RsT {		text-decoration: underline; }
.RsU { }
.RsV { }

.eqn { }
.tbl { }

.HP {		margin-left: 3.8em;
		text-indent: -3.8em; }

 

table.Nm { }
code.Nm {	font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Fl {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Cm {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ar {		font-style: italic;
		font-weight: normal; }
.Op {		display: inline; }
.Ic {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ev {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }
.Pa {		font-style: italic;
		font-weight: normal; }

 

.Lb { }
code.In {	font-style: normal;
		font-weight: bold;
		font-family: inherit; }
a.In { }
.Fd {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ft {		font-style: italic;
		font-weight: normal; }
.Fn {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Fa {		font-style: italic;
		font-weight: normal; }
.Vt {		font-style: italic;
		font-weight: normal; }
.Va {		font-style: italic;
		font-weight: normal; }
.Dv {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }
.Er {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }

 

.An { }
.Lk { }
.Mt { }
.Cd {		font-style: normal;
		font-weight: bold;
		font-family: inherit; }
.Ad {		font-style: italic;
		font-weight: normal; }
.Ms {		font-style: normal;
		font-weight: bold; }
.St { }
.Ux { }

 

.Bf {		display: inline; }
.No {		font-style: normal;
		font-weight: normal; }
.Em {		font-style: italic;
		font-weight: normal; }
.Sy {		font-style: normal;
		font-weight: bold; }
.Li {		font-style: normal;
		font-weight: normal;
		font-family: monospace; }

</style>
<script type="text/javascript">
if (!!document['fonts']) {
        var r = "body{font-family:'Roboto',sans-serif;}";
        var i = ".mandoc,.mandoc pre,.mandoc code,p.section{font-family:'Inconsolata',monospace;}";
        var l = function(m) {
                if (!document.body) {
                        document.write("<style>"+m+"</style>");
                } else {
                        document.body.innerHTML+="<style>"+m+"</style>";
                }
        };
         
        new FontFace('Roboto', "local('Roboto'), local('Roboto Regular'), local('Roboto-Regular'), url(/Roboto-Regular.woff2) format('woff2'), url(/Roboto-Regular.woff) format('woff')")
                .load().then(function() { l(r); });
        new FontFace('Inconsolata', "local('Inconsolata'), url(/Inconsolata.woff2) format('woff2'), url(/Inconsolata.woff) format('woff')")
                .load().then(function() { l(i); });
} else {
        var l = document.createElement('link');
        l.rel = 'preload';
        l.href = '/fonts-woff.css';
        l.as = 'style';
        l.onload = function() { this.rel = 'stylesheet'; };
        document.head.appendChild(l);
}
</script>
<link rel="search" title="Debian manpages" type="application/opensearchdescription+xml" href="../../opensearch.xml">
<noscript>
  <style type="text/css">
    body { font-family: 'Roboto', sans-serif; }
    .mandoc, .mandoc pre, .mandoc code, p.section { font-family: 'Inconsolata', monospace; }
  </style>
</noscript>
<link rel="alternate" href="../../buster/manpages-zh/history.1.zh_CN.html" hreflang="zh-CN">
<link rel="alternate" href="../../buster/manpages-zh/history.1.zh_TW.html" hreflang="zh-TW">
</head>
<body>
<div id="header">
   <div id="upperheader">
   <div id="logo">
  <a href="../../" title="Debian Home"><img src="../../openlogo-50.svg" alt="Debian" width="50" height="61"></a>
  </div>
  <p class="section"><a href="../../">MANPAGES</a></p>
  <div id="searchbox">
    <form action="../../jump" method="get">
      <input type="hidden" name="suite" value="buster">
      <input type="hidden" name="binarypkg" value="manpages-zh">
      <input type="hidden" name="section" value="1">
      <input type="hidden" name="language" value="zh_TW">
      <input type="text" name="q" placeholder="manpage name" required>
      <input type="submit" value="Jump">
    </form>
  </div>
 </div>
<div id="navbar">
<p class="hidecss"><a href="#content">Skip Quicknav</a></p>
<ul>
   <li><a href="../../">Index</a></li>
   <li><a href="../../about.html">About Manpages</a></li>
   <li><a href="../../faq.html">FAQ</a></li>
   <li><a href="../../manpages.debian.org">Service Information</a></li>
</ul>
</div>
   <p id="breadcrumbs">&nbsp;
     
     &#x2F; <a href="../../contents-buster.html">buster</a>
     
     
     
     &#x2F; <a href="../../buster/manpages-zh/index.html">manpages-zh</a>
     
     
     
     &#x2F; history(1)
     
     </p>
</div>
<div id="content">


<div class="panels" id="panels">
<div class="panel" role="complementary">
<div class="panel-heading" role="heading">
links
</div>
<div class="panel-body">
<ul class="list-group list-group-flush">
<li class="list-group-item">
<a href="../../buster/manpages-zh/history.1">language-indep link</a>
</li>
<li class="list-group-item">
<a href="../../pkg/manpages-zh">package tracker</a>
</li>
<li class="list-group-item">
<a href="../../buster/manpages-zh/history.1.zh_TW.gz">raw man page</a>
</li>
</ul>
</div>
</div>

<div class="panel toc" role="complementary" style="padding-bottom: 0">
<details>
<summary>
table of contents
</summary>
<div class="panel-body">
<ul class="list-group list-group-flush">

<li class="list-group-item">
  <a class="toclink" href="#NAME" title="NAME">NAME</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E6%A6%82%E8%BF%B0%28SYNOPSIS%29" title="概述(SYNOPSIS)">概述(SYNOPSIS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E7%89%88%E6%AC%8A%E6%89%80%E6%9C%89%28COPYRIGHT%29" title="版權所有(COPYRIGHT)">版權所有(COPYRIGHT)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E6%8F%8F%E8%BF%B0%28DESCRIPTION%29" title="描述(DESCRIPTION)">描述(DESCRIPTION)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E9%81%B8%E9%A0%85%28OPTIONS%29" title="選項(OPTIONS)">選項(OPTIONS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%8F%83%E6%95%B8%28ARGUMENTS%29" title="參數(ARGUMENTS)">參數(ARGUMENTS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%95%93%E5%8B%95%28INVOCATION%29" title="啓動(INVOCATION)">啓動(INVOCATION)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%AE%9A%E7%BE%A9%28DEFINITIONS%29" title="定義(DEFINITIONS)">定義(DEFINITIONS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E4%BF%9D%E7%95%99%E5%AD%97%28&amp;amp;amp;amp;amp;%2334;RESERVED_WORDS&amp;amp;amp;amp;amp;%2334;%29" title="保留字(&amp;amp;amp;amp;amp;#34;RESERVED WORDS&amp;amp;amp;amp;amp;#34;)">保留字(&amp;amp;amp;amp;amp;#34;RESERVED WORDS&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#shell%E8%AA%9E%E6%B3%95%28&amp;amp;amp;amp;amp;%2334;SHELL_GRAMMAR&amp;amp;amp;amp;amp;%2334;%29" title="shell語法(&amp;amp;amp;amp;amp;#34;SHELL GRAMMAR&amp;amp;amp;amp;amp;#34;)">shell語法(&amp;amp;amp;amp;amp;#34;SHELL GRAMMAR&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E8%A8%BB%E9%87%8B%28COMMENTS%29" title="註釋(COMMENTS)">註釋(COMMENTS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%BC%95%E7%94%A8%28QUOTING%29" title="引用(QUOTING)">引用(QUOTING)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%8F%83%E6%95%B8%28PARAMETERS%29" title="參數(PARAMETERS)">參數(PARAMETERS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E6%93%B4%E5%B1%95%28EXPANSION%29" title="擴展(EXPANSION)">擴展(EXPANSION)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E9%87%8D%E5%AE%9A%E5%90%91%28REDIRECTION%29" title="重定向(REDIRECTION)">重定向(REDIRECTION)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%88%A5%E5%90%8D%28ALIASES%29" title="別名(ALIASES)">別名(ALIASES)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%87%BD%E6%95%B8%28FUNCTIONS%29" title="函數(FUNCTIONS)">函數(FUNCTIONS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E7%AE%97%E8%A1%93%E6%B1%82%E5%80%BC%28&amp;amp;amp;amp;amp;%2334;ARITHMETIC_EVALUATION&amp;amp;amp;amp;amp;%2334;%29" title="算術求值(&amp;amp;amp;amp;amp;#34;ARITHMETIC EVALUATION&amp;amp;amp;amp;amp;#34;)">算術求值(&amp;amp;amp;amp;amp;#34;ARITHMETIC EVALUATION&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E6%A2%9D%E4%BB%B6%E8%A1%A8%E9%81%94%E5%BC%8F%28&amp;amp;amp;amp;amp;%2334;CONDITIONAL_EXPRESSIONS&amp;amp;amp;amp;amp;%2334;%29" title="條件表達式(&amp;amp;amp;amp;amp;#34;CONDITIONAL EXPRESSIONS&amp;amp;amp;amp;amp;#34;)">條件表達式(&amp;amp;amp;amp;amp;#34;CONDITIONAL EXPRESSIONS&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E7%B0%A1%E5%96%AE%E5%91%BD%E4%BB%A4%E6%93%B4%E5%B1%95%28&amp;amp;amp;amp;amp;%2334;SIMPLE_COMMAND_EXPANSION&amp;amp;amp;amp;amp;%2334;%29" title="簡單命令擴展(&amp;amp;amp;amp;amp;#34;SIMPLE COMMAND EXPANSION&amp;amp;amp;amp;amp;#34;)">簡單命令擴展(&amp;amp;amp;amp;amp;#34;SIMPLE COMMAND EXPANSION&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%91%BD%E4%BB%A4%E5%9F%B7%E8%A1%8C%28COMMAND_EXECUTION%29" title="命令執行(COMMAND EXECUTION)">命令執行(COMMAND EXECUTION)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%91%BD%E4%BB%A4%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%28COMMAND_EXECUTION_ENVIRONMENT%29" title="命令執行環境(COMMAND EXECUTION ENVIRONMENT)">命令執行環境(COMMAND EXECUTION ENVIRONMENT)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E7%92%B0%E5%A2%83%28ENVIRONMENT%29" title="環境(ENVIRONMENT)">環境(ENVIRONMENT)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E9%80%80%E5%87%BA%E7%8B%80%E6%85%8B%28&amp;amp;amp;amp;amp;%2334;EXIT_STATUS&amp;amp;amp;amp;amp;%2334;%29" title="退出狀態(&amp;amp;amp;amp;amp;#34;EXIT STATUS&amp;amp;amp;amp;amp;#34;)">退出狀態(&amp;amp;amp;amp;amp;#34;EXIT STATUS&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E4%BF%A1%E8%99%9F%28SIGNALS%29" title="信號(SIGNALS)">信號(SIGNALS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E4%BD%9C%E6%A5%AD%E6%8E%A7%E5%88%B6%28&amp;amp;amp;amp;amp;%2334;JOB_CONTROL&amp;amp;amp;amp;amp;%2334;%29" title="作業控制(&amp;amp;amp;amp;amp;#34;JOB CONTROL&amp;amp;amp;amp;amp;#34;)">作業控制(&amp;amp;amp;amp;amp;#34;JOB CONTROL&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E6%8F%90%E7%A4%BA%E7%AC%A6%28PROMPTING%29" title="提示符(PROMPTING)">提示符(PROMPTING)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#readline%E5%BA%AB%28READLINE%29" title="readline庫(READLINE)">readline庫(READLINE)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E6%AD%B7%E5%8F%B2%28HISTORY%29" title="歷史(HISTORY)">歷史(HISTORY)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E6%AD%B7%E5%8F%B2%E6%93%B4%E5%B1%95%28&amp;amp;amp;amp;amp;%2334;HISTORY_EXPANSION&amp;amp;amp;amp;amp;%2334;%29" title="歷史擴展(&amp;amp;amp;amp;amp;#34;HISTORY EXPANSION&amp;amp;amp;amp;amp;#34;)">歷史擴展(&amp;amp;amp;amp;amp;#34;HISTORY EXPANSION&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#shell_%E5%85%A7%E5%BB%BA%E5%91%BD%E4%BB%A4%28SHELL_BUILTIN_COMMANDS%29" title="shell 內建命令(SHELL BUILTIN COMMANDS)">shell 內建命令(SHELL BUILTIN COMMANDS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%8F%97%E9%99%90%E7%9A%84shell%28RESTRICTED_SHELL%29" title="受限的shell(RESTRICTED SHELL)">受限的shell(RESTRICTED SHELL)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%8F%83%E8%A6%8B%28&amp;amp;amp;amp;amp;%2334;SEE_ALSO&amp;amp;amp;amp;amp;%2334;%29" title="參見(&amp;amp;amp;amp;amp;#34;SEE ALSO&amp;amp;amp;amp;amp;#34;)">參見(&amp;amp;amp;amp;amp;#34;SEE ALSO&amp;amp;amp;amp;amp;#34;)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E6%96%87%E4%BB%B6%28FILES%29" title="文件(FILES)">文件(FILES)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E4%BD%9C%E8%80%85%28AUTHORS%29" title="作者(AUTHORS)">作者(AUTHORS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E5%A0%B1%E5%91%8ABUGS_%28BUG_REPORTS%29" title="報告BUGS (BUG REPORTS)">報告BUGS (BUG REPORTS)</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#BUGS" title="BUGS">BUGS</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%5B%E4%B8%AD%E6%96%87%E7%89%88%E7%B6%AD%E8%AD%B7%E4%BA%BA%5D" title="[中文版維護人]">[中文版維護人]</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%5B%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%80%E6%96%B0%E6%9B%B4%E6%96%B0%5D" title="[中文版最新更新]">[中文版最新更新]</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#ZgotmplZ" title="《中國linux論壇man手冊頁翻譯計劃》:">《中國linux論壇man手冊頁翻譯計劃》:</a>
</li>

<li class="list-group-item">
  <a class="toclink" href="#%E8%B7%8B" title="跋">跋</a>
</li>

</ul>
</div>
</details>
</div>

<div class="panel otherversions" role="complementary">
<div class="panel-heading" role="heading">
other versions
</div>
<div class="panel-body">
<ul class="list-group list-group-flush">

<li class="list-group-item active">
<a href="../../buster/manpages-zh/history.1.zh_TW.html">buster</a> <span class="pkgversion" title="1.6.3.3-1">1.6.3.3-1</span>
</li>

<li class="list-group-item">
<a href="../../testing/manpages-zh/history.1.zh_TW.html">testing</a> <span class="pkgversion" title="1.6.3.3-2">1.6.3.3-2</span>
</li>

<li class="list-group-item">
<a href="../../unstable/manpages-zh/history.1.zh_TW.html">unstable</a> <span class="pkgversion" title="1.6.3.3-2">1.6.3.3-2</span>
</li>

</ul>
</div>
</div>


<div class="panel otherlangs" role="complementary">
<div class="panel-heading" role="heading">
other languages
</div>
<div class="panel-body">
<ul class="list-group list-group-flush">

<li class="list-group-item">
<a href="../../buster/manpages-zh/history.1.zh_CN.html" title="Chinese (zh_CN)">中文 (zh-CN)</a>

</li>

<li class="list-group-item active">
<a href="../../buster/manpages-zh/history.1.zh_TW.html" title="Chinese (zh_TW)">繁體中文 (zh-TW)</a>

</li>

</ul>
</div>
</div>



<div class="panel" role="complementary">
<div class="panel-heading" role="heading">
other sections
</div>
<div class="panel-body">
<ul class="list-group list-group-flush">

<li class="list-group-item active">
<a href="../../buster/manpages-zh/history.1.zh_TW.html">1 (<span title="Executable programs or shell commands">progs</span>)</a>
</li>

<li class="list-group-item">
<a href="../../buster/libedit-dev/history.3.en.html">3 (<span title="Library calls (functions within program libraries)">libfuncs</span>)</a>
</li>

<li class="list-group-item">
<a href="../../buster/readline-common/history.3readline.en.html">3readline (<span title="Library calls (functions within program libraries)">libfuncs</span>)</a>
</li>

<li class="list-group-item">
<a href="../../buster/manpages-zh/history.3tcl.zh_TW.html">3tcl (<span title="Library calls (functions within program libraries)">libfuncs</span>)</a>
</li>

<li class="list-group-item">
<a href="../../buster/tklib/history.3tk.en.html">3tk (<span title="Library calls (functions within program libraries)">libfuncs</span>)</a>
</li>

<li class="list-group-item">
<a href="../../buster/inn/history.5.en.html">5 (<span title="File formats and conventions eg /etc/passwd">formats</span>)</a>
</li>

</ul>
</div>
</div>



</div>

<div class="maincontent">
<p class="paneljump"><a href="#panels">Scroll to navigation</a></p>
<div class="mandoc">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">BASH(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">BASH(1)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME">NAME<a class="anchor" href="#NAME">¶</a></h1>
bash - GNU Bourne-Again SHell (GNU
  命令解釋程序
  “Bourne二世”)
</section>
<section class="Sh">
<h1 class="Sh" id="概述(SYNOPSIS)">概述(SYNOPSIS)<a class="anchor" href="#%E6%A6%82%E8%BF%B0(SYNOPSIS)">¶</a></h1>
<b>bash</b> [options] [file]
</section>
<section class="Sh">
<h1 class="Sh" id="版權所有(COPYRIGHT)">版權所有(COPYRIGHT)<a class="anchor" href="#%E7%89%88%E6%AC%8A%E6%89%80%E6%9C%89(COPYRIGHT)">¶</a></h1>
Bash is Copyright (C) 1989-2002 by the Free Software Foundation, Inc.
</section>
<section class="Sh">
<h1 class="Sh" id="描述(DESCRIPTION)">描述(DESCRIPTION)<a class="anchor" href="#%E6%8F%8F%E8%BF%B0(DESCRIPTION)">¶</a></h1>
<b>Bash</b> 是一個與 <i>sh</i>
  兼容的命令解釋程序，可以執行從標準輸入或者文件中讀取的命令。
  <b>Bash</b> 也整合了 <i>Korn</i> 和 <i>C</i>
  <i>Shell</i> (<b>ksh</b> 和 <b>csh</b>)
  中的優秀特性。
<p class="Pp"><b>Bash</b>
    的目標是成爲遵循 IEEE POSIX
    Shell and Tools specification (IEEE Working Group
    1003.2，可移植操作系統規約：
    shell 和工具) 的實現。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="選項(OPTIONS)">選項(OPTIONS)<a class="anchor" href="#%E9%81%B8%E9%A0%85(OPTIONS)">¶</a></h1>
除了在 <b>set</b>
  內建命令的文檔中講述的單字符選項
  (option) 之外，<b>bash</b>
  在啓動時還解釋下列選項。
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>-c</b><i> string</i></dt>
  <dd>如果有 <b>-c</b>
      選項，那麼命令將從
      <i>string</i> 中讀取。如果
      <i>string</i> 後面有參數
      (argument)，它們將用於給位置參數
      (positional parameter，以 <b>$0</b> 起始)
      賦值。</dd>
  <dt><b>-i</b></dt>
  <dd>如果有 <b>-i</b> 選項，shell
      將交互地執行 ( <i>interactive</i>
      )。</dd>
  <dt><b>-l</b></dt>
  <dd>選項使得 <b>bash</b>
      以類似登錄 shell (login shell)
      的方式啓動
      (參見下面的
      <small><b>啓動(INVOCATION)</b></small>
      章節)。</dd>
  <dt><b>-r</b></dt>
  <dd>如果有 <b>-r</b> 選項，shell
      成爲受限的 ( <i>restricted</i> )
      (參見下面的
      <small><b>受限的shell(RESTRICTED SHELL)</b></small>
      章節)。</dd>
  <dt><b>-s</b></dt>
  <dd>如果有 <b>-s</b>
      選項，或者如果選項處理完以後，沒有參數剩餘，那麼命令將從標準輸入讀取。
      這個選項允許在啓動一個交互
      shell
      時可以設置位置參數。</dd>
  <dt><b>-D</b></dt>
  <dd>向標準輸出打印一個以
      <b>$</b>
      爲前導的，以雙引號引用的字符串列表。
      這是在當前語言環境不是
      <b>C</b> 或 <b>POSIX</b>
      時，腳本中需要翻譯的字符串。
      這個選項隱含了 <b>-n</b>
      選項；不會執行命令。</dd>
  <dt><b>[-+]O [<i>shopt_option</i>]</b></dt>
  <dd><i>shopt_option</i> 是一個 <b>shopt</b>
      內建命令可接受的選項
      (參見下面的 <small><b>shell
      內建命令(SHELL BUILTIN COMMANDS)</b></small>
      章節)。 如果有
      <i>shopt_option</i>，<b>-O</b>
      將設置那個選項的取值；
      <b>+O</b> 取消它。
      如果沒有給出
      <i>shopt_option</i>，<b>shopt</b>
      將在標準輸出上打印設爲允許的選項的名稱和值。
      如果啓動選項是
      <b>+O</b>，輸出將以一種可以重用爲輸入的格式顯示。</dd>
  <dt><b>--</b></dt>
  <dd><b>--</b>
      標誌選項的結束，禁止其餘的選項處理。任何
      <b>--</b>
      之後的參數將作爲文件名和參數對待。參數
      <b>-</b> 與此等價。</dd>
</dl>
<p class="Pp"><b>Bash</b>
    也解釋一些多字節的選項。在命令行中，這些選項必須置於需要被識別的單字符參數之前。</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>--dump-po-strings</b></dt>
  <dd>等價於
      <b>-D</b>，但是輸出是 GNU
      <i>gettext</i> <b>po</b> (可移植對象)
      文件格式</dd>
  <dt><b>--dump-strings</b></dt>
  <dd>等價於 <b>-D</b></dd>
  <dt><b>--help</b></dt>
  <dd>在標準輸出顯示用法信息併成功退出</dd>
  <dt><b>--init-file</b> <i>file</i></dt>
  <dd></dd>
  <dt><b>--rcfile</b> <i>file</i></dt>
  <dd>如果 shell
      是交互的，執行 <i>file</i>
      中的命令，而不是標準的個人初始化文件
      <i>~/.bashrc</i> (參見下面的
      <small><b>啓動(INVOCATION)</b></small> 章節)</dd>
  <dt><b>--login</b></dt>
  <dd>等價於 <b>-l</b></dd>
  <dt><b>--noediting</b></dt>
  <dd>如果 shell
      是交互的，不使用 GNU
      <b>readline</b> 庫來讀命令行</dd>
  <dt><b>--noprofile</b></dt>
  <dd>不讀取系統範圍的啓動文件
      <i>/etc/profile</i>
      或者任何個人初始化文件
      <i>~/.bash_profile</i>, <i>~/.bash_login</i>, 或 <i>~/.profile</i>
      。默認情況下， <b>bash</b>
      在作爲登錄 shell
      啓動時讀取這些文件
      (參見下面的
      <small><b>啓動(INVOCATION)</b></small> 章節)</dd>
  <dt><b>--norc</b></dt>
  <dd>如果 shell
      是交互的，不讀取/執行個人初始化文件
      <i>~/.bashrc</i> 這個選項在 shell 以
      <b>sh</b>
      命令啓動時是默認啓用的</dd>
  <dt><b>--posix</b></dt>
  <dd>如果默認操作與 POSIX 1003.2
      標準不同的話，改變
      <b>bash</b>
      的行爲來符合標準 (<i>posix
      mode</i>)</dd>
  <dt><b>--restricted</b></dt>
  <dd>shell 成爲受限的
      (參見下面的
      <small><b>受限的shell(RESTRICTED SHELL)</b></small>
      章節)</dd>
  <dt><b>--rpm-requires</b></dt>
  <dd>產生一個爲使腳本運行，需要的文件的列表。
      這個選項包含了 <b>-n</b>
      選項。
      它是爲了避免進行編譯期錯誤檢測時的限制－－
      Backticks, [] tests, 還有 evals
      不會被解釋，一些依賴關係可能丟失</dd>
  <dt><b>--verbose</b></dt>
  <dd>等價於 <b>-v</b></dd>
  <dt><b>--version</b></dt>
  <dd>在標準輸出顯示此
      <b>bash</b>
      的版本信息併成功退出。</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="參數(ARGUMENTS)">參數(ARGUMENTS)<a class="anchor" href="#%E5%8F%83%E6%95%B8(ARGUMENTS)">¶</a></h1>
如果選項處理之後仍有參數剩餘，並且沒有指定
  <b>-c</b> 或 <b>-s</b>
  選項，第一個參數將假定爲一個包含
  shell 命令的文件的名字。
  如果 <b>bash</b>
  是以這種方式啓動的，
  <b>$0</b>
  將設置爲這個文件的名字，位置參數將設置爲剩餘的其他參數。
  <b>Bash</b>
  從這個文件中讀取並執行命令，然後退出。
  <b>Bash</b>
  的退出狀態是腳本中執行的最後一個命令的退出狀態。
  如果沒有執行命令，退出狀態是0。
  嘗試的步驟是先試圖打開在當前目錄中的這個文件，接下來，
  如果沒有找到，shell
  將搜索腳本的 <small><b>PATH</b></small>
  環境變量中的路徑。
</section>
<section class="Sh">
<h1 class="Sh" id="啓動(INVOCATION)">啓動(INVOCATION)<a class="anchor" href="#%E5%95%93%E5%8B%95(INVOCATION)">¶</a></h1>
<i>login shell</i> 登錄
  shell，參數零的第一個字符是
  <b>-</b>
  ，或者啓動時指定了
  <b>--login</b> 選項的 shell。
<p class="Pp"><i>interactive</i> 交互的
    shell，是一個啓動時沒有指定非選項的參數，並且沒有指定
    <b>-c</b>
    選項，標準輸出和標準輸入都連接到了終端
    (在 <a href="../../buster/manpages-dev/isatty.3.en.html">isatty(3)</a> 中判定)
    的shell，或者啓動時指定了
    <b>-i</b> 選項的 shell。如果 <b>bash</b>
    是交互的， <small><b>PS1</b></small>
    環境變量將被設置，並且
    <b>$-</b> 包含 <b>i</b> ，允許一個
    shell
    腳本或者一個啓動文件來檢測這一狀態。</p>
<p class="Pp">下列段落描述了
    <b>bash</b>
    如何執行它的啓動文件。如果這些啓動文件中的任一個存在但是不可讀取，
    <b>bash</b>
    將報告一個錯誤。文件名中的波浪號
    (~,tilde) 將像 <small><b>EXPANSION</b></small>
    章節中 <b>Tilde Expansion</b>
    段描述的那樣展開。</p>
<p class="Pp">當 <b>bash</b>
    是作爲交互的登錄 shell
    啓動的，或者是一個非交互的
    shell 但是指定了 <b>--login</b>
    選項，
    它首先讀取並執行
    <i>/etc/profile</i>
    中的命令，只要那個文件存在。
    讀取那個文件之後，它以如下的順序查找
    <i>~/.bash_profile</i>, <i>~/.bash_login</i>, 和 <i>~/.profile</i>,
    從存在並且可讀的第一個文件中讀取並執行其中的命令。
    <b>--noprofile</b> 選項可以用來在
    shell
    啓動時阻止它這樣做。</p>
<p class="Pp">當一個登錄 shell
    退出時， <b>bash</b>
    讀取並執行文件
    <i>~/.bash_logout</i>
    中的命令，只要它存在。</p>
<p class="Pp">當一個交互的 shell
    但不是登錄 shell
    啓動時， <b>bash</b> 從文件
    <i>~/.bashrc</i>
    中讀取並執行命令，只要它存在。可以用
    <b>--norc</b>
    選項來阻止它這樣做。
    <b>--rcfile</b> <i>file</i> 選項將強制
    <b>bash</b> 讀取並執行文件
    <i>file</i> 中的命令，而不是
    <i>~/.bashrc</i> 中的。</p>
<p class="Pp">當 <b>bash</b>
    以非交互的方式啓動時，例如在運行一個
    shell
    腳本時，它在環境中查找變量
    <small><b>BASH_ENV</b></small>
    ，如果它存在則將它的值展開，使用展開的值作爲一個文件的名稱，讀取並執行。
    <b>Bash</b>
    運作的過程就如同執行了下列命令：</p>
<p class="Pp"></p>
<div class="Bd-indent">if [ -n &#34;$BASH_ENV&#34; ]; then .
  &#34;$BASH_ENV&#34;; fi</div>
<p class="Pp">但是沒有使用
    <small><b>PATH</b></small>
    變量的值來搜索那個文件名。</p>
<p class="Pp">如果 <b>bash</b> 以名稱 <b>sh</b>
    啓動，它試圖模仿 (mimic)
    <b>sh</b>
    歷史版本的啓動過程，儘可能地相似，同時也遵循
    POSIX 標準。
    當作爲交互式登錄 shell
    啓動時,或者是非交互但使用了
    <b>--login</b> 選項
    啓動的時候,它首先嚐試讀取並執行文件
    <i>/etc/profile</i> 和 <i>~/.profile</i>,
    中的命令. 選項 <b>--noprofile</b>
    用於避免這種行爲.當使用命令
    <b>sh</b>
    來啓動一個交互式的
    shell 時, <b>bash</b> 查找環境變量
    <b>ENV</b>,
    如果有定義的話就擴展它的值,然後使用擴展後的值作爲要讀取和執行的文件
    的名稱.由於使用 <b>sh</b>
    啓動的 shell
    不會讀取和執行任何其他的啓動文件,選項
    <b>--rcfile</b>
    沒有意義.使用名稱 <b>sh</b>
    啓動的非交互的 shell
    不會讀取任何其他啓動文件.當以
    <b>sh</b> 啓動時, <b>bash</b>
    在讀取啓動文件之後進入
    <i>posix</i> 模式.</p>
<p class="Pp">當 <b>bash</b> 以 <i>posix</i>
    模式啓動時,(和使用
    <b>--posix</b>
    命令行參數效果相同),它遵循
    POSIX 標準.
    這種模式下,交互式 shell
    擴展 <small><b>ENV</b></small>
    環境變量的值,讀取並執行以擴展後值爲文件名的配置文件.
    不會讀取其他文件.</p>
<p class="Pp"><b>Bash</b>
    試着檢測它是不是由遠程
    shell 守護程序,通常爲 <i>rshd</i>
    啓動的.如果 <b>bash</b>
    發現它是由 <i>rshd</i>
    啓動的,它將讀取並執行
    <i>~/.bashrc</i> 文件中的命令,
    只要這個文件存在並且可讀.如果以
    <b>sh</b>
    命令啓動,它不會這樣做.
    選項 <b>--norc</b>
    可以用來阻止這種行爲,選項
    <b>--rcfile</b>
    用來強制讀取另一個文件,但是通常
    <i>rshd</i> 不會允許它們,
    或者用它們來啓動 shell.</p>
<p class="Pp">如果 shell
    是以與真實用戶(組) id
    不同的有效用戶(組) id
    來啓動的, 並且沒有 <b>-</b>
    選項,那麼它不會讀取啓動文件,
    也不會從環境中繼承
    shell 函數.
    環境變量中如果出現
    <small><b>SHELLOPTS，</b></small>
    它將被忽略.有效用戶 id
    將設置爲真實用戶 id.
    如果啓動時給出了 <b>-</b>
  <br/>
選項,那麼啓動時的行爲是類似的,
    但是不會重置有效用戶
    id.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="定義(DEFINITIONS)">定義(DEFINITIONS)<a class="anchor" href="#%E5%AE%9A%E7%BE%A9(DEFINITIONS)">¶</a></h1>
下列定義在文檔餘下部分中通用.
<dl class="Bl-tag">
  <dt><b>blank 空白</b></dt>
  <dd>一個空格或是 tab .</dd>
  <dt><b>word 詞</b></dt>
  <dd>一個字符序列, shell
      將它們視爲一個結構單元.
      也稱爲一個
      <b>token</b>片段。</dd>
  <dt><b>name 名稱</b></dt>
  <dd>一個只由字母,數字和下劃線構成的詞,並且以字符或下劃線起始.
      也稱爲一個 <i>word</i>
      <b>identifier</b>標識符.</dd>
  <dt><b>metacharacter 元字符</b></dt>
  <dd>一個字符,
      如果不是引用的話,
      將成爲詞的分隔符.
      它是如下字符之一:
    <br/>
  </dd>
</dl>
<div class="Bd-indent">
<p class="Pp"><b>| &amp; ; ( ) &lt; &gt; space tab</b></p>
</div>
<dl class="Bl-tag">
  <dt><b>control operator 控制操作符</b></dt>
  <dd>一個 <i>token</i>(標識),
      擁有控制功能.
      它是如下符號之一:</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"><b>|| &amp; &amp;&amp; ; ;; ( ) | &lt;newline&gt;</b></p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="保留字(&#34;RESERVED_WORDS&#34;)">保留字(&#34;RESERVED WORDS&#34;)<a class="anchor" href="#%E4%BF%9D%E7%95%99%E5%AD%97(%22RESERVED_WORDS%22)">¶</a></h1>
<i>Reserved words</i>(保留字) 是對 shell
  有特殊意義的詞.
  下列詞被識別爲保留的,
  如果不是引用,
  並且不是一個簡單命令的起始詞
  (參見下面的
  <small><b>shell語法(&#34;SHELL GRAMMAR&#34;)</b></small> ),
  也不是 <b>case</b> 或者 <b>for</b>
  命令的第三個詞:
<p class="Pp"><b>! case do done elif else esac fi for function if in select then
    until while { } time [[ ]]</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="shell語法(&#34;SHELL_GRAMMAR&#34;)">shell語法(&#34;SHELL GRAMMAR&#34;)<a class="anchor" href="#shell%E8%AA%9E%E6%B3%95(%22SHELL_GRAMMAR%22)">¶</a></h1>
<section class="Ss">
<h2 class="Ss" id="Simple_Commands_簡單命令">Simple Commands 簡單命令<a class="anchor" href="#Simple_Commands_%E7%B0%A1%E5%96%AE%E5%91%BD%E4%BB%A4">¶</a></h2>
<i>simple command</i>(簡單命令)
  是(可選的)一系列變量賦值,
  緊接着是 <b>blank</b>(空格)
  分隔的詞和重定向,
  然後以一個 <i>control operator</i>
  結束.
  第一個詞指明瞭要執行的命令,
  它被作爲第 0 個參數.
  其餘詞被作爲這個命令的參數.
<p class="Pp"><i>simple command</i>
    簡單命令的返回值是它的退出狀態,
    或是 128+<i>n</i>, 如果命令被
    signal(信號) <i>n</i> 結束的話.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pipelines_管道">Pipelines 管道<a class="anchor" href="#Pipelines_%E7%AE%A1%E9%81%93">¶</a></h2>
<i>pipeline</i>(管道)
  是一個或多個命令的序列，用字符
  <b>|</b>
  分隔。管道的格式是這樣:
<div class="Bd-indent">
<p class="Pp">[<b>time</b> [<b>-p</b>]] [ ! ] <i>command</i> [ <b>|</b>
    <i>command2</i> ... ]</p>
</div>
<p class="Pp">命令 <i>command</i>
    的標準輸出通過管道連接到命令
    <i>command2</i>
    的標準輸入。連接是在命令指定的任何重定向之前進行的(參見下面的
    <small><b>REDIRECTION 重定向)。</b></small></p>
<p class="Pp">如果保留字 <b>!</b>
    作爲管道前綴，管道的退出狀態將是最後一個命令的退出狀態的邏輯非值。
    否則，管道的退出狀態就是最後一個命令的。
    shell
    在返回退出狀態值之前，等待管道中的所有命令返回。</p>
<p class="Pp">如果保留字 <b>time</b>
    作爲管道前綴，管道中止後將給出執行管道耗費的用戶和系統時間。
    選項 <b>-p</b> 將使輸出符合
    POSIX 指定的格式。
    環境變量 <small><b>TIMEFORMAT</b></small>
    可以設置爲一個格式字符串，指定時間信息應當如何顯示；參見下面的
    <b>Shell Variables 環境變量</b> 中
    <small><b>TIMEFORMAT</b></small> 的講述。</p>
<p class="Pp">管道中的每個命令都作爲單獨的進程來執行(即，在一個子
    shell 中啓動)。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Lists_序列">Lists 序列<a class="anchor" href="#Lists_%E5%BA%8F%E5%88%97">¶</a></h2>
<i>list</i>(序列)是一個或多個管道，用操作符
  <b>;</b>, <b>&amp;</b>, <b>&amp;&amp;</b>, 或 <b>⎪⎪</b>
  分隔的序列,
  並且可以選擇用 <b>;</b>,
  <b>&amp;</b>, 或
  <b>&lt;newline&gt;</b>新行符結束.
<p class="Pp">這些序列操作符中，
    <b>&amp;&amp;</b> 和 <b>⎪⎪</b>
    優先級相同，其次是
    <b>;</b> 和 <b>&amp;,</b>
    它們的優先級是相同的。</p>
<p class="Pp">序列中可以有一個或多個新行符來分隔命令，而不是使用分號分隔。</p>
<p class="Pp">如果一個命令是由控制操作符
    <b>&amp;</b> 結束的, shell
    將在後臺的子 shell
    中執行這個命令。 shell
    不會等待命令執行結束，返回狀態總是
    0。以分號 <b>;</b>
    分隔的命令會被順序執行；shell
    會等待每個命令依次結束。返回狀態是最後執行的命令的返回狀態。</p>
<p class="Pp">控制操作符 <b>&amp;&amp;</b>
    和 <b>⎪⎪</b> 分別代表 AND
    和 OR 序列。一個 AND
    序列的形式是</p>
<div class="Bd-indent">
<p class="Pp"><i>command1</i> <b>&amp;&amp;</b> <i>command2</i></p>
</div>
<p class="Pp"><i>command2</i> 只有在 <i>command1</i>
    返回 0 時才被執行。</p>
<p class="Pp">一個 OR
    序列的形式是</p>
<div class="Bd-indent">
<p class="Pp"><i>command1</i> <b>⎪⎪</b> <i>command2</i></p>
</div>
<p class="Pp"><i>command2</i> 只有在 <i>command1</i>
    返回非 0
    狀態時才被執行。AND 和
    OR
    序列的返回狀態是序列中最後執行的命令的返回狀態。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Compound_Commands_複合命令">Compound Commands 複合命令<a class="anchor" href="#Compound_Commands_%E8%A4%87%E5%90%88%E5%91%BD%E4%BB%A4">¶</a></h2>
<i>compound command</i>(複合命令)
  是如下情況之一：
<dl class="Bl-tag">
  <dt>(<i>list</i>)</dt>
  <dd><i>list</i> 序列將在一個子 shell
      中執行。變量賦值和影響
      shell
      環境變量的內建命令在命令結束後不會再起作用。
      返回值是序列的返回值。</dd>
  <dt>{ <i>list</i>; }</dt>
  <dd><i>list</i> 序列將在當前 shell
      環境中執行。序列必須以一個新行符或分號結束。
      這種做法也稱爲 <i>group
      command</i>(命令組)。返回值是序列的返回值。注意與元字符
      <b>(</b> 和 <b></b> 不同， <b>{</b> 和
      <b>}</b> 是 <i>reserved
      words</i>(保留字)，必須出現在能夠識別保留字的場合。
      由於它們不會產生斷詞(cause
      a word
      break)，它們和序列之間必須用空格分開。</dd>
  <dt>((<i>expression</i>))</dt>
  <dd>表達式 <i>expression</i>
      將被求值。求值規則在下面的
      <b>算術求值 (ARITHMETIC EVALUATION)</b>
      章節中描述。如果表達式的值非零，返回值就是
      0；否則返回值是
      1。這種做法和 <b>let
      &#34;</b><i>expression</i><b>&#34;</b> 等價。</dd>
  <dt><b>[[</b> <i>expression</i> <b>]]</b></dt>
  <dd>返回 0 或
      1，取決於條件表達式
      <i>expression</i> 求值的情況。
      表達式是由下面 <b>CONDITIONAL
      EXPRESSIONS 條件表達式</b>
      章節中描述的原語(primaries)
      組成。 <b>[[</b> 和 <b>]]</b>
      中的詞不會進行詞的拆分和路徑的擴展處理；
      而tilde
      擴展，參數和變量擴展，算術擴展，命令替換，函數替換和引用的去除則都將進行。
    <p class="Pp">當使用 <b>==</b> 和 <b>!=</b>
        操作符時，操作符右邊的字符串被認爲是一個模式，根據下面
        <b>Pattern Matching</b>(模式匹配)
        章節中的規則進行匹配。
        如果匹配則返回值是
        0，否則返回
        1。模式的任何部分可以被引用，強制使它作爲一個字符串而被匹配。</p>
    <p class="Pp">表達式可以用下列操作符結合起來。根據優先級的降序列出如下：</p>
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>( <i>expression</i> )</b></dt>
  <dd>返回表達式 <i>expression</i>
      的值。括號可以用來提升操作符的優先級。</dd>
  <dt><b>! <i>expression</i></b></dt>
  <dd>返回真，如果表達式
      <i>expression</i> 返回假。</dd>
  <dt><i>expression1</i> <b>&amp;&amp;</b> <i>expression2</i></dt>
  <dd>返回真，如果表達式
      <i>expression1</i> 和 <i>expression2</i>
      都返回真。</dd>
  <dt><i>expression1</i> <b>||</b> <i>expression2</i></dt>
  <dd>返回真，如果表達式
      <i>expression1</i> 或者 <i>expression2</i>
      二者之一返回真。</dd>
</dl>
<p class="Pp"><b>&amp;&amp;</b>(與) 和 <b>||</b>
    操作符不會對錶達式
    <i>expression2</i> 求值，如果
    <i>expression1</i>
    可以決定整個條件表達式的返回值的話。</p>
</div>
<dl class="Bl-tag">
  <dt><b>for</b> <i>name</i> [ <b>in</b> <i>word</i> ] ; <b>do</b> <i>list</i> ;
    <b>done</b></dt>
  <dd><b>in</b>
      之後的一系列詞會被擴展，產生一個項目列表。變量
      <i>name</i>
      被依次賦以這個列表中的每個元素，
      序列 <i>list</i>
      每次都被執行。如果
      <b>in</b> <i>word</i> 被忽略，那麼
      <b>for</b> 命令遍歷
      已設置的位置參數(positional
      parameter，參見下面的
      <small><b>PARAMETERS 參數)，</b></small>
      爲每一個執行一次序列
      <i>list</i>。
      返回值是最後一個命令的返回值。如果
      <b>in</b>
      之後的詞擴展的結果是空列表，就不會執行任何命令，返回值是
      0。</dd>
  <dt><b>for</b> (( <i>expr1</i> ; <i>expr2</i> ; <i>expr3</i> )) ; <b>do</b>
    <i>list</i> ; <b>done</b></dt>
  <dd>首先，算術表達式
      <i>expr1</i> 被根據下面
      <b>算術求值 (ARITHMETIC EVALUATION)</b>
      中的規則進行求值。
      然後算術表達式 <i>expr2</i>
      被循環求值，直到它等於
      0。每次 <i>expr2</i>
      結果非零時，序列
      <i>list</i> 都被執行，
      算術表達式 <i>expr3</i>
      被求值。如果任何表達式被忽略，將被視爲執行結果是
      1。 返回值是序列 <i>list</i>
      中被執行的最後一個命令的返回值；或者是
      false，如果任何表達式非法的話。</dd>
  <dt><b>select</b> <i>name</i> [ <b>in</b> <i>word</i> ] ; <b>do</b>
    <i>list</i> ; <b>done</b></dt>
  <dd><b>in</b>
      之後的一系列詞會被擴展，產生一個項目列表。這個擴展後的詞集合被輸出到標準錯誤上，每個前面
      加上一個數字。如果
      <b>in</b> <i>word</i>
      被忽略，將輸出位置參數
      (參見下面的 <small><b>PARAMETERS
      參數</b></small> 章節)。 <b>PS3</b>
      提示符將被顯示出來，等待從標準輸入得到一行輸入。如果
      輸入是一個數字且顯示中有對應的詞，那麼變量
      <i>name</i>
      的值將設置爲這個詞。如果輸入一個空行，那麼詞和提示符將再次顯示出來。如果讀入了一個
      EOF，命令就結束。
      任何其他值將設置變量
      <i>name</i>
      爲空。讀入的行保存爲變量
      <b>REPLY</b>. 序列 <i>list</i>
      在每次選擇之後都會執行，直到執行了一個
      <b>break</b> 命令。 <b>select</b>
      的退出狀態是序列
      <i>list</i>
      中執行的最後一個命令的退出狀態，如果沒有執行命令就是
      0。</dd>
  <dt><b>case</b> <i>word</i> <b>in</b> [ [(] <i>pattern</i> [ <b>|</b>
    <i>pattern</i> ] ... ) <i>list</i> ;; ] ... <b>esac</b></dt>
  <dd><b>case</b> 命令首先擴展 <i>word</i>,
      然後依次試着用每個
      <i>pattern</i> 來匹配它，
      使用與路徑擴展相同的匹配規則(參見下面的
      <b>Pathname Expansion 路徑擴展</b>
      章節)。如果找到一個匹配，相應的序列將被執行。找到一個匹配之後，不會再嘗試其後的匹配。
      如果沒有模式可以匹配，返回值是
      0。否則，返回序列中最後執行的命令的返回值。</dd>
  <dt><b>if</b> <i>list</i>; <b>then</b> <i>list;</i> [ <b>elif</b> <i>list</i>;
    <b>then</b> <i>list</i>; ] ... [ <b>else</b> <i>list</i>; ] <b>fi</b></dt>
  <dd>序列 <b>if</b> <i>list</i>
      被執行。如果退出狀態是
      0，<b>then</b> <i>list</i>
      將被執行。否則，每個
      <b>elif</b>
      將被一次執行，如果退出狀態是
      0，相應的 <b>then</b> <i>list</i>
      將被執行，命令結束。
      否則，<b>else</b> <i>list</i>
      將被執行，如果存在的話。
      退出狀態是最後執行的命令的退出狀態，或者是
      0，如果所有條件都不滿足。</dd>
  <dt><b>while</b> <i>list</i>; <b>do</b> <i>list</i>; <b>done</b></dt>
  <dd></dd>
  <dt><b>until</b> <i>list</i>; <b>do</b> <i>list</i>; <b>done</b></dt>
  <dd><b>while</b>
      命令不斷地執行序列
      <b>do</b>
      <i>list</i>，直到序列中最後一個命令返回
      0。 <b>until</b> 命令和 <b>while</b>
      命令等價，除了對條件的測試恰好相反；序列
      <b>do</b> <i>list</i>
      執行直到序列中最後一個命令返回非零狀態值。
      <b>while</b> 和 <b>until</b>
      命令的退出狀態是序列
      <b>do</b> <i>list</i>
      中最後一個命令的退出狀態，
      或者是
      0，如果沒有執行任何命令。</dd>
  <dt>[ <b>function</b> ] <i>name</i> () { <i>list</i>; }</dt>
  <dd>這樣可以定義一個名爲
      <i>name</i> 的函數。函數體
      <i>body</i> 是包含在 { 和 }
      之間的命令序列
      <i>list</i>。 在指定將 <i>name</i>
      作爲一個命令運行的場合，這個序列將被執行。
      函數的退出狀態是函數體最後執行的命令的退出狀態(參見下面的
      <small><b>FUNCTIONS 函數</b></small>
    章節)。</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="註釋(COMMENTS)">註釋(COMMENTS)<a class="anchor" href="#%E8%A8%BB%E9%87%8B(COMMENTS)">¶</a></h1>
在非交互的 shell
  中或者使用內建命令
  <b>shopt</b> 啓用了 <b>interactive_comments</b>
  選項的交互的 shell
  中，以 <b>#</b>
  起始的詞使得這個詞和所有同一行上所有剩餘的字符都被忽略。沒有啓用
  <b>interactive_comments</b> 選項的交互式
  shell
  不允許出現註釋。這個選項在交互式
  shell 中是默認啓用的
  (參見下面的 <small><b>shell
  內建命令(SHELL BUILTIN COMMANDS)</b></small>
  章節)。
</section>
<section class="Sh">
<h1 class="Sh" id="引用(QUOTING)">引用(QUOTING)<a class="anchor" href="#%E5%BC%95%E7%94%A8(QUOTING)">¶</a></h1>
引用 <i>Quoting</i>
  用來去掉特定字符或詞的特殊意義。引用可以用來禁止對特殊字符的處理，
  阻止保留字被識別，還用來阻止參數的擴展。
<p class="Pp">上面在 <small><b>DEFINITIONS
    定義</b></small>
    中列出的每個元字符
    <i>metacharacters</i> 對於 shell
    都有特殊意義。如果要表達它的本義，必須引用它。</p>
<p class="Pp">在使用命令行歷史擴展功能時，<i>history
    expansion</i> 字符，通常是
    <b>!</b>，必須被引用，纔不會進行歷史擴展。</p>
<p class="Pp">有三種引用機制：轉義字符
    <i>(escape character)</i>,
    單引號和雙引號。</p>
<p class="Pp">一個未被引用的反斜槓
    (<b>\</b>) 是轉義字符 <i>escape
    character</i>。
    它保留其後下一個字符的字面意義，除非那是一個新行符。
    如果 <b>\</b>
    和新行符成對出現，並且反斜槓自身沒有被引用，那麼
    <b>\</b>&lt;newline&gt;
    被視爲續行標誌
    (意思是，它被從輸入流中刪除並忽略了)。</p>
<p class="Pp">將字符放在單引號之中，將保留引用中所有字符的字面意義。單引號不能包含在單引號引用之中，即使前面加上了反斜槓。</p>
<p class="Pp">將字符放在雙引號中，同樣保留所有字符的字面意義，例外的情況是
    <b>$</b>, <b>`</b>, 和 <b>\</b>。 字符 <b>$</b>
    和 <b>`</b>
    在雙引號中仍然具有特殊意義。反斜槓只有後面是下列字符時纔有特殊意義：
    <b>$</b>, <b>`</b>, <b>&#34;</b>, <b>\</b>, 或
    <b>&lt;newline&gt;</b>.
    雙引號可以包含在雙引號引用中，但要在前面加上一個反斜槓。</p>
<p class="Pp">特殊的參數 <b>*</b> 和
    <b>@</b>
    在雙引號中有特殊意義(參見下面的
    <small><b>PARAMETERS 參數</b></small>
  章節)。</p>
<p class="Pp">形式爲 <b>$</b>&#39;<i>string</i>&#39;
    的詞會被特殊處理。它被擴展爲
    <i>string</i>，其中的反斜槓轉義字符
    被替換爲 ANSI C
    標準中規定的字符。反斜槓轉義序列，如果存在的話，將做如下轉換：</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>\a</b></dt>
  <dd>alert (bell) 響鈴</dd>
  <dt><b>\b</b></dt>
  <dd>backspace 回退</dd>
  <dt><b>\e</b></dt>
  <dd>an escape character 字符 Esc</dd>
  <dt><b>\f</b></dt>
  <dd>form feed 進紙</dd>
  <dt><b>\n</b></dt>
  <dd>new line 新行符</dd>
  <dt><b>\r</b></dt>
  <dd>carriage return 回車</dd>
  <dt><b>\t</b></dt>
  <dd>horizontal tab 水平跳格</dd>
  <dt><b>\v</b></dt>
  <dd>vertical tab 豎直跳格</dd>
  <dt><b>\\</b></dt>
  <dd>backslash 反斜槓</dd>
  <dt><b>\&#39;</b></dt>
  <dd>single quote 單引號</dd>
  <dt><b>\<i>nnn</i></b></dt>
  <dd>一個八比特字符，它的值是八進制值
      <i>nnn</i> (一到三個數字)。</dd>
  <dt><b>\x<i>HH</i></b></dt>
  <dd>一個八比特字符，它的值是十六進制值
      <i>HH</i>
      (一到兩個十六進制數字)。</dd>
  <dt><b>\c<i>x</i></b></dt>
  <dd>一個 ctrl-<i>x</i> 字符</dd>
</dl>
</div>
<p class="Pp">擴展結果是單引號引用的，就好像
    $ 符號不存在一樣。</p>
<p class="Pp">雙引號引用字符串前面加上一個
    <b>$</b>
    符號將使得這個字符串被根據當前語言環境
    (locale) 來翻譯。
    如果當前語言環境是
    <b>C</b> 或者
    <b>POSIX</b>，這個符號將被忽略。
    如果這個字符串被翻譯並替換了，那麼替換結果是雙引號引用的。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="參數(PARAMETERS)">參數(PARAMETERS)<a class="anchor" href="#%E5%8F%83%E6%95%B8(PARAMETERS)">¶</a></h1>
一個參數 <i>parameter</i>
  是一個儲存值的實體。它可以是一個名稱
  <i>name</i>,
  一個數字或者是下面
  <b>Special Parameters 特殊參數</b>
  章節中列出的特殊字符之一。從
  shell
  的角度來看，一個變量
  <i>variable</i> 是一個由名稱 <i>name</i>
  代表的參數。一個變量有一個值
  <i>value</i>
  以及零個或多個屬性
  <i>attibutes</i>。屬性可以使用內建命令
  <b>declare</b> 來設置(參見下面
  <b>shell 內建命令(SHELL BUILTIN COMMANDS)</b>
  章節中對 <b>declare</b>
  的描述)。
<p class="Pp">如果給一個參數賦值，那麼它就被定義了。空字符串是有效的值。一旦一個變量被定義了，它只能用內建命令
    <b>unset</b> 來取消(參見下面
    <small><b>shell 內建命令(SHELL BUILTIN
    COMMANDS)</b></small> 章節).</p>
<p class="Pp">一個變量 <i>variable</i>
    可以用這樣的語句形式來賦值：</p>
<div class="Bd-indent">
<p class="Pp"><i>name</i>=[<i>value</i>]</p>
</div>
<p class="Pp">如果沒有給出值
    <i>value，</i>
    變量就被賦爲空字符串。所有值
    <i>values</i>
    都經過了波浪線擴展，參數和變量擴展，命令替換，算術擴展和引用的刪除(參見下面的
    <small><b>EXPANSION 擴展</b></small>
    章節)。如果變量設置了
    <b>integer 整數</b>
    屬性，那麼值 <i>value</i>
    將進行算術擴展，即使沒有應用
    $((...)) 擴展 (參見下面的
    <small><b>Arithmetic Expansion 算術擴展</b></small>
    章節)。
    不會進行詞的拆分，除非是下面
    <b>Special Parameters 特殊參數</b>
    中提到的 <b>&#34;$@&#34;</b>。
    不會進行路徑的擴展。賦值語句也出現在下列內建命令中，作爲它們的參數：
    <b>declare</b>, <b>typeset</b>, <b>export</b>, <b>readonly</b>, 和
    <b>local</b> 。</p>
<section class="Ss">
<h2 class="Ss" id="Positional_Parameters_位置參數">Positional Parameters 位置參數<a class="anchor" href="#Positional_Parameters_%E4%BD%8D%E7%BD%AE%E5%8F%83%E6%95%B8">¶</a></h2>
位置參數 <i>positional parameter</i>
  是以一或多個數字代表的參數，除了
  0。位置參數是在 shell
  啓動時，根據它的參數來賦值的，
  也可以用內建命令 <b>set</b>
  來重新賦值。位置參數不能用賦值語句來賦值。在一個
  shell
  函數被執行的時候，位置參數會被暫時地替換掉
  (參見下面的 <small><b>FUNCTIONS
  函數</b></small> 章節)。
<p class="Pp">當位置參數由兩個以上的數字構成時，它必須放在括號內
    (參見下面的 <small><b>EXPANSION
    擴展</b></small> 章節)。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Special_Parameters_特殊參數">Special Parameters 特殊參數<a class="anchor" href="#Special_Parameters_%E7%89%B9%E6%AE%8A%E5%8F%83%E6%95%B8">¶</a></h2>
shell
  對一些參數做特殊處理。這些參數只能被引用而不能被賦值。
<dl class="Bl-tag">
  <dt><b>*</b></dt>
  <dd>擴展爲位置參數，從 1
      開始。如果擴展發生在雙引號中，它擴展爲一個詞，值是各個參數，以特殊變量
      <small><b>IFS</b></small>
      的第一個字符分隔。也就是說，&#34;<b>$*</b>&#34;
      等價於
      &#34;<b>$1</b><i>c</i><b>$2</b><i>c</i><b>...</b>&#34;，這裏
      <i>c</i> 是變量 <small><b>IFS</b></small>
      的第一個字符。如果沒有設置
      <small><b>IFS，</b></small>
      那麼參數將用空格分隔。
      <small><b>IFS</b></small></dd>
  <dt><b>@</b></dt>
  <dd>擴展爲位置參數，從 1
      開始。如果擴展發生在雙引號中，每個參數都將擴展爲一個詞。也就是說，
      &#34;<b>$@</b>&#34; 等價於 &#34;<b>$1</b>&#34;
      &#34;<b>$2</b>&#34; ...
      如果位置參數不存在，&#34;<b>$@</b>&#34;
      和 <b>$@</b> 擴展爲空
      (即，它們被刪除了)。</dd>
  <dt><b>#</b></dt>
  <dd>擴展爲位置參數的個數，以十進制表示。</dd>
  <dt><b>?</b></dt>
  <dd>擴展爲最近執行的前臺管道的狀態。</dd>
  <dt><b>-</b></dt>
  <dd>擴展爲當前選項標誌。標誌是在啓動時或以內建命令
      <b>set</b> 指定的，或者是 shell
      自身設置的 (例如選項
      <b>-i</b> )。</dd>
  <dt><b>$</b></dt>
  <dd>擴展爲 shell 的進程
      ID。在一個 () 子 shell
      中，它擴展爲當前 shell
      的 進程 ID 而不是子 shell
      的。</dd>
  <dt><b>!</b></dt>
  <dd>擴展爲最近一次執行的後臺
      (異步)
      命令的進程號。</dd>
  <dt><b>0</b></dt>
  <dd>擴展爲 shell 或者 shell
      腳本的名稱。這個變量是在
      shell
      初始化時設置的。如果
      <b>bash</b>
      是執行腳本文件時啓動的，
      <b>$0</b>
      將設置爲那個文件的名稱。如果
      <b>bash</b>
      啓動時的參數包含
      <b>-c，</b> 那麼 <b>$0</b>
      被設置爲啓動命令行被執行後的第一個參數，如果有的話。否則，它被設置爲用來啓動
      <b>bash</b>
      的文件名，就是參數
      0。</dd>
  <dt><b>_</b></dt>
  <dd>shell 啓動時，設置爲 shell
      或參數中被執行的 shell
      腳本的絕對路徑名。
      然後，在擴展時擴展爲上一個命令的最後一個參數。它也被設置爲被執行的每個命令的文件全名並且
      被設置到這個命令執行的環境當中。當檢查郵件時，這個參數保存着正在檢查的郵件文件的名稱。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Shell_Variables_變量">Shell Variables 變量<a class="anchor" href="#Shell_Variables_%E8%AE%8A%E9%87%8F">¶</a></h2>
shell 定義了下列變量：
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>BASH</b></dt>
  <dd>擴展爲用來啓動當前
      <b>bash</b>
      實例的文件全名。</dd>
  <dt><b>BASH_VERSINFO</b></dt>
  <dd>一個只讀數組變量，成員保存着當前
      <b>bash</b>
      實例的版本信息。賦予數組元素的值是如下這些：
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>BASH_VERSINFO[0]</b></dt>
  <dd>主版本號 (<i>release</i>).</dd>
  <dt><b>BASH_VERSINFO[1]</b></dt>
  <dd>次版本號 (<i>version</i>).</dd>
  <dt><b>BASH_VERSINFO[2]</b></dt>
  <dd>補丁版本</dd>
  <dt><b>BASH_VERSINFO[3]</b></dt>
  <dd>編譯信息</dd>
  <dt><b>BASH_VERSINFO[4]</b></dt>
  <dd>發佈時的狀態 (例如,
      <i>beta1</i>).</dd>
  <dt><b>BASH_VERSINFO[5]</b></dt>
  <dd><b>MACHTYPE</b> 平臺類型</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>BASH_VERSION</b></dt>
  <dd>擴展爲一個字符串，描述了這個
      <b>bash</b>. 實例的版本。</dd>
  <dt><b>COMP_CWORD</b></dt>
  <dd><b>${COMP_WORDS}</b>
      的索引，指向當前光標位置所在的詞。
      這個變量只有在被可編程補全功能
      (參見下面的 <b>Programmable Completion</b>
      章節) 調用的 shell
      函數中才可用。</dd>
  <dt><b>COMP_LINE</b></dt>
  <dd>當前命令行。這個變量只有在被命令補全功能調用的
      shell
      函數和外部命令中才可用。</dd>
  <dt><b>COMP_POINT</b></dt>
  <dd>相對於當前命令起始處的當前光標位置。如果當前光標位置是當前命令的末端，
      它的值就和 <b>${#COMP_LINE}</b>
      相等。
      這個變量只有在被命令補全功能調用的
      shell
      函數和外部命令中才可用。</dd>
  <dt><b>COMP_WORDS</b></dt>
  <dd>一個數組變量
      (參見下面的
      <b>Arrays</b>(數組)一節)，由當前命令行的各個單詞構成。
      這個變量只有在被命令補全功能調用的
      shell 函數中才可用。</dd>
  <dt><b>DIRSTACK</b></dt>
  <dd>一個數組變量，包含當前目錄棧的內容。棧中的目錄排列的順序就是用內建命令
      <b>dirs</b>
      顯示時的順序。對這個數組變量的成員賦值可以用來修改棧中已有的目錄，但是要添加和刪除目錄就必須使用
      內建命令 <b>pushd</b> 和 <b>popd。</b>
      對它賦值不會改變當前目錄。如果取消了
      <small><b>DIRSTACK</b></small>
      的定義，它就失去了它的特殊意義，即使後來重新定義它。</dd>
  <dt><b>EUID</b></dt>
  <dd>擴展爲當前用戶的有效用戶
      ID。它在 shell
      啓動時設置。它是隻讀的。</dd>
  <dt><b>FUNCNAME</b></dt>
  <dd>當前執行的 shell
      函數名。這個變量只有在執行一個
      shell 函數時存在。向
      <small><b>FUNCNAME</b></small>
      賦值沒有效果並且返回一個錯誤。如果取消了
      <small><b>FUNCNAME</b></small>
      的定義，它就失去了特殊的意義，即使後來重新定義它。</dd>
  <dt><b>GROUPS</b></dt>
  <dd>一個數組變量，包含當前用戶所屬的組的列表。向
      <small><b>GROUPS</b></small>
      賦值沒有效果並且返回一個錯誤。如果取消了
      <small><b>GROUPS</b></small>
      的定義，它就失去了特殊的意義，即使後來重新定義它。</dd>
  <dt><b>HISTCMD</b></dt>
  <dd>當前命令的歷史編號，或者歷史列表中的索引。如果取消了
      <small><b>HISTCMD</b></small>
      的定義，它就失去了特殊的意義，即使後來重新定義它。</dd>
  <dt><b>HOSTNAME</b></dt>
  <dd>自動設置爲當前的主機名。</dd>
  <dt><b>HOSTTYPE</b></dt>
  <dd>自動設置爲一個字符串，唯一地標識着正在運行
      <b>bash</b>
      的機器類型。默認值是系統相關的。</dd>
  <dt><b>LINENO</b></dt>
  <dd>每次引用這個參數時，shell
      將它替換爲一個指示在腳本或函數中當前行號的十進制數字(從
      1 開始)。
      如果不是在腳本或函數中，替換得到的值不一定有意義。如果取消了
      <small><b>LINENO</b></small>
      的定義，它就失去了特殊的意義，即使後來重新定義它。</dd>
  <dt><b>MACHTYPE</b></dt>
  <dd>自動設置爲一個字符串，完整的描述了正在運行
      <b>bash</b>
      的系統類型，格式是標準的
      GNU <i>cpu-company-system</i>
      格式。默認值是系統相關的。</dd>
  <dt><b>OLDPWD</b></dt>
  <dd>上一次命令 <b>cd</b>
      設置的工作目錄。</dd>
  <dt><b>OPTARG</b></dt>
  <dd>內建命令 <b>getopts</b>
      處理的最後一個選項參數值
      (參見下面的 <small><b>shell
      內建命令(SHELL BUILTIN COMMANDS)</b></small>
      章節)。</dd>
  <dt><b>OPTIND</b></dt>
  <dd>內建命令 <b>getopts</b>
      將處理的下一個參數的索引
      (參見下面的 <small><b>shell
      內建命令(SHELL BUILTIN COMMANDS)</b></small>
      章節)。</dd>
  <dt><b>OSTYPE</b></dt>
  <dd>自動設置的一個字符串，描述了正在運行
      <b>bash</b>
      的操作系統。默認值是系統相關的。</dd>
  <dt><b>PIPESTATUS</b></dt>
  <dd>一個數組變量
      (參見下面的 <b>Arrays 數組</b>
      章節)，包含最近執行的前臺管道中的進程(可能只包含一個命令)的退出狀態。</dd>
  <dt><b>PPID</b></dt>
  <dd>shell
      的父進程的進程號。這個變量是隻讀的。</dd>
  <dt><b>PWD</b></dt>
  <dd>由 <b>cd</b>
      命令設置的當前工作目錄。</dd>
  <dt><b>RANDOM</b></dt>
  <dd>每次引用這個參數時，都會產生一個
      0 到 32767
      之間的隨機整數。可以通過向
      <b>RANDOM</b>
      賦值來初始化隨機數序列。如果取消了
      <small><b>RANDOM</b></small>
      的定義，它就失去了特殊的意義，即使後來重新定義它。</dd>
  <dt><b>REPLY</b></dt>
  <dd>變量的值將作爲內建命令
      <b>read</b>
      的輸入，如果命令沒有參數的話。</dd>
  <dt><b>SECONDS</b></dt>
  <dd>每次引用這個參數時，返回
      shell
      自運行以來的秒數。如果向
      <b>SECONDS</b>
      賦值，此後對它的引用將返回自賦值時起的秒數加上所賦予的值。如果取消
      <small><b>SECONDS</b></small>
      的定義，它就失去了特殊的意義，即使後來重新定義它。</dd>
  <dt><b>SHELLOPTS</b></dt>
  <dd>一個冒號分隔的被允許的
      shell
      選項列表。列表中每個詞都是內置命令
      <b>set</b> 的 <b>-o</b>
      選項的有效參數。
      <small><b>SHELLOPTS</b></small>
      中出現的選項也是 <b>set
      -o</b> 顯示爲 <i>on</i>
      的選項。如果 <b>bash</b>
      啓動時從環境中找到這個變量，那麼在讀取任何配置文件之前，列表中的每個選項都將被設置。這個變量是隻讀的。</dd>
  <dt><b>SHLVL</b></dt>
  <dd>每次啓動一個 <b>bash</b>
      的實例時都會增加。</dd>
  <dt><b>UID</b></dt>
  <dd>擴展爲當前用戶的
      ID，在啓動時初始化。這個變量是隻讀的。</dd>
</dl>
<p class="Pp">下列變量被 shell
    使用。有時 <b>bash</b>
    會爲變量賦默認值；這些情況在下面會標出。</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>BASH_ENV</b></dt>
  <dd>如果 <b>bash</b> 在執行一個
      shell
      腳本時設定了這個變量，它的值將被解釋爲一個文件名，
      包含着初始化 shell
      用到的命令，就像
      <i>~/.bashrc</i> 中一樣。
      <small><b>BASH_ENV</b></small>
      的值在被解釋爲一個文件名之前要經過參數擴展，命令替換和算術擴展。不會使用
      <small><b>PATH</b></small>
      來查找結果文件名。</dd>
  <dt><b>CDPATH</b></dt>
  <dd>命令 <b>cd</b>
      的搜索路徑。這是一個冒號分隔的目錄列表，shell
      從中查找 <b>cd</b>
      命令的目標目錄。可以是這樣：
      &#34;.:~:/usr&#34;.</dd>
  <dt><b>COLUMNS</b></dt>
  <dd>用在內建命令 <b>select</b>
      當中，用來判斷輸出選擇列表時的終端寬度。
      自動根據 SIGWINCH
      信號來設置。</dd>
  <dt><b>COMPREPLY</b></dt>
  <dd>一個數組變量，<b>bash</b>
      從中讀取可能的命令補全。
      它是由命令補全功能調用的
      shell 函數產生的。</dd>
  <dt><b>FCEDIT</b></dt>
  <dd>內建命令 <b>fc</b>
      默認的編輯器。</dd>
  <dt><b>FIGNORE</b></dt>
  <dd>一個冒號分隔的後綴名列表，在進行文件名補全時被忽略
      (參見下面的 <small><b>READLINE</b></small>
      章節)。一個後綴滿足其中之一的文件名被排除在匹配的文件名之外。可以是這樣：
      &#34;.o:~&#34;.</dd>
  <dt><b>GLOBIGNORE</b></dt>
  <dd>一個冒號分隔的模式列表，定義了路徑名擴展時要忽略的文件名集合。
      如果一個文件名與路徑擴展模式匹配，同時匹配
      <b>GLOBIGNORE</b>
      中的一個模式時，它被從匹配列表中刪除。</dd>
  <dt><b>HISTCONTROL</b></dt>
  <dd>如果設置爲 <i>ignorespace</i>, 以
      <b>space</b>
      開頭的行將不會插入到歷史列表中。如果設置爲
      <i>ignoredups</i>,
      匹配上一次歷史記錄的行將不會插入。設置爲
      <i>ignoreboth</i>
      會結合這兩種選項。如果沒有定義，或者設置爲其他值，所有解釋器讀取的行都將存入歷史列表，
      但還要經過 <b>HISTIGNORE</b>
      處理。這個變量的作用可以被
      <b>HISTIGNORE</b>
      替代。多行的組合命令的第二和其餘行都不會被檢測，不管
      <b>HISTCONTROL</b>
      是什麼，都會加入到歷史中。</dd>
  <dt><b>HISTFILE</b></dt>
  <dd>保存命令歷史的文件名
      (參見下面的 <small><b>HISTORY
      歷史</b></small>
      章節)。默認值是
      <i>~/.bash_history</i>。如果取消定義，在交互式
      shell 退出時
      命令歷史將不會保存。</dd>
  <dt><b>HISTFILESIZE</b></dt>
  <dd>歷史文件中包含的最大行數。當爲這個變量賦值時，如果需要的話，歷史文件將被截斷
      來容納不超過這個值的行。默認值是
      500。歷史文件在交互式
      shell 退出時
      也會被截斷到這個值。</dd>
  <dt><b>HISTIGNORE</b></dt>
  <dd>一個冒號分隔的模式列表，用來判斷那個命令行應當保存在歷史列表中。每個模式
      都定位於行首，必須匹配整行
      (沒有假定添加
      `<b>*</b>&#39;)。在 <b>HISTCONTROL</b>
      指定的測試結束後，這裏的每個模式都要被測試。除了平常的
      shell 模式匹配字符，
      `<b>&amp;</b>&#39;
      匹配上一個歷史行。`<b>&amp;</b>&#39;
      可以使用反斜槓來轉義；反斜槓在
      嘗試匹配之前將被刪除。多行的組合命令的第二行以及後續行都不會被測試，不管
      <b>HISTIGNORE</b>
      是什麼，都將加入到歷史中。</dd>
  <dt><b>HISTSIZE</b></dt>
  <dd>命令歷史中保存的歷史數量
      (參見下面的 <small><b>HISTORY
      歷史</b></small>
      章節)。默認值是 500。</dd>
  <dt><b>HOME</b></dt>
  <dd>當前用戶的個人目錄；內建命令
      <b>cd</b>
      的默認參數。在執行波浪線擴展時也用到這個變量。</dd>
  <dt><b>HOSTFILE</b></dt>
  <dd>包含一個格式和 <i>/etc/hosts</i>
      相同的文件名，當 shell
      需要補全主機名時要讀取它。shell
      運行過程中
      可以改變可能的主機名補全列表；改變之後下一次需要主機名補全時
      <b>bash</b>
      會將新文件的內容添加到舊列表中。如果定義了
      <small><b>HOSTFILE</b></small>
      但是沒有賦值，<b>bash</b>
      將嘗試讀取 <i>/etc/hosts</i>
      文件來獲得可能的主機名補全列表。當取消
      <small><b>HOSTFILE</b></small>
      的定義時，主機名列表將清空。</dd>
  <dt><b>IFS</b></dt>
  <dd>內部字段分隔符 <i>Internal Field
      Separator</i>
      用來在擴展之後進行分詞，使用內部命令
      <b>read</b>
      將行劃分成詞。默認值是
      ``&lt;space&gt;&lt;tab&gt;&lt;newline&gt;&#39;&#39;。</dd>
  <dt><b>IGNOREEOF</b></dt>
  <dd>控制交互式 shell
      接受到唯一一個
      <small><b>EOF</b></small>
      字符時的行爲。如果有定義，值是需要在一行的開始連續輸入
      <small><b>EOF</b></small>
      字符，直到可以使
      <b>bash</b>
      退出的字符個數。如果這個變量存在，但是值不是一個數字或者沒有賦值，默認值是
      10。
      如果變量沒有定義，
      <small><b>EOF</b></small>
      標誌着輸入的結束。</dd>
  <dt><b>INPUTRC</b></dt>
  <dd><b>readline</b>
      的啓動配置文件，而不是默認的
      <i>~/.inputrc</i> (參見下面的
      <small><b>READLINE</b></small> 章節)。</dd>
  <dt><b>LANG</b></dt>
  <dd>用來決定沒有特地用
      <b>LC_</b>
      變量指定的語言環境項。</dd>
  <dt><b>LC_ALL</b></dt>
  <dd>這個變量超越了 <b>LANG</b>
      和所有其他指定語言環境項的
      <b>LC_</b> 變量。</dd>
  <dt><b>LC_COLLATE</b></dt>
  <dd>這個變量決定了爲路徑擴展的結果排序時的字母順序，決定了範圍表達式的行爲，
      等價類，和路徑擴展中的歸併順序以及模式匹配。</dd>
  <dt><b>LC_CTYPE</b></dt>
  <dd>這個變量決定了字符的解釋和路徑擴展以及模式匹配中字符類的行爲。</dd>
  <dt><b>LC_MESSAGES</b></dt>
  <dd>這個變量決定了翻譯以
      <b>$</b>
      前導的雙引號字符串時的語言環境。</dd>
  <dt><b>LC_NUMERIC</b></dt>
  <dd>這個變量決定了格式化數字時的語言環境分類。</dd>
  <dt><b>LINES</b></dt>
  <dd>內建命令 <b>select</b>
      用它來判斷輸出選擇列表時的列寬度。在收到
      SIGWINCH
    信號時自動設置。</dd>
  <dt><b>MAIL</b></dt>
  <dd>如果這個參數設置爲一個文件名，並且沒有設置環境變量
      <small><b>MAILPATH</b></small> 的話， <b>bash</b>
      將在這個文件中通知用戶有郵件到達。</dd>
  <dt><b>MAILCHECK</b></dt>
  <dd>指定 <b>bash</b>
      檢查郵件的頻率是多少，以秒爲單位。默認值是
      60
      秒。需要檢查郵件的時候，shell
      在顯示提示符之前將進行檢查。
      如果取消它的定義，或者設置爲並非大於等於零的數值，shell
      將禁止郵件檢查。</dd>
  <dt><b>MAILPATH</b></dt>
  <dd>一個冒號分隔的文件名列表，從中檢查郵件。當郵件到達某個特殊文件中時，輸出的特定消息可以
      通過將文件名與消息以
      `?&#39; 分隔來指定。
      在消息的文本中，<b>$_</b>
      擴展爲當前郵件文件的文件名。例如：</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"><b>MAILPATH</b>=&#39;/var/mail/bfox?&#34;You have
    mail&#34;:~/shell-mail?&#34;$_ has mail!&#34;&#39;</p>
<p class="Pp"><b>Bash</b>
    爲這個變量提供默認值，但是它使用的用戶郵件文件的位置是系統相關的
    (例如，/var/mail/<b>$USER</b>)。</p>
</div>
<dl class="Bl-tag">
  <dt><b>OPTERR</b></dt>
  <dd>如果設置爲 1， <b>bash</b>
      顯示內建命令 <b>getopts</b>
      產生的錯誤消息
      (參見下面的 <small><b>shell
      內建命令(SHELL BUILTIN COMMANDS)</b></small>
      章節)。每次 shell
      啓動時或者一個 shell
      腳本被執行時
      <small><b>OPTERR</b></small> 被初始化爲
      1。</dd>
  <dt><b>PATH</b></dt>
  <dd>搜索命令的路徑。它是一個冒號分割的目錄列表，shell
      從中搜索命令
      (參見下面的
      <small><b>命令執行(COMMAND EXECUTION)</b></small>
      段落)。默認的路徑是系統相關的，是由安裝
      <b>bash</b>
      的系統管理員設置的。通常它的值是
      ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin:.&#39;&#39;。</dd>
  <dt><b>POSIXLY_CORRECT</b></dt>
  <dd>如果 <b>bash</b>
      啓動環境中有這個變量，它將在讀取啓動配置文件之前進入
      <i>posix mode</i>，就好像提供了
      <b>--posix</b>
      啓動參數一樣。如果
      shell
      運行過程中設置了它，<b>bash</b>
      就啓用 <i>posix
      mode</i>，就好像執行了 <i>set -o
      posix</i> 命令一樣。</dd>
  <dt><b>PROMPT_COMMAND</b></dt>
  <dd>如果有定義，它的值將作爲一個命令，每次顯示主提示符之前都會執行。</dd>
  <dt><b>PS1</b></dt>
  <dd>這個參數的值被擴展
      (參見下面的 <small><b>PROMPTING
      提示符</b></small>
      段落)，用作主提示符字符串。默認值是
      ``<b>\s-\v\$ </b>&#39;&#39;。</dd>
  <dt><b>PS2</b></dt>
  <dd>這個參數的值同 <b>PS1</b>
      一起被擴展，用作次提示符字符串。默認值是
      ``<b>&gt; </b>&#39;&#39;。</dd>
  <dt><b>PS3</b></dt>
  <dd>這個參數的值被用作內建命令
      <b>select</b> 的提示符
      (參見上面的 <small><b>SHELL GRAMMAR
      語法</b></small> 章節)。</dd>
  <dt><b>PS4</b></dt>
  <dd>這個參數的值同 <b>PS1</b>
      一起被擴展，在執行跟蹤中在
      <b>bash</b>
      顯示每個命令之前顯示。需要的話，
      <small><b>PS4</b></small>
      的第一個字符會被複制多次，來指示
      indirection
      的層數。默認值是 ``<b>+
      </b>&#39;&#39;。</dd>
  <dt><b>TIMEFORMAT</b></dt>
  <dd>在前綴 time
      保留字的管道中，這個參數的值用作格式字符串，
      指定計時信息如何顯示。字符
      <b>%</b>
      引入的轉義序列，被擴展爲時間值
      或其他信息。轉義序列和它們的含義如下所示；括號中是可選的成分。
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>%%</b></dt>
  <dd>一個字面上的 <b>%</b>。</dd>
  <dt><b>%[<i>p</i>][l]R</b></dt>
  <dd>經歷的時間，以秒計算。</dd>
  <dt><b>%[<i>p</i>][l]U</b></dt>
  <dd>CPU
      在用戶模式下執行的秒數。</dd>
  <dt><b>%[<i>p</i>][l]S</b></dt>
  <dd>CPU
      在系統模式下執行的秒數。</dd>
  <dt><b>%P</b></dt>
  <dd>CPU 使用率，算法是 (%U + %S) /
      %R。</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>可選的 <i>p</i> 是指定精度
      (小數點後數字位數)
      的數值。 如果是 0
      就不輸出小數點或小數值。最多指定到小數點後三位；
      如果 <i>p</i> 大於 3
      就會被改爲
      3。如果沒有指定
      <i>p</i>，默認使用 3。</dd>
  <dt></dt>
  <dd>可選的 <b>l</b>
      指定了長格式，包含分鐘，格式是
      <i>MM</i>m<i>SS</i>.<i>FF</i>s。 <i>p</i>
      的值決定了是不是包含小數位。</dd>
  <dt></dt>
  <dd>如果沒有設置這個值，<b>bash</b>
      假定它的值是
      <b>$&#39;\nreal\t%3lR\nuser\t%3lU\nsys%3lS&#39;</b>。
      如果它是空值，就不會顯示計時信息。顯示格式字符串的時候，會加上
      一個前導的新行符。</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>TMOUT</b></dt>
  <dd>如果設置爲大於 0
      的值，<b>TMOUT</b>
      被當作內建命令 <b>read</b>
      的默認超時
      等待時間。如果等待終端輸入時，
      <b>TMOUT</b>
      秒之後仍然沒有輸入，
      <b>select</b>
      命令將終止。在交互的
      shell
      中，它的值被解釋爲顯示了
      主提示符之後等待輸入的秒數。如果經過這個秒數之後仍然沒有輸入，
      <b>Bash</b> 將退出。</dd>
  <dt><b>auto_resume</b></dt>
  <dd>這個變量控制了 shell
      如何與用戶和作業控制交互。如果設置了這個變量，
      一個不包含重定向的單個詞的簡單命令，將作爲恢復被中斷的作業的指示。
      不允許出現模棱兩可的情況；如果有多個作業都以這個詞起始，將恢復最近運行
      的作業。在這種情形下，被中斷的作業的
      <i>name</i>
      是用於啓動它的命令行。如果值設置爲
      <i>exact，</i>
      給出的字符串必須精確匹配被中斷的作業名；如果設置爲
      <i>substring</i>，
      給出的字符串需要匹配被中斷的作業名的子串。值
      <i>substring</i>
      的功能與作業標識符
      <b>%?</b> 功能類似
      (參見下面的 <small><b>JOB CONTROL
      作業控制</b></small>
      章節)。如果設置爲任何其他值，給出的字符串必須是被中斷的作業的前綴；
      這樣做與作業標識符
      <b>%</b> 功能類似。</dd>
  <dt><b>histchars</b></dt>
  <dd>兩到三個字符，控制着歷史擴展和分段
      (tokenization，參見下面的
      <small><b>HISTORY EXPANSION 歷史擴展</b></small>
      章節)。第一個字符是
      <i>history expansion</i>(歷史擴展)
      字符，
      這個字符表明了歷史擴展的開始，通常是
      `<b>!</b>&#39;。 第二個字符是
      <i>quick substitution</i>(快速替換)
      字符，
      它是重新運行上次輸入的命令，但將命令中的字符串替換爲另一個的簡寫，
      默認是
      `<b>^</b>&#39;。可選的第三個字符是指示如果作爲一個詞的開始，那麼
      一行中剩餘字符是註釋。通常這個字符是
      `<b>#</b>&#39;。歷史註釋字符使得
      對一行中剩餘字符在歷史替換中被跳過。它不一定使
      shell 解釋器將
      這一行的剩餘部分當作註釋。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Arrays">Arrays<a class="anchor" href="#Arrays">¶</a></h2>
<b>Bash</b>
  提供了一維數組變量。任何變量都可以作爲一個數組；內建命令
  <b>declare</b>
  可以顯式地定義數組。數組的大小沒有上限，也沒有限制在連續對成員引用和
  賦值時有什麼要求。數組以整數爲下標，從
  0 開始。
<p class="Pp">如果變量賦值時使用語法
    <i>name</i>[<i>subscript</i>]=<i>value</i>，
    那麼就會自動創建數組。
    <i>subscript</i>
    被當作一個算術表達式，結果必須是大於等於
    0
    的值。要顯式地定義一個數組，使用
    <b>declare -a <i>name</i></b> (參見下面的
    <small><b>shell 內建命令(SHELL BUILTIN
    COMMANDS)</b></small>
    章節)。也可以用 <b>declare -a
    <i>name</i>[<i>subscript</i>]</b> 這時 <i> subscript</i>
    被忽略。數組變量的屬性可以用內建命令
    <b>declare</b> 和 <b>readonly</b>
    來指定。每個屬性對於所有數組元素都有效。</p>
<p class="Pp">數組賦值可以使用複合賦值的方式，形式是
    <i>name</i>=<b>(</b>value<i>1</i> ...
    value<i>n</i><b>)</b>，這裏每個 <i>value</i>
    的形式都是
    [<i>subscript</i>]=<i>string</i>。<i>string</i>
    必須出現。如果出現了可選的括號和下標，將爲這個下標賦值，否則
    被賦值的元素的下標是語句中上一次賦值的下標加一。下標從
    0 開始。
    這個語法也被內建命令
    <b>declare</b>
    所接受。單獨的數組元素可以用上面介紹的語法
    <i>name</i>[<i>subscript</i>]=<i>value</i>
  來賦值。</p>
<p class="Pp">數組的任何元素都可以用
    ${<i>name</i>[<i>subscript</i>]} 來引用。
    花括號是必須的，以避免和路徑擴展衝突。如果
    <i>subscript</i> 是 <b>@</b> 或是
    <b>*</b>，它擴展爲 <i>name</i>
    的所有成員。
    這兩種下標只有在雙引號中才不同。在雙引號中，${<i>name</i>[*]}
    擴展爲一個詞，
    由所有數組成員的值組成，用特殊變量
    <small><b>IFS</b></small>
    的第一個字符分隔；${<i>name</i>[@]}
    將 <i>name</i>
    的每個成員擴展爲一個詞。
    如果數組沒有成員，${<i>name</i>[@]}
    擴展爲空串。這種不同類似於特殊參數
    <b>*</b> 和 <b>@</b> 的擴展
    (參見上面的 <b>Special Parameters</b>
    段落)。${#<i>name</i>[<i>subscript</i>]}
    擴展爲 ${<i>name</i>[<i>subscript</i>]}
    的長度。如果 <i>subscript</i> 是
    <b>*</b> 或者是
    <b>@</b>，擴展結果是數組中元素的個數。引用沒有下標數組變量等價於
    引用元素 0。</p>
<p class="Pp">內建命令 <b>unset</b>
    用於銷燬數組。<b>unset</b>
    <i>name</i>[<i>subscript</i>]
    將銷燬下標是 <i>subscript</i>
    的元素。 <b>unset</b> <i>name</i>, 這裏
    <i>name</i> 是一個數組，或者
    <b>unset</b> <i>name</i>[<i>subscript</i>], 這裏
    <i>subscript</i> 是 <b>*</b> 或者是
    <b>@</b>，將銷燬整個數組。</p>
<p class="Pp">內建命令 <b>declare</b>, <b>local</b>,
    和 <b>readonly</b> 都能接受 <b>-a</b>
    選項，從而指定一個數組。內建命令
    <b>read</b> 可以接受 <b>-a</b>
    選項，從標準輸入讀入一列詞來爲數組賦值。內建命令
    <b>set</b> 和 <b>declare</b>
    使用一種可以重用爲輸入的格式來顯示數組元素。</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="擴展(EXPANSION)">擴展(EXPANSION)<a class="anchor" href="#%E6%93%B4%E5%B1%95(EXPANSION)">¶</a></h1>
命令行的擴展是在拆分成詞之後進行的。有七種類型的擴展：
  <i>brace expansion</i>(花括號擴展), <i>tilde
  expansion</i>(波浪線擴展), <i>parameter and
  variable
  expansion</i>(參數和變量擴展),
  <i>command substitution</i>(命令替換), <i>arithmetic
  expansion</i>(算術擴展), <i>word
  splitting</i>(詞的拆分), 和 <i>pathname
  expansion</i>(路徑擴展).
<p class="Pp">擴展的順序是：brace
    expansion, tilde expansion, parameter, variable 和 arithmetic
    expansion 還有 command substitution
    (按照從左到右的順序),
    word splitting, 最後是 pathname expansion.</p>
<p class="Pp">還有一種附加的擴展：<i>process
    subtitution</i> (進程替換)
    只有在支持它
    的系統中有效。</p>
<p class="Pp">只有 brace expansion, word splitting, 和
    pathname expansion
    在擴展前後的詞數會發生改變；其他擴展總是將一個詞擴展爲一個詞。
    唯一的例外是上面提到的
    &#34;<b>$@</b>&#34; 和 &#34;<b>${</b><i>name</i><b>[@]}</b>&#34;
    (參見 <b>PARAMETERS</b>參數)。</p>
<section class="Ss">
<h2 class="Ss" id="Brace_Expansion">Brace Expansion<a class="anchor" href="#Brace_Expansion">¶</a></h2>
<i>Brace expansion</i>
  是一種可能產生任意字符串的機制。這種機制類似於
  <i>pathname expansion</i>,
  但是並不需要存在相應的文件。
  花括號擴展的模式是一個可選的
  <i>preamble</i>(前導字符),
  後面跟着一系列逗號分隔的字符串，包含在一對花括號中，
  再後面是一個可選的
  <i>postscript</i>(附言)。
  前導被添加到花括號中的每個字符串前面，附言被附加到每個結果字符串之後，
  從左到右進行擴展。
<p class="Pp">花括號擴展可以嵌套。擴展字符串的結果沒有排序；而是保留了從左到右的順序。
    例如， a<b>{</b>d,c,b<b>}</b>e 擴展爲
    `ade ace abe&#39;。</p>
<p class="Pp">花括號擴展是在任何其他擴展之前進行的，任何對其他擴展有特殊意義的字符
    都保留在結果中。它是嚴格字面上的。
    <b>Bash</b>
    不會對擴展的上下文或花括號中的文本做任何語義上的解釋。</p>
<p class="Pp">正確的花括號擴展必須包含沒有引用的左括號和右括號，以及至少一個沒有
    引用的逗號。任何不正確的表達式都不會被改變。可以用反斜槓來引用
    <b>{</b> 或 <b>,</b>
    來阻止將它們識別爲花括號表達式的一部分。
    爲了避免與參數擴展衝突，字符串
    <b>${</b>
    不被認爲有效的組合。</p>
<p class="Pp">這種結構通常用來簡寫字符串的公共前綴遠比上例中爲長的情況，例如：</p>
<div class="Bd-indent">
<p class="Pp">mkdir /usr/local/src/bash/{old,new,dist,bugs}</p>
</div>
或者：
<div class="Bd-indent">chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}</div>
<p class="Pp">花括號擴展導致了與歷史版本的
    <b>sh</b>
    的一點不兼容。在左括號或右括號作爲詞的一部分出現時，
    <b>sh</b>
    不會對它們進行特殊處理，會在輸出中保留它們。
    <b>Bash</b>
    將括號從花括號擴展結果的詞中刪除。例如，向
    <b>sh</b> 輸入 <i>file{1,2}</i>
    會導致不變的輸出。同樣的輸入在
    <b>bash</b>
    進行擴展之後，會輸出
    <i>file1 file2 .</i> 如果需要同 <b>sh</b>
    嚴格地保持兼容，需要在啓動
    <b>bash</b> 的時候使用 <b>+B</b>
    選項，或者使用 <b>set</b>
    命令加上 <b>+B</b>
    選項來禁用花括號擴展
    (參見下面的 <small><b>shell
    內建命令(SHELL BUILTIN COMMANDS)</b></small>
    章節)。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Tilde_Expansion">Tilde Expansion<a class="anchor" href="#Tilde_Expansion">¶</a></h2>
如果一個詞以沒有引用的波浪線字符
  (`<b>~</b>&#39;) 開始，所有
  在第一個沒有引用的斜線
  (`/&#39;) 之前的字符
  (或者是這個詞的所有字符，
  如果沒有沒引用的斜線的話)
  都被認爲是
  <i>tilde-prefix</i>(波浪線前綴)。
  如果 tilde-prefix
  中沒有被引用的字符，那麼波浪線之後的字符串
  被認爲是 <i>login
  name</i>(登錄名)。如果登錄名是空字符串，波浪線將
  被替換爲 shell 參數 <b>HOME</b>
  的值。如果沒有定義
  <small><b>HOME，</b></small>
  將替換爲執行此 shell
  的用戶的個人目錄。否則，tilde-prefix
  被替換爲
  與指定登錄名相聯繫的個人目錄。
<p class="Pp">如果 tilde-prefix 是
    `~+&#39;，將使用 shell 變量
    <small><b>PWD</b></small>
    的值來替換。如果
    tilde-prefix 是 `~-&#39;，並且設置了
    shell 變量 <b>OLDPWD</b>,
    將使用這個變量值來替換。如果在
    tilde-prefix
    中，波浪線之後的字符串
    由一個數字 <i>N</i>
    組成，前綴可選的 `+&#39;
    或者 `-&#39;，那麼 tilde-prefix
    將被替換爲目錄棧中相應的元素，就是將
    tilde-prefix
    作爲參數執行內建命令
    <b>dirs</b> 顯示的結果。如果
    tilde-prefix
    中波浪線之後的字符是一個數字，沒有前綴，
    那麼就假定有一個
  `+&#39;。</p>
<p class="Pp">如果登錄名不合法，或者波浪線擴展失敗，這個詞將不會變化。</p>
<p class="Pp">在變量賦值中，對於
    <b>:</b> 或 <b>=</b>
    之後的字符串會立即檢查未引用的
    tilde-prefix。
    這種情況下，仍然會進行波浪線擴展。因此，可以使用帶波浪線的文件名來爲
    <b>PATH</b>, <b>MAILPATH</b>, 和 <b>CDPATH</b>
    賦值，shell
    將賦予擴展之後的值。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parameter_Expansion">Parameter Expansion<a class="anchor" href="#Parameter_Expansion">¶</a></h2>
字符 `<b>$</b>&#39;
  引入了參數擴展，命令替換和算術擴展。要擴展的參數名或符號
  可能包含在花括號中，花括號可選的，但是可以使得要擴展的變量不會與緊隨其後
  的字符合並，成爲新的名稱。
<p class="Pp">使用花括號的時候，匹配的右括號是第一個
    `<b>}</b>&#39;，並且它沒有被反斜槓引用
    或包含在一個引用的字符串中，也沒有包含在一個嵌入的算術擴展，命令替換
    或是參數擴展中。</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt>${<i>parameter</i>}</dt>
  <dd>被替換爲 <i>parameter</i>
      的值。如果 <i>parameter</i>
      是一個位置參數，並且數字多於一位時；或者當緊隨
      <i>parameter</i>
      之後有不屬於名稱一部分的字符時，都必須加上花括號。</dd>
</dl>
<p class="Pp">如果 <i>parameter</i>
    的第一個字符是一個感嘆號，將引進一層間接變量。
    <b>bash</b> 使用以 <i>parameter</i>
    的其餘部分爲名的變量的值作爲變量的名稱；
    接下來新的變量被擴展，它的值用在隨後的替換當中，而不是使用
    <i>parameter</i>
    自身的值。這也稱爲
    <i>indirect expansion</i>(間接擴展).
    例外情況是下面講到的
    ${!<i>prefix</i>*}。</p>
<p class="Pp">下面的每種情況中，<i>word</i>
    都要經過波浪線擴展，參數擴展，命令替換和
    算術擴展。如果不進行子字符串擴展，<b>bash</b>
    測試一個沒有定義或值爲空的
    參數；忽略冒號的結果是隻測試未定義的參數。</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt>${<i>parameter</i><b>:-</b><i>word</i>}</dt>
  <dd><b>Use Default
      Values</b>(使用默認值)。如果
      <i>parameter</i>
      未定義或值爲空，將替換爲
      <i>word</i>
      的擴展。否則，將替換爲
      <i>parameter</i> 的值。</dd>
  <dt>${<i>parameter</i><b>:=</b><i>word</i>}</dt>
  <dd><b>Assign Default
      Values</b>(賦默認值)。如果
      <i>parameter</i>
      未定義或值爲空，
      <i>word</i> 的擴展將賦予
      <i>parameter</i>. <i>parameter</i>
      的值將被替換。位置參數和特殊參數不能用這種方式賦值。</dd>
  <dt>${<i>parameter</i><b>:?</b><i>word</i>}</dt>
  <dd><b>Display Error if Null or
      Unset</b>(顯示錯誤，如果未定義或值爲空)。如果
      <i>parameter</i>
      未定義或值爲空，<i>word</i>
      (或一條信息，如果
      <i>word</i> 不存在)
      的擴展將寫入到標準錯誤；shell
      如果不是交互的，則將退出。否則，
      <i>parameter</i>
    的值將被替換。</dd>
  <dt>${<i>parameter</i><b>:+</b><i>word</i>}</dt>
  <dd><b>Use Alternate
      Value</b>(使用可選值)。如果
      <i>parameter</i>
      未定義或值爲空，不會進行替換；否則將替換爲
      <i>word</i> 擴展後的值。</dd>
  <dt>${<i>parameter</i><b>:</b><i>offset</i>}</dt>
  <dd></dd>
  <dt>${<i>parameter</i><b>:</b><i>offset</i><b>:</b><i>length</i>}</dt>
  <dd><b>Substring
      Expansion</b>(子字符串擴展)。
      擴展爲<i>parameter</i> 的最多
      <i>length</i> 個字符，從 <i>offset</i>
      指定的字符開始。如果忽略了
      <i>length</i>，擴展爲 <i>parameter</i>
      的子字符串， 從 <i>offset</i>
      指定的字符串開始。<i>length</i>
      和 <i>offset</i> 是算術表達式
      (參見下面的 <small><b>ARITHMETIC EVALUATION
      算術求值</b></small> 段落)。
      <i>length</i>
      必須是一個大於等於 0
      的數值。如果 <i>offset</i>
      求值結果小於 0，
      值將當作從 <i>parameter</i>
      的值的末尾算起的偏移量。如果
      <i>parameter</i> 是 <b>@</b>，結果是
      <i>length</i> 個位置參數，從
      <i>offset</i> 開始。 如果 <i>parameter</i>
      是一個數組名，以 @
      或 *
      索引，結果是數組的
      <i>length</i> 個成員，從
      ${<i>parameter</i>[<i>offset</i>]} 開始。
      子字符串的下標是從 0
      開始的，除非使用位置參數時，下標從
      1 開始。</dd>
  <dt>${<b>!</b><i>prefix</i><b>*</b>}</dt>
  <dd>擴展爲名稱以 <i>prefix</i>
      開始的變量名，以特殊變量
      <small><b>IFS</b></small>
      的第一個字符分隔。</dd>
  <dt>${<b>#</b><i>parameter</i>}</dt>
  <dd>替換爲 <i>parameter</i>
      的值的長度
      (字符數目)。如果
      <i>parameter</i> 是 <b>*</b> 或者是 <b>@</b>,
      替換的值是位置參數的個數。如果
      <i>parameter</i>
      是一個數組名，下標是
      <b>*</b> 或者是 <b>@</b>,
      替換的值是數組中元素的個數。</dd>
  <dt>${<i>parameter</i><b>#</b><i>word</i>}</dt>
  <dd></dd>
  <dt>${<i>parameter</i><b>##</b><i>word</i>}</dt>
  <dd><i>word</i>
      被擴展爲一個模式，就像路徑擴展中一樣。如果這個模式匹配
      <i>parameter</i>
      的值的起始，那麼擴展的結果是將
      <i>parameter</i>
      擴展後的值中，最短的匹配
      (``<b>#</b>&#39;&#39; 的情況)
      或者最長的匹配
      (``<b>##</b>&#39;&#39;的情況)
      刪除的結果。如果
      <i>parameter</i> 是 <b>@</b> 或者是 <b>*</b>,
      則模式刪除操作將依次施用於每個位置參數，最後擴展爲結果的列表。如果
      <i>parameter</i>
      是一個數組變量，下標是
      <b>@</b> 或者是 <b>*</b>,
      模式刪除將依次施用於數組中的每個成員，最後擴展爲結果的列表。</dd>
  <dt>${<i>parameter</i><b>%</b><i>word</i>}</dt>
  <dd></dd>
  <dt>${<i>parameter</i><b>%%</b><i>word</i>}</dt>
  <dd><i>word</i>
      被擴展爲一個模式，就像路徑擴展中一樣。如果這個模式匹配
      <i>parameter</i>
      擴展後的值的尾部，那麼擴展的結果是將
      <i>parameter</i>
      擴展後的值中，最短的匹配
      (``<b>%</b>&#39;&#39; 的情況)
      或者最長的匹配
      (``<b>%%</b>&#39;&#39;的情況)
      刪除的結果。如果
      <i>parameter</i> 是 <b>@</b> 或者是 <b>*</b>,
      則模式刪除操作將依次施用於每個位置參數，最後擴展爲結果的列表。如果
      <i>parameter</i>
      是一個數組變量，下標是
      <b>@</b> 或者是 <b>*</b>,
      模式刪除將依次施用於數組中的每個成員，最後擴展爲結果的列表。</dd>
  <dt>${<i>parameter</i><b>/</b><i>pattern</i><b>/</b><i>string</i>}</dt>
  <dd></dd>
  <dt>${<i>parameter</i><b>//</b><i>pattern</i><b>/</b><i>string</i>}</dt>
  <dd><i>patterm</i>
      被擴展爲一個模式，就像路徑擴展中一樣。<i>parameter</i>
      被擴展，其值中最長的匹配
      <i>pattern</i> 的內容被替換爲
      <i>string</i>。
      在第一種形式中，只有第一個匹配被替換。第二種形式使得
      <i>pattern</i>
      中所有匹配都被替換爲
      <i>string</i>。 如果 <i>pattern</i> 以 <b>#</b>
      開始，它必須匹配
      <i>parameter</i> 擴展後
      值的首部。如果 <i>pattern</i>
      以 <b>%</b>
      開始，它必須匹配
      <i>parameter</i>
      擴展後值的尾部。如果
      <i>string</i> 是空值，<i>pattern</i>
      的匹配都將被刪除，
      <i>pattern</i> 之後的 <b>/</b>
      將被忽略。如果 <i>parameter</i>
      是 <b>@</b> 或者是 <b>*</b>,
      則替換操作將依次施用於每個位置參數，最後擴展爲結果的列表。如果
      <i>parameter</i>
      是一個數組變量，下標是
      <b>@</b> 或者是 <b>*</b>,
      模式刪除將依次施用於數組中的每個成員，最後擴展爲結果的列表。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Command_Substitution">Command Substitution<a class="anchor" href="#Command_Substitution">¶</a></h2>
命令替換 (<i>Command substitution</i>)
  允許以命令的輸出替換命令名。有
  兩種形式：
<p class="Pp"></p>
<div class="Bd-indent">
<p class="Pp"><b>$(</b><i>command</i><b>)</b></p>
</div>
還有
<div class="Bd-indent"><b>`</b><i>command</i><b>`</b></div>
<p class="Pp"><b>Bash</b>
    進行擴展的步驟是執行
    <i>command</i>，以它的標準輸出替換它，並且將所有後續的
    新行符刪除。內嵌的新行符不會刪除，但是它們可能會在詞的拆分中被刪除。
    命令替換 <b>$(cat </b><i>file</i><b>)</b>
    可以用等價但是更快的方法
    <b>$(&lt; </b><i>file</i><b>)</b> 代替。</p>
<p class="Pp">當使用舊式的反引號
    (&#34;``&#34;)
    替換形式時，反斜槓只有其字面意義，除非
    後面是 <b>$</b>, <b>`</b>, 或者是
    <b>\</b>.
    第一個前面沒有反斜槓的反引號將結束命令替換。當使用
    $(<i>command</i>)
    形式時，括號中所有字符組成了整個命令；沒有被特殊處理的字符。</p>
<p class="Pp">命令替換可以嵌套。要在使用反引號形式時嵌套，可以用反斜槓來轉義內層的
    反引號。</p>
<p class="Pp">如果替換髮生在雙引號之中，結果將不進行詞的拆分和路徑擴展。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Arithmetic_Expansion">Arithmetic Expansion<a class="anchor" href="#Arithmetic_Expansion">¶</a></h2>
算術擴展允許算術表達式的求值和結果的替換。算術擴展的格式是：
<div class="Bd-indent">
<p class="Pp"><b>$((</b><i>expression</i><b>))</b></p>
</div>
<p class="Pp">表達式 <i>expression</i>
    被視爲如同在雙引號之中一樣，但是括號中的雙引號不會被特殊處理。
    表達式中所有詞都經過了參數擴展，字符串擴展，命令替換和引用的刪除。
    算術替換可以嵌套。</p>
<p class="Pp">求值根據下面
    <b>算術求值 (ARITHMETIC EVALUATION)</b>
    章節中列出的規則進行。如果表達式
    <i>expression</i> 非法， <b>bash</b>
    輸出錯誤提示消息，不會進行替換。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Process_Substitution">Process Substitution<a class="anchor" href="#Process_Substitution">¶</a></h2>
<i>Process substitution</i> (進程替換)
  只有在支持命名管道
  (<i>FIFOs</i>)， 或者支持使用
  <b>/dev/fd</b>
  方式爲打開的文件命名的系統中才可用。
  它的形式是 <b>&lt;(</b><i>list</i><b>)</b>
  或者是 <b>&gt;(</b><i>list</i><b>)</b>。
  進程 <i>list</i>
  運行時的輸入或輸出被連接到一個
  <i>FIFO</i> 或者 <b>/dev/fd</b>
  中的文件。文件的名稱作爲一個參數被傳遞到當前命令，作爲擴展的結果。
  如果使用 <b>&gt;(</b><i>list</i><b>)</b>
  形式，向文件寫入相當於爲
  <i>list</i>
  提供輸入。如果使用
  <b>&lt;(</b><i>list</i><b>)</b>
  形式，可以讀作爲參數傳遞
  的文件來獲得 <i>list</i>
  的輸出。
<p class="Pp">如果可能的話，進程替換是與參數和變量擴展，命令替換和算術擴展同時發生的。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Word_Splitting">Word Splitting<a class="anchor" href="#Word_Splitting">¶</a></h2>
shell
  檢測不在雙引號引用中發生的參數擴展，命令替換和算術擴展的結果，
  進行 <i>word
  splitting</i>(詞的拆分)。
<p class="Pp">shell 將 <small><b>IFS</b></small>
    的每個字符都作爲定界符，根據這些字符來將其他擴展的結果分成詞。如果
    <small><b>IFS</b></small>
    沒有定義，或者它的值是默認的
    <b>&lt;space&gt;&lt;tab&gt;&lt;newline&gt;</b>, 那麼
    <small><b>IFS</b></small>
    字符的任何序列都將作爲分界之用。如果
    <small><b>IFS</b></small>
    的值是默認之外的值，那麼詞開頭和結尾的空白字符
    <b>space</b> 和 <b>tab</b>
    都將被忽略，只要空白字符在
    <b>IFS</b> 的值之內 (即，
    <small><b>IFS</b></small>
    包含空白字符)。
    任何在 <small><b>IFS</b></small>
    之中但是不是 <small><b>IFS</b></small>
    空白的字符，以及任何相鄰的
    <small><b>IFS</b></small>
    空白字符，將字段分隔開來。
    <small><b>IFS</b></small>
    空白字符的序列也被作爲分界符。如果
    <small><b>IFS</b></small>
    的值是空，不會發生詞的拆分。</p>
<p class="Pp">顯式給出的空值參數
    (<b>&#34;&#34;</b> 或 <b>&#39;&#39;</b>)
    將被保留。
    隱含的空值參數，來自於空值的參數擴展，如果沒有引用則將被刪除。
    如果空值的參數在雙引號引用中擴展，結果是空值的參數，將被保留。</p>
<p class="Pp">注意如果沒有發生擴展，不會進行詞的拆分。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pathname_Expansion">Pathname Expansion<a class="anchor" href="#Pathname_Expansion">¶</a></h2>
詞的拆分之後，除非設置過
  <b>-f</b> 選項， <b>bash</b>
  搜索每個詞，尋找字符
  <b>*</b>, <b>?</b>, 和 <b>[</b>.
  如果找到了其中之一，那麼這個詞被當作一個
  <i>pattern</i>(模式)，
  被替換爲匹配這個模式的文件名以字母順序排列的列表。如果沒有找到匹配的文件名，
  並且 shell 禁用了 <b>nullglob</b>
  選項，這個詞將不發生變化。如果設置了
  <b>nullglob</b>
  選項並且沒有找到匹配，這個詞將被刪除。如果啓用了
  <b>nocaseglob</b>
  選項，匹配時將不考慮字母的大小寫。當模式用作路徑名擴展時，字符
  <b>``.&#39;&#39;</b>
  如果在一個名稱的開始或者緊隨一個斜槓之後，那麼它必須被顯式地匹配，除非設置了
  <b>dotglob</b> shell
  選項。當匹配一個路徑名時，斜槓符必須被顯式地匹配。其他情況下，字符
  <b>``.&#39;&#39;</b>
  不會被特殊對待。參見下面的
  <small><b>shell 內建命令(SHELL BUILTIN
  COMMANDS)</b></small> 中對 <b>shopt</b>
  的介紹，其中有 shell
  選項 <b>nocaseglob</b>, <b>nullglob</b>, 和 <b>dotglob</b>
  的描述。
<p class="Pp">環境變量 <small><b>GLOBIGNORE</b></small>
    可以用來限制匹配
    <i>pattern</i>
    的文件名集合。如果設置了
    <small><b>GLOBIGNORE，</b></small>
    每個匹配的文件名如果匹配
    <small><b>GLOBIGNORE</b></small>
    中任何一個模式的話將從匹配的列表中刪除。文件名
    <b>``.&#39;&#39;</b> 和 <b>``..&#39;&#39;</b>
    總是被忽略，即使設置了
    <small><b>GLOBIGNORE。</b></small>
    但是，設置 <small><b>GLOBIGNORE</b></small>
    和啓用 shell 選項 <b>dotglob</b>
    效果是相同的，因此所有其他以
    <b>``.&#39;&#39;</b>
    開頭的文件名將被匹配。要得到原來的行爲
    (忽略所有以 <b>``.&#39;&#39;</b>
    開頭的文件名)，可以將
    <b>``.*&#39;&#39;</b> 添加爲 <b>GLOBIGNORE</b>
    的模式之一。選項
    <b>dotglob</b> 被禁用，如果
    <small><b>GLOBIGNORE</b></small>
    沒有定義時。</p>
<p class="Pp"><b>Pattern Matching</b></p>
<p class="Pp">任何模式中出現的字符，除了下面描述的特殊模式字符外，都匹配它本身。
    模式中不能出現 NUL
    字符。如果要匹配字面上的特殊模式字符，它必須被引用。</p>
<p class="Pp">特殊模式字符有下述意義：</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>*</b></dt>
  <dd>匹配任何字符串包含空串。</dd>
  <dt><b>?</b></dt>
  <dd>匹配任何單個字符。</dd>
  <dt><b>[...]</b></dt>
  <dd>匹配所包含的任何字符之一。用一個連字符
      (`-&#39;)
      分隔的一對字符意思是一個
      <i>range expression</i> (範圍表達式)；
      任何排在它們之間的字符，包含它們，都被匹配。
      排序使用當前語言環境的字符順序和字符集。如果
      <b>[</b>
      之後的第一個字符是一個
      <b>!</b> 或是一個 <b>^</b>
      那麼任何不包含在內的字符將被匹配。範圍表達式中字符的順序是由當前語言環境
      和環境變量 <b>LC_COLLATE</b>
      的值
      (如果設置了的話)
      決定的。一個 <b>-</b>
      只有作爲集合中第一個或最後一個字符時才能被匹配。一個
      <b>]</b>
      只有是集合中第一個字符時才能被匹配。
    <p class="Pp">在 <b>[</b> 和 <b>]</b>
        中，<i>character classes</i> (字符類)
        可以用 <b>[:</b><i>class</i><b>:]</b>
        這樣的語法來指定，這裏
        <i>class</i> 是在 POSIX.2
        標準中定義的下列類名之一:</p>
  </dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent"><b>alnum alpha ascii blank cntrl digit graph lower print
  punct space upper word xdigit</b>
<br/>
一個字符類匹配任何屬於這一類的字符。<b>word</b>
  字符類匹配字母，數字和字符
  _。
<p class="Pp">在 <b>[</b> 和 <b>]</b>
    中，可以用 <b>[=</b><i>c</i><b>=]</b>
    這樣的語法來指定
    <i>equivalence class</i>
    (等價類)。它匹配與字符
    <i>c</i> 有相同歸併權值 (collation
    weight，由當前
    語言環境定義)
    的字符。</p>
<p class="Pp">在 <b>[</b> 和 <b>]</b>
    中，語法 <b>[.</b><i>symbol</i><b>.]</b>
    匹配歸併符號 (collating symbol)
    <i>symbol</i>。</p>
</div>
<p class="Pp">如果使用內建命令
    <b>shopt</b> 啓用了 shell 選項
    <b>extglob</b>，
    將識別另外幾種模式匹配操作符。下面的描述中，<i>pattern-list</i>
    是一個 或多個模式以
    <b>|</b>
    分隔的列表。複合的模式可以使用一個或多個下列的
    子模式構造出來：</p>
<p class="Pp"></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>?(</b><i>pattern-list</i><b>)</b></dt>
  <dd>匹配所給模式零次或一次出現</dd>
  <dt><b>*(</b><i>pattern-list</i><b>)</b></dt>
  <dd>匹配所給模式零次或多次出現</dd>
  <dt><b>+(</b><i>pattern-list</i><b>)</b></dt>
  <dd>匹配所給模式一次或多次出現</dd>
  <dt><b>@(</b><i>pattern-list</i><b>)</b></dt>
  <dd>準確匹配所給模式之一</dd>
  <dt><b>!(</b><i>pattern-list</i><b>)</b></dt>
  <dd>任何除了匹配所給模式之一的字串</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Quote_Removal">Quote Removal<a class="anchor" href="#Quote_Removal">¶</a></h2>
經過前面的擴展之後，所有未引用的字符
  <b>\</b>, <b>&#39;</b>,
  以及並非上述擴展結果的字符
  <b>&#34;</b> 都被刪除。
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="重定向(REDIRECTION)">重定向(REDIRECTION)<a class="anchor" href="#%E9%87%8D%E5%AE%9A%E5%90%91(REDIRECTION)">¶</a></h1>
在命令執行前，它的輸入和輸出可能被
  <i>redirected (重定向)，</i>
  使用一種 shell
  可以解釋的特殊記法。重定向也可以用於爲當前
  shell 執行環境
  打開和關閉文件。下列重定向操作符可以前置或者放在
  <i>simple command (簡單命令)</i>
  之中的任何位置，或者放在
  <i>command</i>
  之後。重定向是以出現的順序進行處理的，從左到右。
<p class="Pp">下列描述中，如果文件描述符被忽略，並且第一個重定向操作符是
    <b>&lt;</b>,
    那麼重定向指的是標準輸入
    (文件描述符是
    0)。如果重定向操作符的第一個字符是
    <b>&gt;</b>,
    那麼重定向指的是標準輸出
    (文件描述符是 1)。</p>
<p class="Pp">下列描述中，重定向操作符之後的詞如果沒有特殊說明，都要經過
    brace expansion, tilde expansion, parameter expansion, command substitution,
    arithmetic expansion, quote removal, pathname expansion, 還有
    word
    splitting。如果擴展爲多於一個詞，
    <b>bash</b> 將報錯。</p>
<p class="Pp">注意重定向的順序非常重要。例如，命令</p>
<div class="Bd-indent">
<p class="Pp">ls <b>&gt;</b> dirlist 2<b>&gt;&amp;</b>1</p>
</div>
<p class="Pp">將標準輸出和標準錯誤重定向到文件
    <i>dirlist</i>, 而命令</p>
<div class="Bd-indent">
<p class="Pp">ls 2<b>&gt;&amp;</b>1 <b>&gt;</b> dirlist</p>
</div>
<p class="Pp">只會將標準輸出重定向到文件
    <i>dirlist</i>,
    因爲在標準輸出被重定向到文件
    <i>dirlist</i>
    中之前，標準錯誤被複製爲標準輸出。</p>
<p class="Pp">一些文件名在重定向中被
    <b>bash</b>
    特殊處理，如下表所示：</p>
<div class="Bd-indent">
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>/dev/fd/<i>fd</i></b></dt>
  <dd>如果 <i>fd</i>
      是一個合法的整數，文件描述符
      <i>fd</i> 將被複制。</dd>
  <dt><b>/dev/stdin</b></dt>
  <dd>文件描述符 0
      被複制。</dd>
  <dt><b>/dev/stdout</b></dt>
  <dd>文件描述符 1
      被複制。</dd>
  <dt><b>/dev/stderr</b></dt>
  <dd>文件描述符 2
      被複制。</dd>
  <dt><b>/dev/tcp/<i>host</i>/<i>port</i></b></dt>
  <dd>如果 <i>host</i>
      是一個合法的主機名或
      Internet 地址，並且 <i>port</i> 是
      一個整數端口號或服務名，<b>bash</b>
      試圖建立與相應的 socket
      (套接字) 的 TCP 連接。</dd>
  <dt><b>/dev/udp/<i>host</i>/<i>port</i></b></dt>
  <dd>如果 <i>host</i>
      是一個合法的主機名或
      Internet 地址，並且 <i>port</i> 是
      一個整數端口號或服務名，<b>bash</b>
      試圖建立與相應的 socket
      (套接字) 的 UDP 連接。</dd>
</dl>
</div>
<p class="Pp">打開或創建文件錯誤將導致重定向出錯。</p>
<section class="Ss">
<h2 class="Ss" id="Redirecting_Input">Redirecting Input<a class="anchor" href="#Redirecting_Input">¶</a></h2>
重定向輸入使得以 <i>word</i>
  擴展結果爲名的文件被打開並通過文件描述符
  <i>n</i>
  讀取，如果沒有指定
  <i>n</i>
  那麼就作爲標準輸入
  (文件描述符爲 0) 讀取。
<p class="Pp">重定向輸入的一般形式是：</p>
<div class="Bd-indent">
<p class="Pp">[<i>n</i>]<b>&lt;</b><i>word</i></p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Redirecting_Output">Redirecting Output<a class="anchor" href="#Redirecting_Output">¶</a></h2>
重定向輸出使得以 <i>word</i>
  擴展結果爲名的文件被打開並通過文件描述符
  <i>n</i>
  寫入，如果沒有指定
  <i>n</i>
  那麼就作爲標準輸出
  (文件描述符爲 1) 寫入。
<p class="Pp">重定向的一般形式是：</p>
<div class="Bd-indent">
<p class="Pp">[<i>n</i>]<b>&gt;</b><i>word</i></p>
</div>
<p class="Pp">如果重定向操作符是
    <b>&gt;</b>，
    並且啓用了內建命令
    <b>set</b> 的 <b>noclobber</b>
    選項，那麼如果 <i>word</i>
    擴展後得到的文件名存在並且是一個普通的文件，
    重定向將失敗。如果重定向操作符是
    <b>&gt;|</b>,
    或者重定向操作符是
    <b>&gt;</b>
    並且沒有啓用內建命令
    <b>set</b> 的 <b>noclobber</b>
    選項，那麼即使 <i>word</i>
    得出的文件名存在，也會嘗試進行重定向。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Appending_Redirected_Output_(添加到重定向後的輸出尾部)">Appending Redirected Output (添加到重定向後的輸出尾部)<a class="anchor" href="#Appending_Redirected_Output_(%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%87%8D%E5%AE%9A%E5%90%91%E5%BE%8C%E7%9A%84%E8%BC%B8%E5%87%BA%E5%B0%BE%E9%83%A8)">¶</a></h2>
這種方式的輸出重定向使得以
  <i>word</i>
  擴展結果爲名的文件被打開並通過文件描述符
  <i>n</i>
  從尾部添加。如果沒有指定
  <i>n</i> 就使用標準輸出
  (文件描述符
  1)。如果文件不存在，它將被創建。
<p class="Pp">重定向的一般形式是：</p>
<div class="Bd-indent">
<p class="Pp">[<i>n</i>]<b>&gt;&gt;</b><i>word</i></p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Redirecting_Standard_Output_and_Standard_Error">Redirecting Standard Output and Standard Error<a class="anchor" href="#Redirecting_Standard_Output_and_Standard_Error">¶</a></h2>
<b>Bash</b>
  允許使用這種結構將標準輸出和標準錯誤
  (文件描述符 1 和 2)
  重定向到以 <i>word</i>
  擴展結果爲名的文件中。
<p class="Pp">有兩種重定向標準輸出/標準錯誤的形式：</p>
<div class="Bd-indent">
<p class="Pp"><b>&amp;&gt;</b><i>word</i></p>
</div>
還有
<div class="Bd-indent"><b>&gt;&amp;</b><i>word</i></div>
<p class="Pp">兩種形式中，推薦使用第一種。它與</p>
<div class="Bd-indent">
<p class="Pp"><b>&gt;</b><i>word</i> 2<b>&gt;&amp;</b>1</p>
</div>
在語義上等價。
</section>
<section class="Ss">
<h2 class="Ss" id="Here_Documents">Here Documents<a class="anchor" href="#Here_Documents">¶</a></h2>
這種重定向使得 shell
  從當前源文件讀取輸入，直到遇到僅包含
  <i>word</i> 的一行
  (並且沒有尾部空白，trailing
  blanks)
  爲止。直到這一點的所有行被用作
  命令的標準輸入。
<p class="Pp">here-document 的格式是：</p>
<div class="Bd-indent">
<p class="Pp"></p>
<pre><b>&lt;&lt;</b>[<b>-</b>]<i>word</i>
        <i>here-document</i>
<i>delimiter</i>
</pre>
</div>
<p class="Pp">不會對 <i>word</i> 進行 parameter
    expansion, command substitution, arithmetic expansion, 或者
    pathname expansion。如果 <i>word</i>
    中任何字符是引用的，
    <i>delimiter</i> 將是對 <i>word</i>
    進行引用刪除的結果，here-document
    中的行不會被擴展。如果
    <i>word</i> 沒有被引用，here-documnet
    中的所有行都要經過
    parameter expansion, command substitution, 和 arithmetic
    expansion。
    在後一種情況下，字符序列
    <b>\&lt;newline&gt;</b>
    被忽略；必須用 <b>\</b>
    來引用字符 <b>\</b>, <b>$</b>, 和
    <b>`</b>.</p>
<p class="Pp">如果重定向操作符是
    <b>&lt;&lt;-</b>, 那麼所有前導的
    tab
    字符都被從輸入行和包含
    <i>delimiter</i>
    的行中刪除。這樣使得
    shell 腳本中的 here-document
    可以被更好地縮進。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Here_Strings">Here Strings<a class="anchor" href="#Here_Strings">¶</a></h2>
here-document 的變種，形式是
<div class="Bd-indent">
<p class="Pp"></p>
<pre><b>&lt;&lt;&lt;</b><i>word</i>
</pre>
</div>
<p class="Pp"><i>word</i>
    被擴展，提供給命令作爲標準輸入。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Duplicating_File_Descriptors_(複製文件描述符)">Duplicating File Descriptors (複製文件描述符)<a class="anchor" href="#Duplicating_File_Descriptors_(%E8%A4%87%E8%A3%BD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)">¶</a></h2>
重定向操作符
<div class="Bd-indent">
<p class="Pp">[<i>n</i>]<b>&lt;&amp;</b><i>word</i></p>
</div>
<p class="Pp">用於複製文件描述符。如果
    <i>word</i>
    擴展爲一個或多個數字，
    <i>n</i>
    代表的文件描述符將成爲那個文件描述符的複製。如果
    <i>word</i>
    中的數字並未指定一個被用於讀取的文件描述符，將產生一個重定向錯誤。如果
    <i>word</i> 擴展爲 <b>-</b>,
    文件描述符 <i>n</i>
    將被關閉。如果沒有指定
    <i>n，</i> 將使用標準輸入
    (文件描述符 0)。</p>
<p class="Pp">類似的，操作符</p>
<div class="Bd-indent">
<p class="Pp">[<i>n</i>]<b>&gt;&amp;</b><i>word</i></p>
</div>
<p class="Pp">用於複製輸出文件描述符。如果沒有指定
    <i>n，</i> 將使用標準輸出
    (文件描述符 1)。如果
    <i>word</i>
    中的數字並未指定一個被用於輸出的文件描述符，將產生一個重定向錯誤。
    特殊情況下，如果忽略了
    <i>n</i>，並且 <i>word</i>
    並非擴展爲一個或多個數字，
    標準輸出和標準錯誤將被重定向，和前面描述的一樣。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Moving_File_Descriptors">Moving File Descriptors<a class="anchor" href="#Moving_File_Descriptors">¶</a></h2>
重定向操作符
<div class="Bd-indent">
<p class="Pp">[<i>n</i>]<b>&lt;&amp;</b><i>digit</i><b>-</b></p>
</div>
<p class="Pp">將文件描述符 <i>digit</i>
    移動爲文件描述符 <i>n</i>,
    或標準輸入
    (文件描述符
    0)，如果沒有指定 <i>n</i>
    的話。 <i>digit</i> 複製爲 <i>n</i>
    之後就被關閉了。</p>
<p class="Pp">類似的，重定向操作符</p>
<div class="Bd-indent">
<p class="Pp">[<i>n</i>]<b>&gt;&amp;</b><i>digit</i><b>-</b></p>
</div>
<p class="Pp">將文件描述符 <i>digit</i>
    移動爲文件描述符 <i>n</i>,
    或標準輸出
    (文件描述符
    1)，如果沒有指定 <i>n</i>
    的話。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Opening_File_Descriptors_for_Reading_and_Writing">Opening File Descriptors for Reading and Writing<a class="anchor" href="#Opening_File_Descriptors_for_Reading_and_Writing">¶</a></h2>
重定向操作符
<div class="Bd-indent">
<p class="Pp">[<i>n</i>]<b>&lt;&gt;</b><i>word</i></p>
</div>
<p class="Pp">使得以 <i>word</i>
    擴展結果爲名的文件被打開，通過文件描述符
    <i>n</i>
    進行讀寫。如果沒有指定
    <i>n</i>
    那麼就使用文件描述符
    0。如果文件不存在，它將被創建。</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="別名(ALIASES)">別名(ALIASES)<a class="anchor" href="#%E5%88%A5%E5%90%8D(ALIASES)">¶</a></h1>
<i>Aliases</i> (別名機制)
  允許將一個詞來替換爲一個字符串，如果它是
  一個簡單命令的第一個詞的話。shell
  記錄着一個別名列表，可以使用
  內建命令 <b>alias</b> 和 <b>unalias</b>
  來定義和取消
  (參見下面的 <small><b>shell
  內建命令(SHELL BUILTIN COMMANDS)</b></small>
  章節)。每個命令的第一個詞，如果沒有引用，都將被檢查是否是一個別名。
  如果是，這個詞將被它所指代的文本替換。別名和替換的文本可以包含任何有效
  的 shell
  輸入，包含上面列出的
  <i>metacharacters (元字符)</i>
  ，特殊情況是別名中不能包含
  <i>=</i>。替換文本的第一個詞也被檢查是否
  是別名，但是如果它與被替換的別名相同，就不會再替換第二次。這意味着可以用
  <b>ls</b> 作爲 <b>ls -F</b> 的別名，
  <b>bash</b>
  不會遞歸地展開替換文本。如果別名的最後一個字符是
  <i>blank</i>,
  那麼命令中別名之後的下一個詞也將被檢查是否能進行別名展開。
<p class="Pp">別名可以使用 <b>alias</b>
    命令來創建或列舉出來，使用
    <b>unalias</b> 命令來刪除。</p>
<p class="Pp">在替換文本中沒有參數機制。如果需要參數，應當使用
    shell 函數 (參見下面的
    <small><b>FUNCTIONS (函數)</b></small>
  段落)。</p>
<p class="Pp">如果 shell
    不是交互的，別名將不會展開，除非使用內建命令
    <b>shopt</b> 設置了 <b>expand_aliases</b>
    選項。</p>
<p class="Pp">關於別名的定義和使用中的規則比較混亂。
    <b>Bash</b>
    在執行一行中的任何命令之前，總是讀入至少完整一行的輸入。
    別名在命令被讀取時展開，而不是在執行的時候。因此，別名定義如果
    和另一個命令在同一行，那麼不會起作用，除非讀入了下一行。
    別名定義之後，同一行中的命令不會受新的別名影響。這種行爲
    在函數執行時存在爭議，因爲別名替換是在函數定義被讀取時發生的，
    而不是函數被執行的時候，因爲函數定義本身是一個複合命令。結果，
    在函數中定義的別名只有當這個函數執行完纔會生效。爲了保險起見，
    應當總是將別名定義放在單獨的一行，不在複合命令中使用
    <b>alias。</b></p>
<p class="Pp">不管什麼情況下，別名都被
    shell 函數超越 (be superseded)。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="函數(FUNCTIONS)">函數(FUNCTIONS)<a class="anchor" href="#%E5%87%BD%E6%95%B8(FUNCTIONS)">¶</a></h1>
一個 shell 函數，以上面 <b>SHELL
  GRAMMAR</b>
  中描述的方法定義，保存着一系列的命令，等待稍後執行。
  當 shell
  函數名作爲一個簡單命令名使用時，這個函數名關聯的命令的序列
  被執行。函數在當前 shell
  的上下文環境中執行；不會創建新的進程來
  解釋它們 (這與 shell
  腳本的執行形成了對比)。當執行函數時，函數
  的參數成爲執行過程中的位置參數
  (positional parameters)。特殊參數 <b>#</b>
  被更新以反映這個變化。位置參數
  0
  不會改變。函數執行時，
  <small><b>FUNCNAME</b></small>
  變量被設置爲函數的名稱。函數和它的調用者在
  shell 執行環境的所有
  其他方面都是一樣的，特殊情況是
  <small><b>DEBUG</b></small> 陷阱
  (參見下面對內建函數
  <b>trap</b> 的描述，在 <small><b>shell
  內建命令(SHELL BUILTIN COMMANDS)</b></small>
  章節中)
  不會被繼承，除非函數設置了
  <b>trace</b> 屬性
  (參見下面對內建函數
  <small><b>declare</b></small> 的描述)。
<p class="Pp">函數中的局部變量可以使用內建命令
    <b>local</b>
    來聲明。通常情況下，變量和它們的值在函數和它的調用者之間是共享的。</p>
<p class="Pp">如果函數中執行了內建命令
    <b>return，</b>
    那麼函數結束，執行從函數調用之後的下一個命令開始。
    函數結束後，位置參數的值以及特殊參數
    <b>#</b>
    都將重置爲它們在函數執行前的值。</p>
<p class="Pp">函數名和定義可以使用內建命令
    <b>declare</b> 或 <b>typeset</b> 加上 <b>-f</b>
    參數來列出。如果在
    <b>declare</b> 或 <b>typeset</b>
    命令中使用 <b>-F</b>
    選項將只列出函數名。函數可以使用內建命令
    <b>export</b> 加上 <b>-f</b>
    參數導出，使得子 shell
    中它們被自動定義。</p>
<p class="Pp">函數可以是遞歸的。對於遞歸調用的次數沒有硬性限制。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="算術求值(&#34;ARITHMETIC_EVALUATION&#34;)">算術求值(&#34;ARITHMETIC EVALUATION&#34;)<a class="anchor" href="#%E7%AE%97%E8%A1%93%E6%B1%82%E5%80%BC(%22ARITHMETIC_EVALUATION%22)">¶</a></h1>
在一定的環境下，shell
  允許進行算術表達式的求值
  (參見內建命令 <b>let</b> 和
  <b>Arithmetic Expansion</b>
  (算術表達式))。
  求值使用固定寬度的整數，不檢查是否溢出，但是被零除會被捕獲，標記爲錯誤。
  操作數及其優先級和聚合程度與
  C
  語言中相同。下列操作數的列表按照相同
  優先級的操作數其級別來分組。列出的級別順序是優先級遞減的。
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b><i>id</i>++ <i>id</i>--</b></dt>
  <dd>變量自增/自減 (在後)</dd>
  <dt><b>++<i>id</i> --<i>id</i></b></dt>
  <dd>變量自增/自減 (在前)</dd>
  <dt><b>- +</b></dt>
  <dd>(單目的) 取負/取正</dd>
  <dt><b>! ~</b></dt>
  <dd>邏輯和位取反</dd>
  <dt><b>**</b></dt>
  <dd>乘冪</dd>
  <dt><b>* / %</b></dt>
  <dd>乘，除，取餘</dd>
  <dt><b>+ -</b></dt>
  <dd>加，減</dd>
  <dt><b>&lt;&lt; &gt;&gt;</b></dt>
  <dd>左/右位移</dd>
  <dt><b>&lt;= &gt;= &lt; &gt;</b></dt>
  <dd>比較</dd>
  <dt><b>== !=</b></dt>
  <dd>相等/不等</dd>
  <dt><b>&amp;</b></dt>
  <dd>位與 (AND)</dd>
  <dt><b>^</b></dt>
  <dd>位異或 (exclusive OR)</dd>
  <dt><b>|</b></dt>
  <dd>位或 (OR)</dd>
  <dt><b>&amp;&amp;</b></dt>
  <dd>邏輯與 (AND)</dd>
  <dt><b>||</b></dt>
  <dd>邏輯或 (OR)</dd>
  <dt><b><i>expr</i>?<i>expr</i>:<i>expr</i></b></dt>
  <dd>條件求值</dd>
  <dt><b>= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</b></dt>
  <dd>賦值</dd>
  <dt><b><i>expr1</i> , <i>expr2</i></b></dt>
  <dd>逗號表達式</dd>
</dl>
<p class="Pp">shell
    變量可以作爲操作數；在表達式求值之前會進行參數擴展。
    在表達式中，可以用名稱引用
    shell
    變量，不必使用參數擴展的語法。
    變量被引用時，其值被作爲算術表達式來求值。
    shell
    變量用於表達式中時，不必啓用整數屬性。</p>
<p class="Pp">以 0
    爲前導的常量被當作八進制數，以
    0x 或 0X
    作爲前導表明是十六進制。
    其他情況下，數字的形式是
    [<i>base#</i>]n，這裏 <i>base</i> 是一個
    2 到 64
    的十進制數值，作爲數字的基數，<i>n</i>
    是在這個基數中數字的值。
    如果忽略了
    <i>base#</i>，將以 10
    爲基數。大於 10
    的數字依次以小寫字母，
    大寫字母，@ 和 _
    表示。如果 <i>base</i>
    小於或等於 36，在表示
    10 與 35 之間
    的數字時小寫字母和大寫字母可以互換。</p>
<p class="Pp">操作符根據優先級順序進行求值。圓括號中的子表達式被最先求值，可能會
    超越上面的優先級規則。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="條件表達式(&#34;CONDITIONAL_EXPRESSIONS&#34;)">條件表達式(&#34;CONDITIONAL EXPRESSIONS&#34;)<a class="anchor" href="#%E6%A2%9D%E4%BB%B6%E8%A1%A8%E9%81%94%E5%BC%8F(%22CONDITIONAL_EXPRESSIONS%22)">¶</a></h1>
條件表達式用於 <b>[[</b>
  複合命令以及內建命令
  <b>test</b> 和 <b>[</b> 中，
  用來測試文件屬性，進行字符串和算術比較。表達式使用下面的單目或二進制操作構造。
  如果某操作的任何 <i>file</i>
  參數的形式是
  <i>/dev/fd/n</i>，那麼將檢查
  文件描述符
  <i>n</i>。如果某操作的 <i>file</i>
  參數是 <i>/dev/stdin</i>， <i>/dev/stdout</i>
  或者 <i>/dev/stderr</i>
  之一，將分別檢查文件描述符
  0，1 和 2。
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>-a <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在則爲真。</dd>
  <dt><b>-b <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且爲塊設備則爲真。</dd>
  <dt><b>-c <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且爲字符設備則爲真。</dd>
  <dt><b>-d <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且是一個目錄則爲真。</dd>
  <dt><b>-e <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在則爲真。</dd>
  <dt><b>-f <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且爲普通文件則爲真。</dd>
  <dt><b>-g <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且是設置組ID的 (sgid)
      則爲真。</dd>
  <dt><b>-h <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且爲符號鏈接則爲真。</dd>
  <dt><b>-k <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且設置了 ``sticky&#39;&#39; 位
      (粘滯位) 則爲真。</dd>
  <dt><b>-p <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且是一個命名管道
      (FIFO) 則爲真。</dd>
  <dt><b>-r <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且可讀則爲真。</dd>
  <dt><b>-s <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且大小大於零則爲真。</dd>
  <dt><b>-t <i>fd</i></b></dt>
  <dd>如果文件描述符 <i>fd</i>
      是打開的且對應一個終端則爲真。</dd>
  <dt><b>-u <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且是設置用戶ID的
      (suid) 則爲真。</dd>
  <dt><b>-w <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且可寫則爲真。</dd>
  <dt><b>-x <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且可執行則爲真。</dd>
  <dt><b>-O <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且爲有效用戶ID所擁有則爲真。</dd>
  <dt><b>-G <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且爲有效組ID所擁有則爲真。</dd>
  <dt><b>-L <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且爲符號鏈接則爲真。</dd>
  <dt><b>-S <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且爲套接字則爲真。</dd>
  <dt><b>-N <i>file</i></b></dt>
  <dd>如果 <i>file</i>
      存在且上次讀取後被修改過則爲真。</dd>
  <dt><i>file1</i> -<b>nt</b> <i>file2</i></dt>
  <dd>如果 <i>file1</i> 比 <i>file2</i> 要新
      (根據修改日期)，或者
      如果 <i>file1</i> 存在而 <i>file2</i>
      不存在，則爲真。</dd>
  <dt><i>file1</i> -<b>ot</b> <i>file2</i></dt>
  <dd>如果 <i>file1</i> 比 <i>file2</i>
      更舊，或者 如果 <i>file1</i>
      不存在而 <i>file2</i>
      存在，則爲真。</dd>
  <dt><i>file1</i> <b>-ef</b> <i>file2</i></dt>
  <dd>如果 <i>file1</i> 和 <i>file2</i>
      指的是相同的設備和
      inode 號則爲真。</dd>
  <dt><b>-o <i>optname</i></b></dt>
  <dd>如果啓用了 shell 選項
      <i>optname</i>
      則爲真。參見下面對內建命令
      <b>set</b> 的 <b>-o</b>
      選項的描述中的選項列表。</dd>
  <dt><b>-z <i>string</i></b></dt>
  <dd>如果 <i>string</i> 的長度爲 0
      則爲真。</dd>
  <dt><b>-n <i>string</i></b></dt>
  <dd></dd>
  <dt><i>string</i></dt>
  <dd>如果 <i>string</i> 的長度非 0
      則爲真。</dd>
  <dt><i>string1</i> <b>==</b> <i>string2</i></dt>
  <dd>如果字符串相等則爲真。<b>=</b>
      可以用於使用 <b>==</b>
      的場合來兼容 POSIX
      規範。</dd>
  <dt><i>string1</i> <b>!=</b> <i>string2</i></dt>
  <dd>如果字符串不相等則爲真。</dd>
  <dt><i>string1</i> <b>&lt;</b> <i>string2</i></dt>
  <dd>如果 <i>string1</i>
      在當前語言環境的字典順序中排在
      <i>string2</i> 之前則爲真。</dd>
  <dt><i>string1</i> <b>&gt;</b> <i>string2</i></dt>
  <dd>如果 <i>string1</i>
      在當前語言環境的字典順序中排在
      <i>string2</i> 之後則爲真。</dd>
  <dt><i><i>arg1</i> <b>OP</b> <i>arg2</i></i></dt>
  <dd><small><b>OP</b></small> 是 <b>-eq</b>, <b>-ne</b>, <b>-lt</b>,
      <b>-le</b>, <b>-gt</b>, 或 <b>-ge</b>
      之一。這些算術二進制操作返回真，如果
      <i>arg1</i> 與 <i>arg2</i> 分別是
      相等，不等，小於，小於或等於，大於，大於或等於關係。
      <i>Arg1</i> 和 <i>arg2</i>
      可以是正/負整數。</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="簡單命令擴展(&#34;SIMPLE_COMMAND_EXPANSION&#34;)">簡單命令擴展(&#34;SIMPLE COMMAND EXPANSION&#34;)<a class="anchor" href="#%E7%B0%A1%E5%96%AE%E5%91%BD%E4%BB%A4%E6%93%B4%E5%B1%95(%22SIMPLE_COMMAND_EXPANSION%22)">¶</a></h1>
當執行一個簡單命令時，shell
  進行下列擴展，賦值和重定向，從左到右。
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>解釋器標記爲與變量賦值
      (在命令名之前的)
      和重定向有關的詞被保存等待隨後處理。</dd>
  <dt>2.</dt>
  <dd>並非變量賦值或重定向的詞被擴展。如果擴展後仍然有詞保留下來，第一個詞被
      作爲命令名，其餘詞是參數。</dd>
  <dt>3.</dt>
  <dd>重定向按照上面
      <b>REDIRECTION</b>
      中講到的規則進行。</dd>
  <dt>4.</dt>
  <dd>每個變量賦值中 <b>=</b>
      之後的文本在賦予變量之前要經過波浪線擴展，
      參數擴展，命令替換，算術擴展和引用刪除。</dd>
</dl>
<p class="Pp">如果沒有得到命令名，變量賦值影響當前
    shell
    環境。否則，變量被加入
    被執行的命令的環境中，不影響當前
    shell
    環境。如果任何賦值動作試圖
    爲只讀變量賦值，將導致出錯，命令以非零狀態值退出。</p>
<p class="Pp">如果沒有得到命令名，重定向仍會進行，但是不影響當前
    shell 環境。
    重定向出錯將使命令以非零狀態值退出。</p>
<p class="Pp">如果擴展後有命令名保留下來，那麼執行過程如下所示。否則，命令退出。
    如果在任何擴展中包含命令替換，那麼整個命令的退出狀態是最後一個命令
    替換的退出狀態。如果沒有進行命令替換，命令以狀態零退出。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="命令執行(COMMAND_EXECUTION)">命令執行(COMMAND EXECUTION)<a class="anchor" href="#%E5%91%BD%E4%BB%A4%E5%9F%B7%E8%A1%8C(COMMAND_EXECUTION)">¶</a></h1>
命令被拆分爲詞之後，如果結果是一個簡單命令和可選的參數列表，將執行
  下面的操作。
<p class="Pp">如果命令名中沒有斜槓，shell
    試圖定位命令位置。如果存在同名的
    shell
    函數，函數將被執行，像上面
    <b>FUNCTIONS</b>
    中講到的一樣。如果名稱不是一個函數，shell
    從
    內建命令中搜索它。如果找到
    對應命令，它將被執行。</p>
<p class="Pp">如果名稱既不是 shell
    函數也不是一個內建命令，並且沒有包含斜槓，
    <b>bash</b> 搜索 <small><b>PATH</b></small>
    的每個成員，查找含有此文件名
    (可執行文件) 的目錄。
    <b>Bash</b>
    使用散列表來儲存可執行文件的全路徑
    (參見下面的 <small><b>shell
    內建命令(SHELL BUILTIN COMMANDS)</b></small>
    中的 <b>hash。</b>
    只有在散列表中沒有找到此命令，纔對
    <small><b>PATH</b></small>
    進行完整的搜索。如果搜索不成功，shell
    輸出錯誤消息，返回退出狀態
    127。</p>
<p class="Pp">如果搜索成功，或者命令中包含一個或多個斜槓，shell
    在單獨的執行環境中
    執行這個程序。參數 0
    被設置爲所給名稱；命令的其他參數被設置爲所給的參數，
    如果有的話。</p>
<p class="Pp">如果執行失敗，因爲文件不是可執行格式，並且此文件不是目錄，就假定它是
    一個 <i>shell script</i>
    (腳本)，一個包含 shell
    命令的文件。此時將孵化
    (spawn) 出一個子 shell
    來執行它。子 shell
    重新初始化自身，效果就好像是
    執行了一個新的 shell
    來處理腳本一樣，但是父
    shell
    保存的命令位置仍然被
    保留 (參見下面的 <small><b>shell
    內建命令(SHELL BUILTIN COMMANDS)</b></small>
    中的 <b>hash)。</b></p>
<p class="Pp">如果程序是以 <b>#!</b>
    開頭的文件，那麼第一行的其餘部分指定了這個程序的解釋器。
    shell
    執行指定的解釋器，如果操作系統不會自行處理這種可執行文件格式的話。
    解釋器的參數由下面三部分組成：程序第一行中解釋器名稱之後的可選的一個參數，
    程序的名稱，命令行參數，如果有的話。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="命令執行環境(COMMAND_EXECUTION_ENVIRONMENT)">命令執行環境(COMMAND EXECUTION ENVIRONMENT)<a class="anchor" href="#%E5%91%BD%E4%BB%A4%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83(COMMAND_EXECUTION_ENVIRONMENT)">¶</a></h1>
shell 有 <i>execution environment</i> (執行環境)
  的概念，由下列內容組成：
<p class="Pp"></p>
<ul class="Bl-bullet">
  <li>shell
      啓動時繼承的打開的文件，例如在內建命令
      <b>exec</b> 中使用重定向
      修改的結果</li>
  <li>當前工作目錄，使用
      <b>cd</b>，<b>pushd</b> 或者 <b>popd</b>
      設置，或是由 shell
      在啓動時繼承得到</li>
  <li>文件創建模式掩碼，使用
      <b>umask</b> 設置或是從 shell
      的父進程中繼承得到</li>
  <li>當前陷阱，用 <b>trap</b>
      設置</li>
  <li>shell
      參數，使用變量賦值或者
      <b>set</b>
      設置，或者是從父進程的環境中繼承得到</li>
  <li>shell
      函數，在執行中定義或者是從父進程的環境中繼承得到</li>
  <li>設爲允許的選項，在執行時設置
      (要麼是默認允許的，要麼是命令行給出的)
      或者是 用 <b>set</b> 設置</li>
  <li>用 <b>shopt</b>
      設爲允許的選項</li>
  <li>用 <b>alias</b> 定義的 shell 別名</li>
  <li>各種進程號，包含後臺作業的進程號，<b>$$</b>
      的值，以及 <b>$PPID</b>
    的值</li>
</ul>
<p class="Pp">當並非 shell
    函數或內置命令的簡單命令執行時，它在一個由下述內容組成的
    單獨的執行環境中啓動。除非另外說明，值都是從
    shell 中繼承的。</p>
<p class="Pp"></p>
<ul class="Bl-bullet">
  <li>shell
      打開的文件，加上對命令使用重定向修改和添加的文件</li>
  <li>當前工作目錄</li>
  <li>文件創建模式掩碼</li>
  <li>標記爲導出 (export) 的 shell
      變量，以及傳遞到環境中爲這個命令導出的變量</li>
  <li>shell
      捕捉的陷阱被重置爲從
      shell
      的父進程中繼承的值，shell
      忽略的陷阱
    也被忽略</li>
</ul>
<p class="Pp">在單獨的環境中啓動的命令不能影響
    shell 的執行環境。</p>
<p class="Pp">命令替換和異步命令都在子
    shell 環境中執行。子 shell
    環境是原有 shell
    環境的賦值，但 shell
    捕捉的陷阱被重置爲
    shell
    啓動時從父進程中繼承的值。
    作爲管道一部分來執行的內建命令也在一個子
    shell 環境中執行。對子 shell
    環境所作修改不能影響到原有
    shell 的執行環境。</p>
<p class="Pp">如果命令後面是
    <b>&amp;</b>
    並且沒有啓用作業控制，命令的默認標準輸入將是空文件
    <i>/dev/null</i>。否則，被執行的命令從調用它的
    shell
    中繼承被重定向修改的
    文件描述符。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="環境(ENVIRONMENT)">環境(ENVIRONMENT)<a class="anchor" href="#%E7%92%B0%E5%A2%83(ENVIRONMENT)">¶</a></h1>
當一個程序執行時，它被賦予一個字符串數組，成爲環境
  <i>environment</i>。 它是一個
  名稱-值對 (<i>name</i>-<i>value</i>)
  的列表，形式是 <i>name=value</i>.
<p class="Pp">shell
    提供了多種操作環境的方法。啓動時，shell
    掃描自身的環境，爲每個找到
    的名字創建一個參數，自動地將它標記爲
    <i>export</i>
    (向子進程導出的)。被執行的命令繼承了這個環境。
    <b>export</b> 和 <b>declare -x</b>
    命令允許參數和函數被加入到環境中或從環境中刪除。如果環境中參數的值
    被修改，新值成爲環境的一部分，替換了舊值。所有被執行的命令繼承的環境
    包含 shell 的初始環境
    (可能值被修改過)，減去被
    <b>unset</b>
    命令刪除的，加上通過
    <b>export</b> 和 <b>declare -x</b>
    命令添加的部分。</p>
<p class="Pp">可以在任何 <i>simple command</i>
    或函數的環境中設定暫時有效的參數，只要將參數賦值放在命令前面就可以了，
    參見上面 <b>PARAMETERS</b>
    的描述。這些賦值語句只在這個命令的環境中有效。</p>
<p class="Pp">如果設置了內建命令
    <b>set</b> 的 <b>-k</b> 選項，
    <i>所有的</i>
    變量賦值都將放到命令的環境中，不僅是在命令名前面的那些。</p>
<p class="Pp">當 <b>bash</b>
    執行一個外部命令時，變量
    <b>_</b>
    被設置爲命令的文件全名，然後被傳遞到命令的環境之中。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="退出狀態(&#34;EXIT_STATUS&#34;)">退出狀態(&#34;EXIT STATUS&#34;)<a class="anchor" href="#%E9%80%80%E5%87%BA%E7%8B%80%E6%85%8B(%22EXIT_STATUS%22)">¶</a></h1>
從 shell
  的角度看，一個命令退出狀態是
  0 意味着成功退出。
  退出狀態是 0
  表明成功。非零狀態值表明失敗。當命令收到
  fatal signal <i>N</i> 退出時，bash 使用
  128+<i>N</i>
  作爲它的退出狀態。
<p class="Pp">如果沒有找到命令，爲執行它而創建的子進程返回
    127。如果找到了命令但是
    文件不可執行，返回狀態是
    126。</p>
<p class="Pp">如果命令由於擴展或重定向錯誤而失敗，退出狀態大於零。</p>
<p class="Pp">shell
    內建命令如果成功返回
    0(<i>true</i>)，執行時出錯則返回非零
    (<i>false</i>)。
    所有內建命令返回 2
    來指示不正確的用法。</p>
<p class="Pp"><b>Bash</b>
    自身返回最後執行的命令的退出狀態，除非發生了語法錯誤，
    這時它返回非零值。參見下面的內建命令
    <b>exit</b>。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="信號(SIGNALS)">信號(SIGNALS)<a class="anchor" href="#%E4%BF%A1%E8%99%9F(SIGNALS)">¶</a></h1>
如果 <b>bash</b>
  是交互的，沒有設定任何陷阱，它忽略
  <small><b>SIGTERM</b></small> (這樣 <b>kill 0</b>
  不會殺掉交互的 shell)。
  <small><b>SIGINT</b></small> 被捕獲並處理
  (從而使內建命令 <b>wait</b>
  可以中斷)。在所有情況下，
  <b>bash</b> 忽略 <b>SIGQUIT</b>。
  如果正在使用作業控制，
  <b>bash</b> 忽略 <b>SIGTTIN</b>, <b>SIGTTOU</b>, 和
  <b>SIGTSTP</b>.
<p class="Pp"><b>bash</b>
    開始的並行作業的信號處理句柄都設置爲
    shell 從父進程中繼承
    的值。如果不是正在使用作業控制，異步命令還忽略
    <small><b>SIGINT</b></small> 和 <small><b>SIGQUIT 。</b></small>
    作爲命令替換結果運行的命令忽略鍵盤產生的作業控制信號
    <b>SIGTTIN</b>, <b>SIGTTOU</b>, 和 <b>SIGTSTP</b>.</p>
<p class="Pp">如果收到信號
    <b>SIGHUP，</b> shell
    默認退出。在退出前，交互的
    shell
    向所有作業，運行的或停止的，發送
    <small><b>SIGHUP</b></small> 信號。shell
    向停止的作業發出
    <small><b>SIGCONT</b></small>
    信號來保證它們會收到
    <b>SIGHUP</b>. 要阻止 shell
    向特定的作業發送信號，應當使用內建命令
    <b>disown</b>
    將作業從作業表中刪除
    (參見下面的 <small><b>shell
    內建命令(SHELL BUILTIN COMMANDS)</b></small>
    章節) 或者使用 <b>disown -h</b>
    來標記爲不接受
    <small><b>SIGHUP。</b></small></p>
<p class="Pp">如果使用 <b>shopt</b>
    設置了 shell 選項 <b>huponexit，</b>
    在交互的登錄 shell
    退出時 <b>bash</b>
    向所有作業發出
    <small><b>SIGHUP</b></small> 信號。</p>
<p class="Pp">當 <b>bash</b>
    等待命令執行結束時，如果收到已設置了陷阱的信號，陷阱
    (trap)
    將不會執行，直到命令結束。
    當 <b>bash</b> 通過內建命令
    <b>wait</b>
    等待異步命令時，如果收到已設置
    了陷阱的信號，將使得內建命令
    <b>wait</b> 立即以大於 128
    的狀態值返回。
    接着，陷阱將立即被執行。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="作業控制(&#34;JOB_CONTROL&#34;)">作業控制(&#34;JOB CONTROL&#34;)<a class="anchor" href="#%E4%BD%9C%E6%A5%AD%E6%8E%A7%E5%88%B6(%22JOB_CONTROL%22)">¶</a></h1>
<i>Job control</i> (作業控制)
  指的是可以選擇停止
  (<i>suspend</i>，掛起)
  進程執行，並且
  可以在之後繼續
  (<i>resume</i>，恢復)
  執行的能力。用戶一般在交互的人機界面
  中使用這種功能。界面是由系統的終端驅動和
  <b>bash</b> 共同提供的。
<p class="Pp">shell
    將每個管道分配給一個
    <i>作業(job)。</i>
    它保存一個當前運行的作業表，可以用
    <b>jobs</b> 命令來列出。當
    <b>bash</b>
    啓動一個異步的作業時
    <i>(background，後臺執行)，</i>
    它輸出這樣的一行：</p>
<div class="Bd-indent">
<p class="Pp">[1] 25647</p>
</div>
<p class="Pp">表明這個作業的作業號是
    1，與作業相關連的管道中最後一個進程的
    進程ID是
    15647。管道中所有進程都是同一個作業的成員。
    <b>Bash</b> 使用 <i>作業(job)</i>
    概念作爲作業控制的基礎。</p>
<p class="Pp">爲簡化作業控制的用戶界面的實現，操作系統負責管理“當前終端的進程組”
    (<i>current terminal process group ID</i>)
    的概念。這個進程組的成員
    (進程組 ID
    是當前終端進程組 ID
    的進程)
    可以收到鍵盤產生的信號，例如
    <b>SIGINT</b>. 這些進程被稱爲
    <i>foreground</i>(前臺的)。 <i>Background
    (後臺的)</i>
    進程是那些進程組 ID
    與終端不同的進程；這些進程不會收到鍵盤產生的信號。
    只有前臺進程可以從終端讀或向終端寫。後臺進程試圖讀/寫終端時，將收到終端驅動程序發送的
    <small><b>SIGTTIN (SIGTTOU)</b></small>
    信號。這個信號如果沒有加以捕捉，將掛起這個進程。</p>
<p class="Pp">如果 <b>bash</b>
    運行其上的操作系統支持作業控制，
    <b>bash</b>
    會包含使用它的設施。在一個進程正在運行的時候鍵入
    <i>suspend 掛起</i> 字符 (通常是
    <b>^Z</b>, Control-Z)
    將使這個進程暫停，將控制權還給
    <b>bash</b>. 輸入 <i>delayed suspend ,
    延時掛起</i> 字符
    (通常是 <b>^Y</b>, Control-Y)
    將使這個進程在試圖從終端讀取輸入時暫停，將控制權還給
    <b>bash</b>.
    用戶接下來可以控制此作業的狀態，使用
    <b>bg</b>
    命令使它在後臺繼續運行，
    <b>fg</b>
    命令使它在前臺繼續運行，或
    <b>kill</b>
    命令將它殺死。<b>^Z</b>
    會立即起作用，並且還有使等待中的
    (pending)
    輸出和輸入被忽略的附加副作用。</p>
<p class="Pp">有很多方法來指代
    shell 中的作業。字符 <b>%</b>
    可以引入作業名。編號爲
    <i>n</i> 的作業可以用 <b>%n</b>
    的形式來指代。作業也可以用啓動它的名稱的前綴，或者命令行中的子字符串來指代。例如，
    <b>%ce</b> 指代一個暫停的
    <b>ce</b>
    作業。如果前綴匹配多於一個作業，
    <b>bash</b>
    報錯。另一方面，使用
    <b>%?ce</b>,
    可以指代任何命令行中包含字符串
    <b>ce</b>
    的作業。如果子字符串匹配多於一個作業，
    <b>bash</b> 報錯。符號 <b>%%</b> 和
    <b>%+</b> 指代 shell 意義上的 <i>current
    job</i>，當前作業，
    也就是前臺被暫停的最後一個作業，或者是在後臺啓動的作業。
    <i>previous job ，前一作業</i>
    可以使用 <b>%-</b>
    來指代。在有關作業的輸出信息中
    (例如，命令 <b>jobs</b>
    的輸出)，當前作業總是被標記爲
    <b>+</b>, 前一作業標記爲
  <b>-</b>.</p>
<p class="Pp">簡單地給出作業名，可以用來把它放到前臺：
    <b>%1</b> 是 <b>``fg %1&#39;&#39;</b>
    的同義詞，將作業 1
    從後臺放到前臺。類似的，
    <b>``%1 &amp;&#39;&#39;</b> 在後臺恢復作業
    1，與 <b>``bg %1&#39;&#39;</b> 等價。</p>
<p class="Pp">當某個作業改變狀態時，shell
    立即可以得知。通常，
    <b>bash</b>
    等待直到要輸出一個提示符時，纔會報告作業的狀態變化，從而不會打斷其他輸出。
    如果啓用了內建命令
    <b>set</b> 的 <b>-b</b> 選項， <b>bash</b>
    將立即報告這些變化。對
    <small><b>SIGCHLD</b></small>
    信號的陷阱將在每個子進程退出時執行。</p>
<p class="Pp">如果在作業暫停時試圖退出
    <b>bash，</b> shell
    打印一條警告消息。命令
    <b>jobs</b>
    可能被用來檢查作業的狀態。如果再次試圖退出，中間沒有其他命令，shell
    不會打印
    其他警告，暫停的作業將終止。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="提示符(PROMPTING)">提示符(PROMPTING)<a class="anchor" href="#%E6%8F%90%E7%A4%BA%E7%AC%A6(PROMPTING)">¶</a></h1>
在交互執行時， <b>bash</b>
  在準備好讀入一條命令時顯示主提示符
  <small><b>PS1，</b></small>
  在需要更多的輸入來完成一條命令時顯示
  <small><b>PS2。</b></small> <b>Bash</b>
  允許通過插入一些反斜槓轉義的特殊字符來定製這些提示字符串，這些字符被如下解釋：
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>\a</b></dt>
  <dd>一個 ASCII 響鈴字符 (07)</dd>
  <dt><b>\d</b></dt>
  <dd>日期，格式是 &#34;星期
      月份 日&#34; (例如，&#34;Tue May
      26&#34;)</dd>
  <dt><b>\D{<i>format</i>}</b></dt>
  <dd><i>format</i> 被傳遞給
      <a href="../../buster/manpages-dev/strftime.3.en.html">strftime(3)</a>，結果被插入到提示字符串中；
      空的 <i>format</i>
      將使用語言環境特定的時間格式。花括號是必需的</dd>
  <dt><b>\e</b></dt>
  <dd>一個 ASCII 轉義字符 (033)</dd>
  <dt><b>\h</b></dt>
  <dd>主機名，第一個 `.&#39;
      之前的部分</dd>
  <dt><b>\H</b></dt>
  <dd>主機名</dd>
  <dt><b>\j</b></dt>
  <dd>shell
      當前管理的作業數量</dd>
  <dt><b>\l</b></dt>
  <dd>shell
      的終端設備名的基本部分</dd>
  <dt><b>\n</b></dt>
  <dd>新行符</dd>
  <dt><b>\r</b></dt>
  <dd>回車</dd>
  <dt><b>\s</b></dt>
  <dd>shell 的名稱， <b>$0</b>
      的基本部分
      (最後一個斜槓後面的部分)</dd>
  <dt><b>\t</b></dt>
  <dd>當前時間，採用
      24小時制的 HH:MM:SS 格式</dd>
  <dt><b>\T</b></dt>
  <dd>當前時間，採用
      12小時制的 HH:MM:SS 格式</dd>
  <dt><b>\@</b></dt>
  <dd>當前時間，採用
      12小時制上午/下午 (am/pm)
      格式</dd>
  <dt><b>\A</b></dt>
  <dd>當前時間，採用
      24小時制上午/下午格式</dd>
  <dt><b>\u</b></dt>
  <dd>當前用戶的用戶名 the
      username of the current user</dd>
  <dt><b>\v</b></dt>
  <dd><b>bash</b> 的版本 (例如，2.00)</dd>
  <dt><b>\V</b></dt>
  <dd><b>bash</b>
      的發行編號，版本號加補丁級別
      (例如，2.00.0)</dd>
  <dt><b>\w</b></dt>
  <dd>當前工作目錄</dd>
  <dt><b>\W</b></dt>
  <dd>當前工作目錄的基本部分</dd>
  <dt><b>\!</b></dt>
  <dd>此命令的歷史編號</dd>
  <dt><b>\#</b></dt>
  <dd>此命令的命令編號</dd>
  <dt><b>\$</b></dt>
  <dd>如果有效 UID 是 0，就是
      <b>#</b>, 其他情況下是 <b>$</b></dd>
  <dt><b>\<i>nnn</i></b></dt>
  <dd>對應八進制數 <i>nnn</i>
      的字符</dd>
  <dt><b>\\</b></dt>
  <dd>一個反斜槓</dd>
  <dt><b>\[</b></dt>
  <dd>一個不可打印字符序列的開始，可以用於在提示符中嵌入終端控制序列</dd>
  <dt><b>\]</b></dt>
  <dd>一個不可打印字符序列的結束</dd>
</dl>
</div>
<p class="Pp">命令編號和歷史編號通常是不同的：歷史編號是命令在歷史列表中的位置，可能
    包含從歷史文件中恢復的命令
    (參見下面的 <small><b>HISTORY
    歷史</b></small>
    章節)，而命令編號是當前
    shell
    會話中執行的命令序列中，命令的位置。
    字符串被解碼之後，它將進行擴展，要經過
    parameter expansion, command substitution, arithmetic expansion 和
    quote removal, 最後要經過 shell
    選項 <b>promptvars</b> 處理
    (參見下面的 <small><b>shell
    內建命令(SHELL BUILTIN COMMANDS)</b></small>
    章節中，對命令 <b>shopt</b>
    的描述)。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="readline庫(READLINE)">readline庫(READLINE)<a class="anchor" href="#readline%E5%BA%AB(READLINE)">¶</a></h1>
這是在交互 shell
  中處理讀取輸入的庫，除非在
  shell 啓動時給出了 <b>--noediting</b>
  選項。默認情況下，行編輯命令類似於
  emacs
  中的那些。也可以使用
  vi 樣式的行編輯界面。
  要在 shell
  運行之後關閉行編輯，使用內置命令
  <b>set</b> 的 <b>+o emacs</b> 或 <b>+o vi</b> 選項
  (參見下面的 <small><b>shell
  內建命令(SHELL BUILTIN COMMANDS)</b></small>
  章節)。
<section class="Ss">
<h2 class="Ss" id="Readline_Notation">Readline Notation<a class="anchor" href="#Readline_Notation">¶</a></h2>
在這個小節中，將使用
  emacs
  樣式的記法來表述按鍵。Ctrl
  鍵記爲 C-<i>key</i>， 例如，C-n
  意思是 Ctrl-N。類似的，
  <i>meta</i> 鍵記爲 M-<i>key</i>，因此 M-x
  意味着 Meta-x。(在沒有 <i>meta</i>
  鍵的鍵盤上，M-<i>x</i>
  意思是
  ESC-<i>x</i>，也就是說，按下
  Esc 鍵，然後按 <i>x</i>
  鍵。這使得 Esc 成爲 <i>meta
  prefix</i>。M-C-<i>x</i>
  的組合意思是 Esc-Ctrl-<i>x</i>，
  也就是按 Esc
  鍵，然後按住 Ctrl
  鍵，同時按 <i>x</i> 鍵。)
<p class="Pp">readline
    命令可以有數字的
    <i>參數</i>(arguments)，
    一般作爲重複的計數。有些時候，它是重要參數的標記。給向前方進行的命令
    (例如，<b>kill-line</b>)
    傳遞負數參數，將使得命令向反方向進行。
    下面的命令如果接受參數時的行爲與此不同，將另行說明。</p>
<p class="Pp">當命令被描述爲剪切
    (<i>killing</i>)
    文本時，被刪除的文本被保存，等待將來使用
    (粘貼，<i>yanking</i>)。被剪切的文本保存在
    <i>kill ring</i>
    中。連續的剪切使得
    文本被依次加入到一個單元中，可以一次被粘貼。不剪切文本的命令將
    kill ring 中的文本分離。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Readline_Initialization_初始化">Readline Initialization 初始化<a class="anchor" href="#Readline_Initialization_%E5%88%9D%E5%A7%8B%E5%8C%96">¶</a></h2>
readline
  可以通過將命令放入初始化文件
  (<i>inputrc</i> 文件) 來定製。
  文件名從變量 <small><b>INPUTRC</b></small>
  的值中獲取。如果沒有設置這個變量，默認是
  <i>~/.inputrc</i>. 當使用 readline
  庫的程序啓動時，將讀取初始化文件，按鍵關聯和變量將被設置。
  readline
  初始化文件中只允許有很少的基本構造。
  空行被忽略。以 <b>#</b>
  開始的行是註釋。以
  <b>$</b>
  開始的行指示了有條件的構造。
  其他行表示按鍵關聯和變量設置。
<p class="Pp">默認的按鍵關聯可以使用
    <i>inputrc</i>
    文件改變。其他使用這個庫的程序可以添加它們自己的命令和關聯。</p>
<p class="Pp">例如，將</p>
<div class="Bd-indent">
<p class="Pp">M-Control-u: universal-argument</p>
</div>
或
<div class="Bd-indent">C-Meta-u: universal-argument</div>
放入 <i>inputrc</i> 將使得 M-C-u 執行
  readline 命令 <i>universal-argument</i>.
<p class="Pp">可以識別下列字符的符號名稱：
    <i>RUBOUT</i>, <i>DEL</i>, <i>ESC</i>, <i>LFD</i>, <i>NEWLINE</i>,
    <i>RET</i>, <i>RETURN</i>, <i>SPC</i>, <i>SPACE</i>, 和
  <i>TAB</i>.</p>
<p class="Pp">在命令名之外，readline
    允許將按鍵與一個字符串關聯，當按下這個鍵時，將插入這個字符串
    (一個宏，<i>macro</i>)。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Readline_Key_Bindings">Readline Key Bindings<a class="anchor" href="#Readline_Key_Bindings">¶</a></h2>
<i>inputrc</i>
  文件中的控制按鍵關聯的語法非常簡單。需要的內容是命令名或宏，以及它應當關聯到的按鍵序列。
  名稱可以以兩種方式指定：一個按鍵的符號名稱，可能帶有
  <i>Meta-</i> 或 <i>Control-</i>
  前綴，或者是一個按鍵序列。
<p class="Pp">當使用 <b>keyname</b>:<i>function-name</i>
    或 <i>macro</i> 形式時， <i>keyname</i>
    是按鍵以英文拼寫的名稱。例如：</p>
<p class="Pp"></p>
<div class="Bd-indent">Control-u: universal-argument
<br/>
Meta-Rubout: backward-kill-word
<br/>
Control-o: &#34;&gt; output&#34;</div>
<p class="Pp">在上述例子中，
    <i>C-u</i> 被關聯到函數
    <b>universal-argument</b>, <i>M-DEL</i>
    被關聯到函數 <b>backward-kill-word</b>,
    而 <i>C-o</i>
    被關聯爲運行右邊給出的宏
    (意思是，將向行中插入
    ``&gt; output&#39;&#39; )。</p>
<p class="Pp">在第二種形式中，<b>&#34;keyseq&#34;</b>:<i>function-name</i>
    或 <i>macro</i>， <b>keyseq</b>
    不同於上面的 <b>keyname，</b>
    表示整個按鍵序列的字符串可以通過將按鍵序列放在雙引號引用中來指定。
    可以使用一些 GNU Emacs
    樣式的按鍵序列，如下例所示，但是不會識別按鍵的符號名稱。</p>
<p class="Pp"></p>
<div class="Bd-indent">&#34;\C-u&#34;: universal-argument
<br/>
&#34;\C-x\C-r&#34;: re-read-init-file
<br/>
&#34;\e[11~&#34;: &#34;Function Key 1&#34;</div>
<p class="Pp">在上述例子中，
    <i>C-u</i>
    被又一次關聯到函數
    <b>universal-argument</b>. <i>C-x C-r</i>
    被關聯到函數 <b>re-read-init-file</b>,
    而 <i>ESC [ 1 1 ~</i>
    被關聯爲插入文本 ``Function
    Key 1&#39;&#39;.</p>
<p class="Pp">GNU Emacs
    樣式的轉義序列的全集爲：</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>\C-</b></dt>
  <dd>Ctrl 前綴</dd>
  <dt><b>\M-</b></dt>
  <dd>Meta 前綴</dd>
  <dt><b>\e</b></dt>
  <dd>一個 Esc 字符</dd>
  <dt><b>\\</b></dt>
  <dd>反斜槓</dd>
  <dt><b>\&#34;</b></dt>
  <dd>字面上的 &#34;</dd>
  <dt><b>\&#39;</b></dt>
  <dd>字面上的 &#39;</dd>
</dl>
</div>
<p class="Pp">除了 GNU Emacs
    樣式的轉義序列，還有一系列反斜槓轉義序列可用：</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>\a</b></dt>
  <dd>響鈴</dd>
  <dt><b>\b</b></dt>
  <dd>回退</dd>
  <dt><b>\d</b></dt>
  <dd>刪除</dd>
  <dt><b>\f</b></dt>
  <dd>進紙</dd>
  <dt><b>\n</b></dt>
  <dd>新行符</dd>
  <dt><b>\r</b></dt>
  <dd>回車</dd>
  <dt><b>\t</b></dt>
  <dd>水平跳格</dd>
  <dt><b>\v</b></dt>
  <dd>豎直跳格</dd>
  <dt><b>\<i>nnn</i></b></dt>
  <dd>一個八比特字符，它的值是八進制值
      <i>nnn</i>
      (一到三個八進制數字)。</dd>
  <dt><b>\x<i>HH</i></b></dt>
  <dd>一個八比特字符，它的值是十六進制值
      <i>HH</i>
      (一到兩個十六進制數字)。</dd>
</dl>
</div>
<p class="Pp">輸入宏的文本時，必須使用單引號或雙引號引用來表明是宏的定義。
    沒有引用的文本被當作函數名。在宏的定義體中，上述反斜槓轉義被擴展。
    反斜槓將引用宏文本中所有其他字符，包括
    &#34; 和 &#39;。</p>
<p class="Pp"><b>Bash</b>
    允許使用內建命令 <b>bind</b>
    來顯示和修改當前 readline
    按鍵關聯。在交互使用中可以用內建命令
    <b>set</b> 的 <b>-o</b>
    選項切換到編輯模式
    (參見下面的 <small><b>shell
    內建命令(SHELL BUILTIN COMMANDS)</b></small>
    章節)。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Readline_Variables">Readline Variables<a class="anchor" href="#Readline_Variables">¶</a></h2>
readline
  包含額外的可用於定製它的行爲的變量。可以在
  <i>inputrc</i>
  文件中設置變量，使用如下形式的語句：
<div class="Bd-indent">
<p class="Pp"><b>set</b> <i>variable-name</i> <i>value</i></p>
</div>
<p class="Pp">除非另外說明，readline
    變量的值總是 <b>On</b> 或
    <b>Off。</b>
    變量和它們的默認值是：</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>bell-style (audible)</b></dt>
  <dd>控制了當 readline
      需要鳴終端響鈴時的動作。如果設置爲
      <b>none</b>， readline
      不會鳴鈴。如果設置爲
      <b>visible</b>，readline
      使用可視的響鈴，如果可用的話。
      如果設置爲 <b>audible</b>，readline
      試着鳴終端響鈴。</dd>
  <dt><b>comment-begin (``#&#39;&#39;)</b></dt>
  <dd>這個字符串在執行 readline
      命令 <b>insert-comment</b>
      時被插入。這個命令在
      emacs 模式下被關聯爲
      <b>M-#，</b> 在 vi 模式下是
      <b>#。</b></dd>
  <dt><b>completion-ignore-case (Off)</b></dt>
  <dd>如果設置爲 <b>On</b>，readline
      進行大小寫不敏感的文件名匹配和補全。</dd>
  <dt><b>completion-query-items (100)</b></dt>
  <dd>這個變量決定着何時向用戶詢問，是否查看由命令
      <b>possible-completions</b>
      產生的可能的補全數量。
      它可以設爲任何大於或等於
      0
      的值。如果可能的補全數量大於或等於這個變量的值，
      用戶將被提示是否願意查看它們；否則將直接在終端上列出它們。</dd>
  <dt><b>convert-meta (On)</b></dt>
  <dd>如果設置爲 <b>On</b>，readline
      將把設置了最高位的字符轉換爲
      ASCII 按鍵序列，方法是
      去掉第八位，前綴一個轉義字符
      (實際上，使用 Esc
      作爲轉義符 <i>meta prefix</i>)。</dd>
  <dt><b>disable-completion (Off)</b></dt>
  <dd>如果設置爲 <b>On</b>，readline
      將禁止詞的補全。補全字符將被插入到行中，就好像它們被
      映射爲 <b>self-insert</b>。</dd>
  <dt><b>editing-mode (emacs)</b></dt>
  <dd>控制 readline
      的按鍵關聯集合與
      <i>emacs</i> 還是 <i>vi</i> 相似。
      <b>editing-mode</b> 可以設置爲 <b>emacs</b>
      或 <b>vi。</b></dd>
  <dt><b>enable-keypad (Off)</b></dt>
  <dd>如果設置爲 <b>On</b> ，readline
      在調用時將試圖啓用輔助鍵盤。
      一些系統需要設置這個來啓用方向鍵。</dd>
  <dt><b>expand-tilde (Off)</b></dt>
  <dd>如果設置爲 <b>On</b>，readline
      試圖進行詞的補全時會進行波浪線擴展。</dd>
  <dt><b>history-preserve-point</b></dt>
  <dd>如果設置爲
      <b>On</b>，歷史代碼試着在
      <b>previous-history</b> 或 <b>next-history</b>
      取回的每個歷史行的相同位置中加點。</dd>
  <dt><b>horizontal-scroll-mode (Off)</b></dt>
  <dd>如果設置爲
      <b>On</b>，將使得 readline
      使用單行來顯示，如果它比屏幕寬度要長，就在
      單一的屏幕行上水平滾動輸入行，而不是自動迴繞到新行。</dd>
  <dt><b>input-meta (Off)</b></dt>
  <dd>如果設置爲 <b>On</b>，readline
      將允許八比特輸入
      (也就是說，它不會將它讀入的字符中最高位刪除)，
      不管它能支持什麼樣的終端要求。名稱
      <b>meta-flag</b>
    與此變量同義。</dd>
  <dt><b>isearch-terminators (``C-[C-J&#39;&#39;)</b></dt>
  <dd>用於終止增量的搜索，不再將字符當作命令執行的字符串。
      如果這個變量沒有賦值，字符串
      <i>Esc</i> 和 <i>C-J</i>
      將終止增量的搜索。</dd>
  <dt><b>keymap (emacs)</b></dt>
  <dd>設置當前 readline
      鍵盤映射。有效的鍵盤映射名稱是
      <i>emacs, emacs-standard, emacs-meta, emacs-ctlx, vi,</i>
      <i>vi-command</i>，還有 <i>vi-insert。</i>
      <i>vi</i> 等價於 <i>vi-command</i>; <i>emacs</i>
      等價於
      <i>emacs-standard</i>。默認值是
      <i>emacs</i>; <b>editing-mode</b>
      的值也會影響默認的鍵盤映射。</dd>
  <dt><b>mark-directories (On)</b></dt>
  <dd>如果設置爲
      <b>On</b>，補全的目錄名會添加一個斜槓。</dd>
  <dt><b>mark-modified-lines (Off)</b></dt>
  <dd>如果設置爲
      <b>On</b>，已被修改的歷史行將顯示爲前綴一個星號
      (<b>*</b>)。</dd>
  <dt><b>mark-symlinked-directories (Off)</b></dt>
  <dd>如果設置爲
      <b>On</b>，補全的名稱如果是到目錄的符號鏈接，則將添加一個斜槓
      (與 <b>mark-directories</b>
      的值同樣處理)。</dd>
  <dt><b>match-hidden-files (On)</b></dt>
  <dd>這個變量，如果設置爲
      <b>On</b>，將使得 readline
      在進行文件名補全時，匹配以
      `.&#39; 開頭的文件
      (隱藏文件)，
      除非用戶在要補全的文件名中給出了前導的
      `.&#39;。</dd>
  <dt><b>output-meta (Off)</b></dt>
  <dd>如果設置爲 <b>On</b>，readline
      將直接顯示設置了第八位的字符，而不是轉化爲一個帶
      meta 前綴的轉義序列。</dd>
  <dt><b>page-completions (On)</b></dt>
  <dd>如果設置爲 <b>On</b>，readline
      將使用內建的類似
      <i>more</i> 的分頁程序，
      來每次顯示一屏可能的補全。</dd>
  <dt><b>print-completions-horizontally (Off)</b></dt>
  <dd>如果設置爲 <b>On</b>，readline
      將匹配的補全按字母表順序排序，然後水平排列顯示出來，
      而不是在屏幕上豎直排列顯示。</dd>
  <dt><b>show-all-if-ambiguous (Off)</b></dt>
  <dd>這將調整補全函數的默認行爲。如果設置爲
      <b>on</b>,
      擁有多於一個可能的補全的詞將立即列出所有匹配，而不是鳴響鈴。</dd>
  <dt><b>visible-stats (Off)</b></dt>
  <dd>如果設置爲
      <b>On</b>，在列出可能的補全時，將在文件名後面添加一個表示文件類型的字符，
      文件類型由 <a href="../../buster/manpages-dev/stat.2.en.html">stat(2)</a>
      報告。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Readline_Conditional_Constructs">Readline Conditional Constructs<a class="anchor" href="#Readline_Conditional_Constructs">¶</a></h2>
readline
  實現了一種功能，本質上與
  C
  預處理器進行條件編譯的功能類似，
  允許根據測試的結果進行鍵盤關聯和變量設置。其中使用了四種解釋器指令。
<dl class="Bl-tag">
  <dt><b>$if</b></dt>
  <dd><b>$if</b>
      結構允許根據編輯模式，正在使用的終端，使用
      readline
      的應用程序來設定按鍵關聯。
      測試的文本包括一行，直到行尾；不必用字符來隔離它。</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>mode</b></dt>
  <dd><b>$if</b> 結構的 <b>mode=</b>
      形式用於測試 readline 處於
      emacs 還是 vi 模式。
      這可以與命令 <b>set keymap</b>
      結合使用，例如，設置
      <i>emacs-standard</i> 和 <i>emacs-ctlx</i>
      鍵盤映射，僅當 readline 以
      emacs 模式啓動。</dd>
  <dt><b>term</b></dt>
  <dd><b>term=</b>
      形式用於包含與終端相關的按鍵關聯，也許是將按鍵序列輸出與終端的功能鍵相關聯。
      等號 <b>=</b>
      右邊的詞被同終端的全名和名稱中第一個
      <b>-</b>
      前面的一部分相比較。
      例如，允許 <i>sun</i>
      同時匹配 <i>sun</i> 和
      <i>sun-cmd。</i></dd>
  <dt><b>application</b></dt>
  <dd><b>application</b>
      結構用於包含應用程序相關的設置。每個使用
      readline 的程序都設置 <i>application
      name</i>，
      初始化文件可以測試它的值。它可用於將一個按鍵序列與對特定的程序有用的功能相關聯。
      例如，下列命令添加了一個按鍵序列，用以引用
      bash
      中當前的詞或前一個詞
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<pre><b>$if</b> Bash
# Quote the current or previous word
&#34;\C-xq&#34;: &#34;\eb\&#34;\ef\&#34;&#34;
<b>$endif</b>
</pre>
</div>
</div>
<dl class="Bl-tag">
  <dt><b>$endif</b></dt>
  <dd>上例中的這個命令，結束了一個
      <b>$if</b> 命令。</dd>
  <dt><b>$else</b></dt>
  <dd>如果測試失敗，<b>$if</b>
      指令中這個分支的命令將被執行。</dd>
  <dt><b>$include</b></dt>
  <dd>這個指令使用單個文件名作爲參數，從文件中讀取命令和按鍵關聯。例如，下列指令
      將讀取 <i>/etc/inputrc</i>：
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<pre><b>$include</b>  <i>/etc/inputrc</i>
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Searching">Searching<a class="anchor" href="#Searching">¶</a></h2>
readline
  提供了從命令歷史中搜索包含給定字符串的行的命令
  (參見下面的 <small><b>HISTORY
  歷史</b></small>
  章節)。有兩種搜索模式：
  <i>incremental</i> 和 <i>non-incremental</i>.
<p class="Pp">增量的搜索在用戶結束輸入搜索字符串時開始。在搜索字符串的每個字符被輸入的同時，
    readline
    顯示與已輸入的字符串匹配的下一個歷史條目。
    增量的搜索只要求輸入能找到期望的歷史條目所需的那麼多字符。
    <b>isearch-terminators</b>
    變量中的字符用來終止一次增量的搜索。如果
    這個變量沒有被賦值，Esc
    和 Ctrl-J
    字符串將結束一次增量的搜索。
    Ctrl-G
    將取消一次增量的搜索，恢復初始的行。當搜索終止時，包含搜索字符串
    的歷史條目成爲當前行。</p>
<p class="Pp">要從歷史列表中找到其他匹配的條目，適當地鍵入
    Ctrl-S 或 Ctrl-R。
    這樣將在歷史中向前/向後搜索下一個匹配已輸入的搜索字符串的條目。
    其他關聯到某個 readline
    命令的按鍵序列將終止搜索並執行關聯的命令。
    例如，<i>newline</i>
    將終止搜索，接受當前行，從而執行歷史列表中的命令。</p>
<p class="Pp">readline
    可以記住上次增量搜索的字符串。如果鍵入兩次
    Ctrl-R，中間沒有
    輸入任何字符來定義一個新的搜索字符串，那麼將使用已記住的搜索字符串。</p>
<p class="Pp">非增量的搜索將整個搜索字符串讀入，然後纔開始搜索匹配的歷史條目。
    搜索字符串可以由用戶輸入，或者是當前行的內容的一部分。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Readline_Command_Names">Readline Command Names<a class="anchor" href="#Readline_Command_Names">¶</a></h2>
下面列出的是命令的名稱以及默認情況下它們關聯的按鍵序列。
  命令名稱如果沒有對應的按鍵序列，那麼默認是沒有關聯的。在下列描述中，
  點 (<i>point</i>)
  指當前光標位置，標記
  (<i>mark</i>) 指命令 <b>set-mark</b>
  保存的光標位置。point 和
  mark
  之間的文本被稱爲範圍
  (<i>region</i>)。
</section>
<section class="Ss">
<h2 class="Ss" id="Commands_for_Moving_移動">Commands for Moving 移動<a class="anchor" href="#Commands_for_Moving_%E7%A7%BB%E5%8B%95">¶</a></h2>
<dl class="Bl-tag">
  <dt><b>beginning-of-line (C-a)</b></dt>
  <dd>移動到當前行的開始。</dd>
  <dt><b>end-of-line (C-e)</b></dt>
  <dd>移動到當前行的結尾。</dd>
  <dt><b>forward-char (C-f)</b></dt>
  <dd>向前移動一字。</dd>
  <dt><b>backward-char (C-b)</b></dt>
  <dd>向後移動一字。</dd>
  <dt><b>forward-word (M-f)</b></dt>
  <dd>向前移動到下一詞尾。詞由字符
      (字母和數字) 組成。</dd>
  <dt><b>backward-word (M-b)</b></dt>
  <dd>向後移動到當前或上一詞首。</dd>
  <dt><b>clear-screen (C-l)</b></dt>
  <dd>清除屏幕，保留當前行在屏幕頂端。有參數時，刷新當前行，不清屏。</dd>
  <dt><b>redraw-current-line</b></dt>
  <dd>刷新當前行。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Commands_for_Manipulating_the_History_操縱歷史行">Commands for Manipulating the History 操縱歷史行<a class="anchor" href="#Commands_for_Manipulating_the_History_%E6%93%8D%E7%B8%B1%E6%AD%B7%E5%8F%B2%E8%A1%8C">¶</a></h2>
<dl class="Bl-tag">
  <dt><b>accept-line (Newline, Return)</b></dt>
  <dd>接受這一行，不管光標在什麼位置。如果行非空，將根據變量
      <small><b>HISTCONTROL</b></small>
      的狀態加入到歷史列表中。如果行是修改過的歷史行，將恢復該歷史行到初始狀態。</dd>
  <dt><b>previous-history (C-p)</b></dt>
  <dd>從歷史列表中取得前一個命令，從列表中向後移動。</dd>
  <dt><b>next-history (C-n)</b></dt>
  <dd>從歷史列表中取得後一個命令，從列表中向前移動。</dd>
  <dt><b>beginning-of-history (M-&lt;)</b></dt>
  <dd>移動到歷史中的第一行。</dd>
  <dt><b>end-of-history (M-&gt;)</b></dt>
  <dd>移動到輸入歷史行的末尾，也就是當前輸入的行的末尾。</dd>
  <dt><b>reverse-search-history (C-r)</b></dt>
  <dd>從當前行開始向後搜索，按照需要在歷史中向“上”移動。這是一個增量的搜索。</dd>
  <dt><b>forward-search-history (C-s)</b></dt>
  <dd>從當前行開始向前搜索，按照需要在歷史中向“下”移動。這是一個增量的搜索。</dd>
  <dt><b>non-incremental-reverse-search-history (M-p)</b></dt>
  <dd>從當前行開始向後，使用非增量搜索來查找用戶給出的字符串。</dd>
  <dt><b>non-incremental-forward-search-history (M-n)</b></dt>
  <dd>從當前行開始向前，使用非增量搜索來查找用戶給出的字符串。</dd>
  <dt><b>history-search-forward</b></dt>
  <dd>從當前行開始向前搜索歷史，查找從當前行首到
      point 之間的字符串。
      這是一個非增量的搜索。</dd>
  <dt><b>history-search-backward</b></dt>
  <dd>從當前行開始向後搜索歷史，查找從當前行首到
      point 之間的字符串。
      這是一個非增量的搜索。</dd>
  <dt><b>yank-nth-arg (M-C-y)</b></dt>
  <dd>將前一個命令的第一個參數
      (通常是上一行的第二個詞)
      插入到 point
      位置。有參數 <i>n</i>
      時，將前一個命令的第
      <i>n</i> 個詞
      (前一個命令中的詞從
      0 開始計數) 插入到 point
      位置。負數參數則插入前一個命令倒數第
      <i>n</i> 個詞。</dd>
  <dt><b>yank-last-arg (M-., M-_)</b></dt>
  <dd>插入前一個命令的最後一個參數
      (上一歷史條目的最後一個詞)。有參數時，
      行爲類似於
      <b>yank-nth-arg</b>。後繼的 <b>yank-last-arg</b>
      調用將
      從歷史列表中向後移動，依次將每行的最後一個參數插入。</dd>
  <dt><b>shell-expand-line (M-C-e)</b></dt>
  <dd>擴展行，像 shell
      做的那樣。其中包含別名和歷史擴展，還有所有的
      shell 詞的擴展。
      參見下面的 <small><b>HISTORY
      EXPANSION</b></small>
      中關於歷史擴展的描述。</dd>
  <dt><b>history-expand-line (M-^)</b></dt>
  <dd>在當前行進行歷史擴展。參見下面的
      <small><b>HISTORY EXPANSION</b></small>
      中關於歷史擴展的描述。</dd>
  <dt><b>magic-space</b></dt>
  <dd>在當前行進行歷史擴展，並插入一個空格。參見下面的
      <small><b>HISTORY EXPANSION</b></small>
      中關於歷史擴展的描述。</dd>
  <dt><b>alias-expand-line</b></dt>
  <dd>在當前行進行別名擴展，參見上面的
      <small><b>ALIASES</b></small>
      中關於別名擴展的描述。</dd>
  <dt><b>history-and-alias-expand-line</b></dt>
  <dd>在當前行進行歷史和別名擴展。</dd>
  <dt><b>insert-last-argument (M-., M-_)</b></dt>
  <dd>與 <b>yank-last-arg</b> 同義。</dd>
  <dt><b>operate-and-get-next (C-o)</b></dt>
  <dd>接受當前行，加以執行，從歷史中取出相對當前行的下一行進行編輯。
      任何參數都被忽略。</dd>
  <dt><b>edit-and-execute-command (C-xC-e)</b></dt>
  <dd>啓動一個編輯器，編輯當前命令行，將結果作爲
      shell 命令運行。 <b>Bash</b>
      將依次試着運行 <b>$FCEDIT</b>,
      <b>$EDITOR</b>, 和 <i>emacs</i>
      作爲編輯器。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Commands_for_Changing_Text_改變文本">Commands for Changing Text 改變文本<a class="anchor" href="#Commands_for_Changing_Text_%E6%94%B9%E8%AE%8A%E6%96%87%E6%9C%AC">¶</a></h2>
<dl class="Bl-tag">
  <dt><b>delete-char (C-d)</b></dt>
  <dd>刪除 point
      處的字符。如果 point
      在行首，行中沒有字符，最後一次輸入的字符
      沒有被關聯到
      <b>delete-char</b>，將返回 <b>EOF</b>.</dd>
  <dt><b>backward-delete-char (Rubout)</b></dt>
  <dd>刪除光標之後的字符。當給出一個數值的參數時，保存刪除的文本到
      kill ring 中。</dd>
  <dt><b>forward-backward-delete-char</b></dt>
  <dd>刪除光標下的字符，除非光標在行尾，此時刪除光標後的字符。</dd>
  <dt><b>quoted-insert (C-q, C-v)</b></dt>
  <dd>將輸入的下一字符保持原樣添加到行中。例如，可以用它來插入類似
      <b>C-q</b> 的字符。</dd>
  <dt><b>tab-insert (C-v TAB)</b></dt>
  <dd>插入一個跳格符號。</dd>
  <dt><b>self-insert
    (a, b, A, 1, !, ...)</b></dt>
  <dd>插入鍵入的字符。</dd>
  <dt><b>transpose-chars (C-t)</b></dt>
  <dd>將 point
      之前的字符向前移動，越過
      point
      處的字符，同時也改變
      point 的位置。 如果 point
      在行尾，將調換 point
      之前的兩個字符。負數參數沒有作用。</dd>
  <dt><b>transpose-words (M-t)</b></dt>
  <dd>將 point
      之前的詞向前移動，越過
      point
      處的詞，同時也改變
      point 的位置。 如果 point
      在行尾，將調換行中的最後兩個詞。</dd>
  <dt><b>upcase-word (M-u)</b></dt>
  <dd>將當前 (或下一個)
      詞變成全大寫。有負值的參數時，將前一個詞變爲大寫，
      但是不移動 point。</dd>
  <dt><b>downcase-word (M-l)</b></dt>
  <dd>將當前 (或下一個)
      詞變成全小寫。有負值的參數時，將前一個詞變爲小寫，
      但是不移動 point。</dd>
  <dt><b>capitalize-word (M-c)</b></dt>
  <dd>將當前 (或下一個)
      詞變爲首字大寫。有負值的參數時，將前一個詞變爲首字大寫，
      但是不移動 point。</dd>
  <dt><b>overwrite-mode</b></dt>
  <dd>控制插入/改寫模式。給出一個正整數參數時，切換爲改寫模式。給出一個非正數
      參數時，切換爲插入模式。這個命令隻影響
      <b>emacs</b> 模式；<b>vi</b> 模式
      的改寫與此不同。每個對
      <i>readline()</i>
      的調用都以插入模式開始。在改寫模式下，
      關聯到 <b>self-insert</b>
      的字符替換 point
      處的字符，而不是將它推到右邊。
      關聯到 <b>backward-delete-char</b>
      的字符以空格替換 point
      前的字符。
      默認情況下，這個命令沒有關聯。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Killing_and_Yanking_剪切和粘貼">Killing and Yanking 剪切和粘貼<a class="anchor" href="#Killing_and_Yanking_%E5%89%AA%E5%88%87%E5%92%8C%E7%B2%98%E8%B2%BC">¶</a></h2>
<dl class="Bl-tag">
  <dt><b>kill-line (C-k)</b></dt>
  <dd>剪切從 point
      到行尾的文本。</dd>
  <dt><b>backward-kill-line (C-x Rubout)</b></dt>
  <dd>反向剪切到行首。</dd>
  <dt><b>unix-line-discard (C-u)</b></dt>
  <dd>反向剪切到行首。與
      <i>backward-kill-line</i>
      沒有什麼區別。
      剪切的文本被保存於
      kill-ring 中。</dd>
  <dt><b>kill-whole-line</b></dt>
  <dd>剪切當前行中所有字符，不管
      point 在什麼位置。</dd>
  <dt><b>kill-word (M-d)</b></dt>
  <dd>剪切從 point
      到當前詞尾，或者如果
      point
      在詞之間，那麼剪切到下一詞尾。</dd>
  <dt><b>backward-kill-word (M-Rubout)</b></dt>
  <dd>剪切 point
      之後的詞。詞的邊界與
      <b>backward-word</b> 使用的相同。</dd>
  <dt><b>unix-word-rubout (C-w)</b></dt>
  <dd>剪切 point
      之後的詞，使用空白作爲詞的邊界。剪切的文本被保存於
      kill-ring 中。</dd>
  <dt><b>delete-horizontal-space (M-\)</b></dt>
  <dd>刪除 point
      兩邊的所有空格和跳格。</dd>
  <dt><b>kill-region</b></dt>
  <dd>剪切當前 region
    的文本。</dd>
  <dt><b>copy-region-as-kill</b></dt>
  <dd>將 region
      的文本複製到剪切緩衝區中。</dd>
  <dt><b>copy-backward-word</b></dt>
  <dd>將 point
      前面的詞複製到剪切緩衝區中。
      詞的邊界與 <b>backward-word</b>
      使用的相同。</dd>
  <dt><b>copy-forward-word</b></dt>
  <dd>將 point
      之後的詞複製到剪切緩衝區中。
      詞的邊界與 <b>backward-word</b>
      使用的相同。</dd>
  <dt><b>yank (C-y)</b></dt>
  <dd>將 kill-ring
      頂部的內容粘貼到 point
      處的緩衝區中</dd>
  <dt><b>yank-pop (M-y)</b></dt>
  <dd>輪轉
      kill-ring，粘貼新的頂部內容。只能在
      <b>yank</b> 或 <b>yank-pop</b>
      之後使用。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Numeric_Arguments_數值參數">Numeric Arguments 數值參數<a class="anchor" href="#Numeric_Arguments_%E6%95%B8%E5%80%BC%E5%8F%83%E6%95%B8">¶</a></h2>
<dl class="Bl-tag">
  <dt><b>digit-argument (M-0, M-1, ..., M--)</b></dt>
  <dd>將這個數字加入已有的
      (already accumulating)
      參數中，或者開始新的參數。
      M--
      開始一個否定的參數。</dd>
  <dt><b>universal-argument</b></dt>
  <dd>這是指定參數的另一種方法。如果這個命令後面跟着一個或多個數字，
      可能還包含前導的負號，這些數字定義了參數。如果命令之後跟隨着數字，再次執行
      <b>universal-argument</b>
      將結束數字參數，但是其他情況下被忽略。有一種特殊情況，如果命令之後緊接着
      一個並非數字或負號的字符，下一命令的參數計數將乘以
      4。 參數計數初始是
      1，因此第一次執行這個函數，使得參數計數爲
      4，
      第二次執行使得參數計數爲
      16，以此類推。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Completing_補全">Completing 補全<a class="anchor" href="#Completing_%E8%A3%9C%E5%85%A8">¶</a></h2>
<dl class="Bl-tag">
  <dt><b>complete (TAB)</b></dt>
  <dd>試着對 point
      之前的文本進行補全。
      <b>Bash</b>
      依次試着將文本作爲一個變量
      (如果文本以 <b>$</b>
      開始)，一個用戶名
      (如果文本以 <b>~</b>
      開始)，主機名
      (如果文本以 <b>@</b>
      開始)，或者命令
      (以及別名和函數)
      來補全。如果這些都沒有匹配，將嘗試文件名補全。</dd>
  <dt><b>possible-completions (M-?)</b></dt>
  <dd>列出 point
      之前的文本可能的補全。</dd>
  <dt><b>insert-completions (M-*)</b></dt>
  <dd>插入 <b>possible-completions</b>
      已產生的 point
      之前的文本所有的補全。</dd>
  <dt><b>menu-complete</b></dt>
  <dd>與 <b>complete</b>
      相似，但是使用可能的補全列表中的某個匹配替換要補全的詞。
      重複執行 <b>menu-complete</b>
      將遍歷可能的補全列表，插入每個匹配。
      到達補全列表的結尾時，鳴終端響鈴
      (按照 <b>bell-style</b>
      的設置來做)
      並恢復初始的文本。
      參數 <i>n</i>
      將在匹配列表中向前移動
      <i>n</i>
      步；負數參數可以用於在列表中向後移動。
      這個命令應當與 <b>TAB</b>
      鍵關聯，但是默認情況下是沒有關聯的。</dd>
  <dt><b>delete-char-or-list</b></dt>
  <dd>刪除光標下的字符，如果不是在行首或行尾
      (類似 <b>delete-char</b>)。
      如果在行尾，行爲與
      <b>possible-completions</b> 一致。
      這個命令默認沒有關聯。</dd>
  <dt><b>complete-filename (M-/)</b></dt>
  <dd>嘗試對 point
      之前的文本進行文件名補全。</dd>
  <dt><b>possible-filename-completions (C-x /)</b></dt>
  <dd>列出 point
      之前的文本可能的補全，將它視爲文件名。</dd>
  <dt><b>complete-username (M-~)</b></dt>
  <dd>嘗試對 point
      之前的文本進行補全，將它視爲用戶名。</dd>
  <dt><b>possible-username-completions (C-x ~)</b></dt>
  <dd>列出 point
      之前的文本可能的補全，將它視爲用戶名。</dd>
  <dt><b>complete-variable (M-$)</b></dt>
  <dd>嘗試對 point
      之前的文本進行補全，將它視爲
      shell 變量。</dd>
  <dt><b>possible-variable-completions (C-x $)</b></dt>
  <dd>列出 point
      之前的文本可能的補全，將它視爲
      shell 變量。</dd>
  <dt><b>complete-hostname (M-@)</b></dt>
  <dd>嘗試對 point
      之前的文本進行補全，將它視爲主機名。</dd>
  <dt><b>possible-hostname-completions (C-x @)</b></dt>
  <dd>列出 point
      之前的文本可能的補全，將它視爲主機名。</dd>
  <dt><b>complete-command (M-!)</b></dt>
  <dd>嘗試對 point
      之前的文本進行補全，將它視爲命令名。命令補全嘗試着將此文本
      依次與別名，保留字，shell
      函數，shell
      內建命令，最後是可執行文件名進行匹配。</dd>
  <dt><b>possible-command-completions (C-x !)</b></dt>
  <dd>列出 point
      之前的文本可能的補全，將它視爲命令名。</dd>
  <dt><b>dynamic-complete-history (M-TAB)</b></dt>
  <dd>嘗試對 point
      之前的文本進行補全，將此文本與歷史列表中的行相比較來查找可能的補全匹配。</dd>
  <dt><b>complete-into-braces (M-{)</b></dt>
  <dd>進行文件名補全，將可能的補全列表放在花括號中插入，使得列表可以被
      shell 使用 (參見上面的 <b>Brace
      Expansion</b> 花括號擴展)。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Keyboard_Macros_宏">Keyboard Macros 宏<a class="anchor" href="#Keyboard_Macros_%E5%AE%8F">¶</a></h2>
<dl class="Bl-tag">
  <dt><b>start-kbd-macro (C-x ()</b></dt>
  <dd>開始保存輸入字符爲當前鍵盤宏。</dd>
  <dt><b>end-kbd-macro (C-x ))</b></dt>
  <dd>停止保存輸入字符爲當前鍵盤宏，保存宏定義。</dd>
  <dt><b>call-last-kbd-macro (C-x e)</b></dt>
  <dd>重新執行上次定義的鍵盤宏，即顯示出宏中的字符，好像它們是從鍵盤輸入的一樣。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Miscellaneous">Miscellaneous<a class="anchor" href="#Miscellaneous">¶</a></h2>
<dl class="Bl-tag">
  <dt><b>re-read-init-file (C-x C-r)</b></dt>
  <dd>讀入 <i>inputrc</i>
      文件的內容，合併其中的按鍵關聯和變量賦值。</dd>
  <dt><b>abort (C-g)</b></dt>
  <dd>取消當前編輯命令，鳴終端響鈴
      (按照 <b>bell-style</b>
      的設置來做)。</dd>
  <dt><b>do-uppercase-version (M-a, M-b, M-<i>x</i>, ...)</b></dt>
  <dd>如果有 Meta 前綴的字符
      <i>x</i>
      是小寫的，那麼與命令相關連的是對應的大寫字符。</dd>
  <dt><b>prefix-meta (ESC)</b></dt>
  <dd>將輸入的下一個字符加上
      Meta 前綴。 <small><b>ESC</b></small> <b>f</b>
      等價於 <b>Meta-f</b>.</dd>
  <dt><b>undo (C-_, C-x C-u)</b></dt>
  <dd>增量的撤銷，分別記住每一行。</dd>
  <dt><b>revert-line (M-r)</b></dt>
  <dd>撤銷這一行的所有修改。這與執行命令
      <b>undo</b>
      足夠多次的效果相同，將這一行恢復到初始狀態。</dd>
  <dt><b>tilde-expand (M-&amp;)</b></dt>
  <dd>對當前詞進行波浪線擴展。</dd>
  <dt><b>set-mark (C-@, M-&lt;space&gt;)</b></dt>
  <dd>在 point 處設置
      mark。如果給出了數值的參數，標記被設置到那個位置。</dd>
  <dt><b>exchange-point-and-mark (C-x C-x)</b></dt>
  <dd>交換 point 和
      mark。當前光標位置被設置爲保存的位置，舊光標位置被保存爲
      mark。</dd>
  <dt><b>character-search (C-])</b></dt>
  <dd>讀入一個字符，point
      移動到這個字符下一次出現的地方。負數將搜索上一個出現。</dd>
  <dt><b>character-search-backward (M-C-])</b></dt>
  <dd>讀入一個字符，point
      移動到這個字符上一次出現的地方。負數將搜索下面的出現。</dd>
  <dt><b>insert-comment (M-#)</b></dt>
  <dd>沒有數值的參數時，readline
      變量 <b>comment-begin</b>
      的值將被插入到當前行首。如果給出一個數值的參數，命令的行爲類似於一個開關：
      如果行首字符不匹配
      <b>comment-begin</b>
      的值，將插入這個值，否則
      匹配 <b>comment-begin</b>
      的字符將被從行首刪除。在兩種情況下，這一行都被接受，
      好像輸入了新行符一樣。<b>comment-begin</b>
      的默認值使得這個命令將當前行變成
      一條 shell
      註釋。如果數值參數使得註釋字符被刪除，這一行將被
      shell 執行。</dd>
  <dt><b>glob-complete-word (M-g)</b></dt>
  <dd>point
      之前的詞被當作路徑擴展的一個模式，尾部暗含了一個星號。這個模式被用來
      爲可能的補全產生匹配的文件名列表。</dd>
  <dt><b>glob-expand-word (C-x *)</b></dt>
  <dd>point
      之前的詞被當作路徑擴展的一個模式，匹配的文件名的列表被插入，替換這個詞。
      如果給出一個數值參數，在路徑擴展之前將添加一個星號。</dd>
  <dt><b>glob-list-expansions (C-x g)</b></dt>
  <dd>顯示 <b>glob-expand-word</b>
      可能產生的擴展的列表，重繪當前行。如果給出一個數值參數，在路徑擴展之前將添加一個星號。</dd>
  <dt><b>dump-functions</b></dt>
  <dd>向 readline
      輸出流打印所有的函數和它們的按鍵關聯。如果給出一個數值參數，
      輸出將被格式化，可以用作
      <i>inputrc</i> 文件一部分。</dd>
  <dt><b>dump-variables</b></dt>
  <dd>向 readline
      輸出流打印所有可設置的
      readline
      函數。如果給出一個數值參數，
      輸出將被格式化，可以用作
      <i>inputrc</i> 文件一部分。</dd>
  <dt><b>dump-macros</b></dt>
  <dd>向 readline
      輸出流打印所有關聯到宏的
      readline
      按鍵序列以及它們輸出的字符串。
      如果給出一個數值參數，輸出將被格式化，可以用作
      <i>inputrc</i> 文件一部分。</dd>
  <dt><b>display-shell-version (C-x C-v)</b></dt>
  <dd>顯示當前 <b>bash</b>
      實例的版本信息。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Programmable_Completion_可編程補全">Programmable Completion 可編程補全<a class="anchor" href="#Programmable_Completion_%E5%8F%AF%E7%B7%A8%E7%A8%8B%E8%A3%9C%E5%85%A8">¶</a></h2>
當試圖對一個命令的參數進行詞的補全時，如果已經使用內建命令
  <b>complete</b>
  定義了這個命令的補全規則
  (
  <b>compspec</b>)，將啓動可編程補全功能
  (參見下面的 <small><b>shell
  內建命令(SHELL BUILTIN COMMANDS)</b></small>
  章節)。
<p class="Pp">首先，命令名被確認。如果針對這個命令有補全規則的定義，那麼將使用
    規則來產生可能的詞的補全的列表。如果命令詞是一個路徑全名，將首先搜索
    針對這個路徑全名的規則。如果針對這個路徑全名沒有找到規則，將嘗試查找
    針對最後一個斜槓後面的部分的規則。</p>
<p class="Pp">一旦找到了一個規則，它將用作產生匹配的詞。如果沒有找到，將進行上面
    <b>Completing</b> 中描述的 <b>bash</b>
    默認的補全。</p>
<p class="Pp">首先，將執行規則指定的動作。只有以被補全的詞開始的匹配詞纔會被返回。
    當在文件或目錄名補全中使用
    <b>-f</b> 或 <b>-d</b> 選項時，shell
    變量 <small><b>FIGNORE</b></small>
    將用於對匹配進行過濾。</p>
<p class="Pp">接下來，將產生所有由<b>-G</b>
    選項給出的文件名擴展模式指定的補全。
    模式產生的詞不必匹配要補全的詞。shell
    變量 <small><b>GLOBIGNORE</b></small>
    不會用於過濾匹配結果，但是變量
    <small><b>FIGNORE</b></small> 會被使用。</p>
<p class="Pp">接下來，將考慮 <b>-W</b>
    選項的參數指定的字符串。這個字符串首先被
    劃分，用特殊變量
    <small><b>IFS</b></small>
    中的字符作爲分隔符。shell
    引用被當作一個詞。
    接下來，每個詞被擴展，使用上面
    <b>EXPANSION</b> 中描述的 brace expansion, tilde
    expansion, parameter 和 variable expansion, command substitution,
    arithmetic expansion, 以及 pathname expansion
    規則處理。對於結果，再使用上面
    <b>Word Splitting</b>
    中描述的規則劃分成詞。
    擴展的結果與要補全的詞進行前部一致的比較，匹配的詞成爲可能的補全。</p>
<p class="Pp">在這些匹配被產生後，任何由
    <b>-F</b> 和 <b>-C</b> 選項指定的 shell
    函數和命令將被執行。當命令或函數被執行時，變量
    <small><b>COMP_LINE</b></small> 和 <small><b>COMP_POINT</b></small>
    被賦值，使用上面 <b>Shell
    Variables</b> 中的規則。
    如果要執行 shell
    函數，還將設置變量
    <small><b>COMP_WORDS</b></small> 和 <small><b>COMP_CWORD</b></small>
    當函數或命令被執行時，第一個參數是等待參數被補全的命令的名稱，
    第二個參數是要補全的詞，第三個參數是當前命令行中，要補全的詞前面的詞。
    對要補全的詞產生的補全不會進行任何過濾；函數或命令在產生匹配時有完全的自由。</p>
<p class="Pp">任何 <b>-F</b>
    指定的函數將被首先執行。函數可以使用任何
    shell 功能，
    包含內建命令
    <i>compgen</i>，來產生匹配。它必須將可能的補全放到數組變量
    <small><b>COMPREPLY</b></small> 中。</p>
<p class="Pp">接下來，任何 <b>-C</b>
    選項指定的命令將被執行，其執行環境與命令替換
    的環境相同。它應當向標準輸出打印一個補全的列表，每行一個。
    反斜槓可以用來轉義一個新行符，如果需要的話。</p>
<p class="Pp">所有可能的補全都產生之後，將對列表進行
    <b>-X</b>
    選項指定的任何過濾。
    過濾器是一個模式，和路徑名擴展中的一樣；模式中的
    <b>&amp;</b> 替換爲
    要補全的詞。字面上的
    <b>&amp;</b>
    可以用反斜槓轉義；反斜槓在進行匹配時被刪除。
    任何匹配這個模式的補全將從列表中刪除。前導的
    <b>!</b>
    將使模式含義相反；
    這種情況下，任何不匹配這個模式的補全將被刪除。</p>
<p class="Pp">最後，<b>B-P</b> 和 <b>-S</b>
    指定的任何前綴和後綴被添加到補全列表的每個
    成員後面，結果返回給
    readline
    補全代碼，作爲可能的補全列表。</p>
<p class="Pp">如果先前執行的動作沒有產生任何匹配，並且在定義
    compspec 規則時，爲 <b>complete</b>
    命令提供了 <b>-o dirname</b>
    選項，將嘗試目錄名補全。</p>
<p class="Pp">默認情況下，如果找到了一個規則，它產生的任何東西都被返回給補全代碼，
    作爲可能的補全的全集。不再嘗試默認的
    <b>bash</b> 補全，readline 默認的
    文件名補全也會禁止。如果定義規則時，爲
    <b>complete</b> 命令提供了 <b>-o default</b>
    選項，在規則沒有產生匹配時將進行
    readline
  默認的補全處理。</p>
<p class="Pp">當一個規則指出期望目錄名補全時，可編程補全函數強制
    readline 在補全的名稱
    後面添加一個斜槓，如果它是一個到目錄的符號連接。然後還要經過
    readline 變量 <b>mark-directories</b>
    的值處理，不管 readline
    變量 <b>mark-symlinked-directories</b>
    的值是什麼。</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="歷史(HISTORY)">歷史(HISTORY)<a class="anchor" href="#%E6%AD%B7%E5%8F%B2(HISTORY)">¶</a></h1>
當啓用內建命令 <b>set</b> 的
  <b>-o history</b> 選項時，shell
  允許訪問 <i>command
  history</i>，以前輸入的命令的列表。
  <b>HISTSIZE</b>
  的值用作命令列表中保存的命令數量。
  過去 <small><b>HISTSIZE</b></small> 個
  (默認爲500)
  命令將被保存。shell
  將每條命令在進行參數和變量擴展之前
  保存到歷史列表中
  (參見上面的 <small><b>EXPANSION</b></small>
  段落)，但是是在歷史擴展進行之後，並且要經過
  shell 變量 <small><b>HISTIGNORE</b></small> 和
  <b>HISTCONTROL</b> 處理。
<p class="Pp">在啓動時，歷史根據以變量
    <small><b>HISTFILE</b></small>
    的值爲名的文件
    (默認是 <i>~/.bash_history</i>)
    進行初始化。
    如果需要的話，以
    <small><b>HISTFILE</b></small>
    爲名的文件將被截斷，來包含不超過變量
    <b>HISTFILESIZE</b>
    的值指定的行數。當交互
    shell 退出時，最後
    <small><b>$HISTSIZE</b></small>
    行被從歷史列表中複製到
    <b>$HISTFILE</b>
    文件中。如果啓用了
    shell 選項 <b>histappend</b>
    (參見下面的 <small><b>shell
    內建命令(SHELL BUILTIN COMMANDS)</b></small>
    章節中對內建命令
    <b>shopt</b>
    的描述)，這些行被追加到歷史文件中，否則歷史文件被覆蓋。如果
    <small><b>HISTFILE</b></small>
    被取消定義，或者如果歷史文件不可寫，歷史將不會保存。保存歷史之後，
    歷史文件被截斷，以包含不超過
    <small><b>HISTFILESIZE</b></small> 行。如果
    <small><b>HISTFILESIZE</b></small>
    被取消定義，不會進行截斷操作。</p>
<p class="Pp">內建命令 <b>fc</b>
    (參見下面的 <small><b>shell
    內建命令(SHELL BUILTIN COMMANDS)</b></small>
    章節)
    可以用來列出或修改並重新執行歷史列表中的一部分。內建命令
    <b>history</b>
    可以用來顯示或修改歷史列表，操作歷史文件。當使用命令行編輯時，每種
    編輯模式都有搜索命令，提供對歷史列表的訪問。</p>
<p class="Pp">shell
    允許控制哪些命令被保存到歷史列表中。可以設置
    <small><b>HISTCONTROL</b></small> 和 <small><b>HISTIGNORE</b></small>
    變量，來使得 shell
    只保存輸入命令的一個子集。shell
    選項 <b>cmdhist</b>
    如果被啓用，將使得
    shell
    將多行的命令的每一行保存到同一個歷史條目中，
    在需要的地方添加分號來保證語義的正確性。shell
    選項 <b>lithist</b> 使得 shell
    保存命令時，保留嵌入的新行而不是用分號代替。參見下面
    <small><b>shell 內建命令(SHELL BUILTIN
    COMMANDS)</b></small> 中，內建命令
    <b>shopt</b>
    的描述，有關設置和取消
    shell 選項的信息。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="歷史擴展(&#34;HISTORY_EXPANSION&#34;)">歷史擴展(&#34;HISTORY EXPANSION&#34;)<a class="anchor" href="#%E6%AD%B7%E5%8F%B2%E6%93%B4%E5%B1%95(%22HISTORY_EXPANSION%22)">¶</a></h1>
shell
  支持歷史擴展機制，類似於
  <b>csh</b>
  中歷史擴展。這一節描述了可用的語法特徵。在交互的
  shell
  中這一機制被默認啓用，
  可以使用內建命令 <b>set</b>
  的 <b>-H</b> 選項來禁用它
  (參見下面的 <small><b>shell
  內建命令(SHELL BUILTIN COMMANDS)</b></small>
  章節)。非交互的 shell
  默認不進行歷史擴展。
<p class="Pp">歷史擴展將歷史列表中的詞引入輸入流中，使得可以方便地重複已執行命令，
    在當前輸入行中爲前一個命令插入新的參數，
    或者快速修正前一個命令中的錯誤。</p>
<p class="Pp">歷史擴展在讀入一整行後，在
    shell
    將它拆分成詞之前立即進行。它
    由兩部分組成。首先是判斷替換中使用歷史列表中哪一行。其次是選擇那一行中要包含到當前行中的部分。
    從歷史中選擇的行稱爲
    <i>event</i>，從那一行中選擇的部分是
    <i>words</i>。
    可以用多種多樣的
    <i>modifiers</i>
    來操縱所選的詞。在讀入輸入時，行被按照同樣方式分解成詞，
    因此多個以 <i>metacharacter</i>
    分隔的詞，如果被引號包含，就被當成一個詞。
    歷史擴展由歷史擴展字符引入，默認是
    <b>!</b>。只有反斜槓 (<b>\</b>)
    和單引號可以引用歷史擴展字符。</p>
<p class="Pp">內建命令 <b>shopt</b>
    可以設定多個選項值，來調整歷史擴展的行爲。如果
    shell 選項 <b>histverify</b> 被啓用
    (參見內建命令 <b>shopt</b>
    的描述)，並且正在使用
    <b>readline，</b>
    歷史替換不會被立即傳給
    shell
    解釋器。與此相對，擴展後的行被重新載入
    <b>readline</b>
    編輯緩衝區，進行進一步的修改。如果正在使用
    <b>readline，</b> 並且啓用了 shell
    選項 <b>histreedit，</b>
    失敗的歷史替換將被重新載入到
    <b>readline</b>
    編輯緩衝區，進行改正。內建命令
    <b>history</b> 的 <b>-p</b>
    選項可以用來在執行之前查看歷史擴展將如何進行。內建命令
    <b>history</b> 的 <b>-s</b>
    選項可以用來在歷史列表末尾添加命令，而不真正執行它們，從而
    在接下來的調用中可以使用它們。</p>
<p class="Pp">shell
    允許控制歷史擴展機制使用的多種字符
    (參見上面的 <b>Shell Variables</b> 中
    <b>histchars</b> 的描述)。</p>
<section class="Ss">
<h2 class="Ss" id="Event_Designators">Event Designators<a class="anchor" href="#Event_Designators">¶</a></h2>
事件指示器 (event designator)
  是一個對歷史列表中某個命令行條目的引用。
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>!</b></dt>
  <dd>開始一個命令替換，除非後面跟隨的是
      <b>blank</b>, newline, = 或是 (.</dd>
  <dt><b>!<i>n</i></b></dt>
  <dd>引用命令行 <i>n</i>.</dd>
  <dt><b>!-<i>n</i></b></dt>
  <dd>引用當前命令行減去
      <i>n</i>.</dd>
  <dt><b>!!</b></dt>
  <dd>引用上一條命令。這是
      `!-1&#39; 的同義詞。</dd>
  <dt><b>!<i>string</i></b></dt>
  <dd>引用最近的以 <i>string</i>
      開始的命令。</dd>
  <dt><b>!?<i>string</i><b>[?]</b></b></dt>
  <dd>引用最近的包含 <i>string</i>
      的命令。尾部的 <b>?</b>
      可以被忽略，如果
      <i>string</i>
      之後緊接着一個新行符。</dd>
  <dt><b>^<i>string1</i>^<i>string2</i>^</b></dt>
  <dd>快速替換。重複上一條命令，將
      <i>string1</i> 替換爲 <i>string2</i>. 與
      ``!!:s/<i>string1</i>/<i>string2</i>/&#39;&#39; 等價
      (參見下面的 <b>修飾符
      (Modifiers)</b>)。</dd>
  <dt><b>!#</b></dt>
  <dd>到此爲止輸入的整個命令行。</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Word_Designators">Word Designators<a class="anchor" href="#Word_Designators">¶</a></h2>
詞指示器 (word designator) 用於從
  event 中選擇期望的詞。
  <b>:</b> 分隔 event 規則與 word
  指示器。它可以忽略，如果詞指示器以
  <b>^</b>, <b>$</b>, <b>*</b>, <b>-</b>, 或 <b>%</b>
  開始。詞被從行首開始編號，第一個詞被表示爲
  0。插入當前行中的詞以單個空格分隔。
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>0 (zero)</b></dt>
  <dd>第 0 個詞。對 shell
      來將，這是命令名。</dd>
  <dt><i>n</i></dt>
  <dd>第 <i>n</i> 個詞。</dd>
  <dt><b>^</b></dt>
  <dd>第一個參數。也就是，第
      1 個詞。</dd>
  <dt><b>$</b></dt>
  <dd>最後的參數。</dd>
  <dt><b>%</b></dt>
  <dd>最近一次搜索 `?<i>string</i>?&#39;
      匹配的詞。</dd>
  <dt><i>x<b>-</b>y</i></dt>
  <dd>一組詞；`-<i>y</i>&#39; 是 `0-<i>y</i>&#39;
      的簡寫。</dd>
  <dt><b>*</b></dt>
  <dd>所有詞，除了第 0
      個。這是 `<i>1-$</i>&#39;
      的同義詞。如果 event
      中只有一個詞，使用
      <b>*</b>
      也不是錯誤；這種情況下將返回空字符串。</dd>
  <dt><b>x*</b></dt>
  <dd><i>x-$</i> 的簡寫。</dd>
  <dt><b>x-</b></dt>
  <dd><i>-$</i> 的簡寫，就像 <b>x*</b>
      一樣，但是忽略最後一個詞。</dd>
</dl>
<p class="Pp">如果給出了一個 word
    指示器，沒有給出 event
    規則，前一個命令將用作
    event。</p>
</section>
<section class="Ss">
<h2 class="Ss" id="修飾符_(Modifiers)">修飾符 (Modifiers)<a class="anchor" href="#%E4%BF%AE%E9%A3%BE%E7%AC%A6_(Modifiers)">¶</a></h2>
可選的 word
  指示器之後，可以出現一個或多個下述
  modifiers
  的序列，每一個都前綴有
  `:&#39;。
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>h</b></dt>
  <dd>刪除文件名組成的尾部，只保留頭部。</dd>
  <dt><b>t</b></dt>
  <dd>刪除文件名組成中前面的成分，保留尾部。</dd>
  <dt><b>r</b></dt>
  <dd>刪除 <i>.xxx</i>
      形式中尾部的後綴成分，保留基本名稱部分。</dd>
  <dt><b>e</b></dt>
  <dd>刪除所有內容，保留尾部的後綴。</dd>
  <dt><b>p</b></dt>
  <dd>打印新的命令，但是不執行它。</dd>
  <dt><b>q</b></dt>
  <dd>引用替換所得的詞，使它不再進行替換。</dd>
  <dt><b>x</b></dt>
  <dd>引用替換所得的詞，類似與
      <b>q</b>, 但是會根據
      <b>blanks，空白</b>
      和新行符分解爲詞。</dd>
  <dt><b>s/<i>old</i>/<i>new</i>/</b></dt>
  <dd>將事件行中出現的第一個
      <i>old</i> 替換爲 <i>new。</i>
      任何分隔符都可以用來代替
      /，最後一個分隔符是可選的，如果它是事件行的最後一個字符。
      <i>old</i> 和 <i>new</i>
      中的分隔符可以用一個反斜槓來引用。如果
      &amp; 出現在 <i>new</i>
      中，它將替換爲
      <i>old。</i>
      可以用單個反斜槓來引用
      &amp;。如果 <i>old</i>
      爲空，它將設置爲最後替換的
      <i>old，</i>
      或者，如果前面沒有發生過歷史替換，就是
      <b>!?<i>string</i><b>[?]</b></b>
      搜索中的最後一個
      <i>string。</i></dd>
  <dt><b>&amp;</b></dt>
  <dd>重複上一次替換。</dd>
  <dt><b>g</b></dt>
  <dd>使得改變被整個事件行所接受。用於與
      `<b>:s</b>&#39; 或 `<b>:&amp;</b>&#39; 結合
      (例如，`<b>:gs/</b><i>old</i><b>/</b><i>new</i><b>/</b>&#39;)。
      如果與 `<b>:s</b>&#39;
      結合使用，任何分隔符都可以用來代替
      /，
      最後一個分隔符是可選的，如果它是事件行的最後一個字符。</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="shell_內建命令(SHELL_BUILTIN_COMMANDS)">shell 內建命令(SHELL BUILTIN COMMANDS)<a class="anchor" href="#shell_%E5%85%A7%E5%BB%BA%E5%91%BD%E4%BB%A4(SHELL_BUILTIN_COMMANDS)">¶</a></h1>
除非另外說明，這一章介紹的內建命令如果接受
  <b>-</b>
  引導的選項，那麼它也接受
  <b>--</b>
  作爲參數，來指示選項的結束
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>:</b> [<i>arguments</i>]</dt>
  <dd>沒有效果；這個命令除了擴展
      <i>arguments</i>
      並且作任何指定的重定向之外，不做任何事。
      退出時返回0。</dd>
  <dt><b> . </b> <i>filename</i> [<i>arguments</i>]</dt>
  <dd></dd>
  <dt><b>source</b> <i>filename</i> [<i>arguments</i>]</dt>
  <dd>讀取並在當前 shell
      環境中執行 <i>filename</i>
      中的命令，返回 <i>filename</i>
      中最後一個命令的返回狀態。如果
      <i>filename</i> 中不包含斜槓
      (slash)，系統將在 <small><b>PATH</b></small>
      中查找包含 <i>filename</i>
      的目錄。在 <small><b>PATH</b></small>
      中搜索的文件不必是可執行的。
      如果 <b>bash</b> 不是運行於
      <i>posix mode</i>，當 <b>PATH</b>
      中找不到文件時會在當前目錄搜索。如果
      <b>shopt</b> 內建命令的 <b>sourcepath</b>
      選項被關閉，
      <small><b>PATH</b></small>
      將不會被搜索。如果有任何
      <i>arguments</i> ，它們成爲 <i>filename</i>
      的位置參數 (positional
      parameters)，否則
      位置參數不發生變化。
      返回狀態是腳本中最後一個命令退出時的狀態。
      沒有執行命令則返回0，沒有找到或不能讀取
      <i>filename</i> 時返回false。</dd>
  <dt><b>alias</b> [<b>-p</b>] [<i>name</i>[=<i>value</i>] ...]</dt>
  <dd><b>Alias</b> 不帶參數或者帶
      <b>-p</b>
      參數運行時將在標準輸出以這樣的格式
      <b>alias</b> <i>name</i>=<i>value</i>
      給出別名列表。
      如果有參數，將創建提供了
      <i>value</i> 的 <i>name</i> 的別名。
      <i>value</i>
      中尾部的空格使得別名被擴展時，下一個詞做別名替換。
      對於參數列表中的每一個
      <i>name</i>，如果 <i>value</i> 沒有
      給出，這個別名的名稱和值會被打印出來。
      <b>Alias</b> 返回 true 除非 <i>name</i>
      沒有定義爲別名。</dd>
  <dt><b>bg</b> [<i>jobspec</i>]</dt>
  <dd>使掛起的程序 <i>jobspec</i>
      在後臺繼續執行，就好像它是用
      <b>&amp;</b>
      啓動的一樣。如果沒有指定
      <i>jobspec</i>，shell 意義上的 <i>current
      job 當前作業</i>
      將被使用。 <b>bg</b> <i>jobspec</i>
      返回0，除非當前禁止了作業控制，或者在允許作業控制，但
      是沒有找到 <i>jobspec</i>
      ，或者它不是在作業控制下啓動的時候。</dd>
  <dt><b>bind</b> [<b>-m</b> <i>keymap</i>] [<b>-lpsvPSV</b>]</dt>
  <dd></dd>
  <dt><b>bind</b> [<b>-m</b> <i>keymap</i>] [<b>-q</b> <i>function</i>]
    [<b>-u</b> <i>function</i>] [<b>-r</b> <i>keyseq</i>]</dt>
  <dd></dd>
  <dt><b>bind</b> [<b>-m</b> <i>keymap</i>] <b>-f</b> <i>filename</i></dt>
  <dd></dd>
  <dt><b>bind</b> [<b>-m</b> <i>keymap</i>] <b>-x</b>
    <i>keyseq</i>:<i>shell-command</i></dt>
  <dd></dd>
  <dt><b>bind</b> [<b>-m</b> <i>keymap</i>]
    <i>keyseq</i>:<i>function-name</i></dt>
  <dd></dd>
  <dt><b>bind</b> <i>readline-command</i></dt>
  <dd>顯示當前 <b>readline</b>
      鍵和功能的，將一個按鍵序列和一個
      <b>readline</b>
      功能或宏進行關聯，或者設置一個
      <b>readline</b>
      變量。每一個在非選項的參數都是一個命令，好像它是在
      <i>.inputrc</i>
      中出現的一樣。但是每個關聯或者命令必須作爲單獨的參數傳遞；
      也就是這樣 &#39;&#34;\C-x\C-r&#34;:
      re-read-init-file&#39;。
      如果有參數，它們有如下的意義：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-m <i>keymap</i></b></dt>
  <dd>使用 <i>keymap</i>
      作爲隨後的關聯的keymap。可選的
      <i>keymap</i> 名稱是 <i>emacs, emacs-standard,
      emacs-meta, emacs-ctlx, vi,</i> <i>vi-move,
      vi-command</i>，還有 <i>vi-insert</i>。 <i>vi</i>
      和 <i>vi-command</i> 等價; <i>emacs</i> 和
      <i>emacs-standard</i> 等價。</dd>
  <dt><b>-l</b></dt>
  <dd>列出所有的 <b>readline</b>
      功能。</dd>
  <dt><b>-p</b></dt>
  <dd>以程序可讀的方式顯示
      <b>readline</b>
    功能名稱和關聯</dd>
  <dt><b>-P</b></dt>
  <dd>列出當前 <b>readline</b>
      功能名稱和關聯。</dd>
  <dt><b>-v</b></dt>
  <dd>以程序可讀的方式顯示
      <b>readline</b> 變量名稱和值</dd>
  <dt><b>-V</b></dt>
  <dd>列出當前 <b>readline</b>
      變量和值。</dd>
  <dt><b>-s</b></dt>
  <dd>以程序可讀的方式顯示
      <b>readline</b>
      鍵序列和對應的宏</dd>
  <dt><b>-S</b></dt>
  <dd>顯示 <b>readline</b>
      宏對應的鍵序列和他們輸出的字符串</dd>
  <dt><b>-f <i>filename</i></b></dt>
  <dd>從 <i>filename</i>
    中讀取鍵序列</dd>
  <dt><b>-q <i>function</i></b></dt>
  <dd>查詢那些鍵將執行<i>function</i>。</dd>
  <dt><b>-u <i>function</i></b></dt>
  <dd>取消所有關聯到 <i>function</i>
      的鍵。</dd>
  <dt><b>-r <i>keyseq</i></b></dt>
  <dd>取消當前任何 <i>keyseq</i>
      的關聯。</dd>
  <dt><b>-x <i>keyseq</i>:<i>shell-command</i></b></dt>
  <dd>使 <i>shell-command</i> 在 <i>keyseq</i>
      按下時被執行。</dd>
</dl>
<p class="Pp">返回值是0，除非給出了一個不能識別的選項或是產生了一個錯誤。</p>
</div>
<dl class="Bl-tag">
  <dt><b>break</b> [<i>n</i>]</dt>
  <dd>從一個 <b>for</b>, <b>while</b>, <b>until</b>,
      或者 <b>select</b> 循環退出。
      如果指定了 <i>n</i>
      ，就跳出 <i>n</i> 層循環。
      <i>n</i> 必須 ≥ 1。如果 <i>n</i>
      比當前循環層數還要大，將跳出所有循環。
      返回值是0，除非執行
      <b>break</b> 的時候 shell
      不是在執行一個循環。</dd>
  <dt><b>builtin</b> <i>shell-builtin</i> [<i>arguments</i>]</dt>
  <dd>執行指定的 shell
      內建命令，傳遞 <i>arguments</i>
      ，返回命令的返回值。
      這在定義了一個和 shell
      內建命令同名的函數時很有用，
      在那個函數中使用它來執行相應的功能。<b>cd</b>
      命令常以這種方式重新定義。
      返回狀態是
      false，如果指定的 <i>shell-builtin</i>
      並不是一個 shell
      內建命令。</dd>
  <dt><b>cd</b> [<b>-L|-P</b>] [<i>dir</i>]</dt>
  <dd>改變當前路徑到
      <i>dir</i>。這個變量的默認值是
      <small><b>HOME</b></small>
      目錄。環境變量
      <small><b>CDPATH</b></small> 定義了包含
      <i>dir</i> 的搜索路徑。在
      <small><b>CDPATH</b></small>
      中可選的路徑名以冒號(:)
      分隔。 <small><b>CDPATH</b></small>
      中的空路徑名與當前路徑相同，就是
      ``<b>.</b>&#39;&#39;. 如果 <i>目錄名</i>
      以斜槓 (/,slash)
      起始，那麼 <small><b>CDPATH</b></small>
      不會被使用。 <b>-P</b>
      選項是說使用物理路徑結構而不是跟隨符號鏈接，(參見
      <b>set</b> 命令中的 <b>-P</b> 選項);
      <b>-L</b>
      選項強制跟隨符號鏈接。另外，選項
      <b>-</b> 與 <b>$OLDPWD</b> 是相同的。
      返回值是 true
      ，如果成功地改變了目錄；否則是
      false。</dd>
  <dt><b>command</b> [<b>-pVv</b>] <i>command</i> [<i>arg</i> ...]</dt>
  <dd>運行 <i>command</i> ，使用 <i>args</i>
      作爲參數，禁止通常的查找
      shell
      函數的過程。只有內建命令或者
      <small><b>PATH</b></small>
      中包含的命令可以執行。如果給出
      <b>-p</b> 參數， <i>command</i>
      的查找是以 <b>PATH</b>
      的默認值進行的。這樣可以保證找到所有的標準工具。如果給出
      <b>-V</b> 或者 <b>-v</b>
      選項，關於 <i>command</i>
      的說明將被打印出來。
      <b>-v</b>
      選項使得表述這個命令的詞，或者要執行
      <i>command</i>
      需要執行的文件顯示出來；
      <b>-V</b>
      選項給出更詳細的描述。如果給出
      <b>-V</b> 或者 <b>-v</b>
      選項，退出狀態在找到了
      <i>command</i>
      的情況下0，沒找到就是1。
      如果沒有提供選項，並且產生了錯誤或者
      <i>command</i>
      沒有找到，退出狀態就是127。否則，
      <b>command</b>
      內建命令的退出狀態是
      <i>command</i> 的退出狀態。</dd>
  <dt><b>compgen</b> [<i>option</i>] [<i>word</i>]</dt>
  <dd>根據 <i>option</i> 爲 <i>word</i>
      產生可能的補全。<i>option</i>
      是 內建命令 <b>complete</b>
      接受的任何選項，除了
      <b>-p</b> 和
      <b>-r</b>，將匹配結果寫到標準輸出。
      當使用 <b>-F</b> 或 <b>-C</b>
      選項時，可編程補全功能所設置的多數
      shell
      變量如果存在，其值將不再有用。
    <p class="Pp">產生的匹配與可編程補全代碼根據補全規則加上相同的標誌直接產生的結果相同。
        如果指定了
        <i>word</i>，只有匹配 <i>word</i>
        的補全結果將被顯示出來。</p>
    <p class="Pp">返回值爲真，除非提供了非法的選項，或者沒有產生匹配。</p>
  </dd>
  <dt><b>complete</b> [<b>-abcdefgjksuv</b>] [<b>-o</b> <i>comp-option</i>]
    [<b>-A</b> <i>action</i>] [<b>-G</b> <i>globpat</i>] [<b>-W</b>
    <i>wordlist</i>] [<b>-P</b> <i>prefix</i>] [<b>-S</b> <i>suffix</i>]</dt>
  <dd>
    <br/>
    [<b>-X</b> <i>filterpat</i>] [<b>-F</b> <i>function</i>] [<b>-C</b>
      <i>command</i>] <i>name</i> [<i>name ...</i>]</dd>
  <dt><b>complete</b> <b>-pr</b> [<i>name</i> ...]</dt>
  <dd>指定每個 <i>name</i>
      的參數應當如何被補全。如果給出了
      <b>-p</b> 選項，
      或者沒有選項給出，現有的補全規則將被顯示出來，以一種可以重用爲輸入
      的格式顯示。<b>-r</b>
      選項將一個針對每個
      <i>name</i>
      的補全規則刪除。
      或者，如果沒有給出
      <i>name</i>，將刪除所有補全規則。
    <p class="Pp">嘗試詞的補全時，應用這些補全規則的過程在上面
        <b>Programmable Completion</b>(可編程補全)
        中詳述。</p>
    <p class="Pp">其他選項，如果給出的話，具有下列意義。<b>-G</b>,
        <b>-W</b>, 和 <b>-X</b> 選項的參數
        (如果需要的話，還包括
        <b>-P</b> 和 <b>-S</b> 選項)
        應當被引用，避免在執行內建命令
        <b>complete</b> 之前被擴展。</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-o</b> <i>comp-option</i></dt>
  <dd><i>comp-option</i> 控制着 compspec
      除了簡單地產生補全之外的多種行爲。
      <i>comp-option</i>
      可以是如下之一：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>default</b></dt>
  <dd>使用 readline
      的默認文件名補全，如果
      compspec 沒有得到匹配。</dd>
  <dt><b>dirnames</b></dt>
  <dd>進行目錄名補全，如果
      compspec 沒有得到匹配。</dd>
  <dt><b>filenames</b></dt>
  <dd>告訴 readline，compspec
      產生了文件名，使它可以進行任何文件名專用的處理
      (例如，給目錄名加上斜槓或消除尾部空白)。主要用於
      shell 函數。</dd>
  <dt><b>nospace</b></dt>
  <dd>告訴 readline
      不要向補全的詞在行的最後添加一個空格
      (這是默認行爲)。</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>-A</b> <i>action</i></dt>
  <dd><i>action</i>
      可以是下列之一，來產生一系列可能的補全結果：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>alias</b></dt>
  <dd>起別名。也可以用 <b>-a</b>
      指定。</dd>
  <dt><b>arrayvar</b></dt>
  <dd>數組變量名。</dd>
  <dt><b>binding</b></dt>
  <dd><b>Readline</b> 按鍵關聯。</dd>
  <dt><b>builtin</b></dt>
  <dd>shell
      內建命令的名稱。也可以用
      <b>-b</b> 指定。</dd>
  <dt><b>command</b></dt>
  <dd>命令名。也可以用 <b>-c</b>
      指定。</dd>
  <dt><b>directory</b></dt>
  <dd>目錄名。也可以用 <b>-d</b>
      指定。</dd>
  <dt><b>disabled</b></dt>
  <dd>被禁用的內建命令名稱。</dd>
  <dt><b>enabled</b></dt>
  <dd>啓用的內建命令名稱。</dd>
  <dt><b>export</b></dt>
  <dd>被導出的 shell
      變量名稱。也可以用
      <b>-e</b> 指定。</dd>
  <dt><b>file</b></dt>
  <dd>文件名。也可以用 <b>-f</b>
      指定。</dd>
  <dt><b>function</b></dt>
  <dd>shell 函數的名稱。</dd>
  <dt><b>group</b></dt>
  <dd>組名。也可以用 <b>-g</b>
      指定。</dd>
  <dt><b>helptopic</b></dt>
  <dd>內建命令 <b>help</b>
      接受的幫助主題。</dd>
  <dt><b>hostname</b></dt>
  <dd>主機名，從環境變量
      <small><b>HOSTFILE</b></small>
      指定的文件中得到。</dd>
  <dt><b>job</b></dt>
  <dd>作業名，如果作業控制被激活的話。也可以用
      <b>-j</b> 指定。</dd>
  <dt><b>keyword</b></dt>
  <dd>shell 保留字。也可以用
      <b>-k</b> 指定。</dd>
  <dt><b>running</b></dt>
  <dd>正在運行的作業名，如果作業控制被激活的話。</dd>
  <dt><b>service</b></dt>
  <dd>服務名。也可以用 <b>-s</b>
      指定。</dd>
  <dt><b>setopt</b></dt>
  <dd>內建命令 <b>set</b> 的 <b>-o</b>
      選項的有效參數。</dd>
  <dt><b>shopt</b></dt>
  <dd>內建命令 <b>shopt</b> 接受的
      shell 選項名。</dd>
  <dt><b>signal</b></dt>
  <dd>信號名。</dd>
  <dt><b>stopped</b></dt>
  <dd>停止的作業名，如果作業控制被激活的話。</dd>
  <dt><b>user</b></dt>
  <dd>用戶名。也可以用 <b>-u</b>
      指定。</dd>
  <dt><b>variable</b></dt>
  <dd>shell
      變量的名稱。也可以用
      <b>-v</b> 指定。</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>-G</b> <i>globpat</i></dt>
  <dd>文件名擴展模式 <i>globpat</i>
      被擴展，產生可能的補全。</dd>
  <dt><b>-W</b> <i>wordlist</i></dt>
  <dd><small><i>wordlist</i> 被使用</small> <b>IFS</b>
      特殊變量中的字符作爲定界符來拆分，每個結果的詞被擴展。可能的補全是結果列表
      中匹配要補全的詞的那一些。</dd>
  <dt><b>-C</b> <i>command</i></dt>
  <dd><i>command</i> 將在一個子 shell
      環境中執行，它的結果用作可能的補全。</dd>
  <dt><b>-F</b> <i>function</i></dt>
  <dd>shell 函數 <i>function</i> 將在當前
      shell
      環境中執行。當它結束時，可能
      的補全可以從數組元素
      <small><b>COMPREPLY</b></small> 中得到。</dd>
  <dt><b>-X</b> <i>filterpat</i></dt>
  <dd><i>filterpat</i>
      是一個模式，用於文件名擴展。所有前面的選項和參數產生
      的可能的補全都要經過這一步處理，每一個匹配
      <i>filterpat</i> 的補全都
      被從列表中刪除。爲
      <i>filterpat</i> 加上前導 <b>!</b>
      使模式意義相反；
      這種情況下，所有不匹配
      <i>filterpat</i>
    的模式被刪除。</dd>
  <dt><b>-P</b> <i>prefix</i></dt>
  <dd>在所有其他選項都處理過之後，<i>prefix</i>
      被加到每個可能的補全前面。</dd>
  <dt><b>-S</b> <i>suffix</i></dt>
  <dd>在所有其他選項都處理過之後，<i>suffix</i>
      被加到每個可能的補全後面。</dd>
</dl>
<p class="Pp">返回值爲真，除非給出了非法的選項，給出除
    <b>-p</b> 和 <b>-r</b> 之外
    的某個選項時沒有給出
    <i>name</i>
    參數，試圖刪除一條
    <i>name</i> 的補全
    規則但是規則不存在，或者添加補全規則時出錯。</p>
</div>
<dl class="Bl-tag">
  <dt><b>continue</b> [<i>n</i>]</dt>
  <dd>復位到外層 <b>for</b>, <b>while</b>,
      <b>until</b>, 或 <b>select</b>
      循環的下一次開始。如果指定了
      <i>n，</i> 復位到向外第 <i>n</i>
      層循環的開始。 <i>n</i>
      必須 ≥ 1。如果 <i>n</i>
      比外部循環的層數要多，將復位到最外層的循環
      (``top-level&#39;&#39; loop，頂層循環)。
      返回值是 0，除非執行
      <b>continue</b> 時，shell
      不是在循環之中。</dd>
  <dt><b>declare</b> [<b>-afFirtx</b>] [<b>-p</b>]
    [<i>name</i>[=<i>value</i>]]</dt>
  <dd></dd>
  <dt><b>typeset</b> [<b>-afFirtx</b>] [<b>-p</b>]
    [<i>name</i>[=<i>value</i>]]</dt>
  <dd>聲明變量且/或設置它們的屬性。如果沒有給出
      <i>name</i>
      則顯示變量的值。
      選項 <b>-p</b>
      將顯示每個名稱 <i>name</i>
      的屬性和值。當使用
      <b>-p</b>
      時，其他選項被忽略。選項
      <b>-F</b>
      禁止顯示函數定義；只有函數名和屬性會被顯示。
      <b>-F</b> 選項暗含 <b>-f</b>.
      下列選項可用來限制只輸出具有指定屬性的變量，或者爲變量設置屬性：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-a</b></dt>
  <dd>每個 <i>name</i>
      都是數組變量
      (參見上面的 <b>Arrays</b>
      段落)。</dd>
  <dt><b>-f</b></dt>
  <dd>只使用函數名。</dd>
  <dt><b>-i</b></dt>
  <dd>變量被當作一個整數；當變量被賦值時將進行算術運算
      (參見 <small><b>算術求值 (ARITHMETIC
      EVALUATION)</b></small> 章節)。</dd>
  <dt><b>-r</b></dt>
  <dd>使得 <i>name</i>
      只讀。這些名稱不能再被後續的賦值語句賦值或取消定義。</dd>
  <dt><b>-t</b></dt>
  <dd>設置每個 <i>name</i> 的
      <i>trace</i>(跟蹤)
      屬性。被跟蹤的函數繼承了
      調用者 shell 的 <b>DEBUG</b>
      陷阱。trace
      屬性對變量沒有特殊意義。</dd>
  <dt><b>-x</b></dt>
  <dd>標記 <i>name</i>
      爲可以通過環境導出給後續命令。</dd>
</dl>
<p class="Pp">使用 `+&#39; 代替 `-&#39;
    將關閉屬性，特殊情況是
    <b>+a</b> 不能用於銷燬一個
    數組變量。當用於函數中時，它使得每個
    <i>name</i> 成爲局部的，就像
    使用了 <b>local</b>
    命令。返回值是
    0，除非遇到了非法的選項，試圖使用
    ``-f foo=bar&#39;&#39;
    定義函數，試圖向只讀變量賦值，試圖向數組變量賦值但沒有使用複合的賦值
    語法 (參見上面的 <b>Arrays</b>
    段落)，<i>name</i>
    之一不是有效的 shell
    變量名，試圖將數組變量的數組
    狀態關閉，或者是試圖使用
    <b>-f</b>
    顯示一個不存在的函數。</p>
</div>
<dl class="Bl-tag">
  <dt><b>dirs [<b>-clpv</b>] [+<i>n</i>] [-<i>n</i>]</b></dt>
  <dd>沒有選項時顯示當前保存的目錄。默認輸出爲一行，目錄名用空格分開。
      可以使用 <b>pushd</b>
      命令將目錄添加到列表，
      <b>popd</b>
      命令將列表中的條目刪除。</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>+</b><i>n</i></dt>
  <dd>顯示 <b>dirs</b>
      在不帶選項執行時顯示的列表的第
      <i>n</i> 個條目，從 0
      開始自左算起。</dd>
  <dt><b>-</b><i>n</i></dt>
  <dd>顯示 <b>dirs</b>
      在不帶選項執行時顯示的列表的第
      <i>n</i> 個條目，從 0
      開始自右算起。</dd>
  <dt><b>-c</b></dt>
  <dd>刪除所有條目，清空目錄棧。</dd>
  <dt><b>-l</b></dt>
  <dd>產生長列表；默認列表格式使用波浪線來表示個人目錄。</dd>
  <dt><b>-p</b></dt>
  <dd>輸出目錄棧，一行一個。</dd>
  <dt><b>-v</b></dt>
  <dd>輸出目錄棧，一行一個，每個條目前面加上它在棧中的位置索引。</dd>
</dl>
<p class="Pp">返回值是
    0，除非給出了非法的參數，或者
    <i>n</i>
    索引超出了目錄棧的範圍。</p>
</div>
<dl class="Bl-tag">
  <dt><b>disown</b> [<b>-ar</b>] [<b>-h</b>] [<i>jobspec</i> ...]</dt>
  <dd>沒有選項時，每個
      <i>jobspec</i>
      被從正在運行的作業表中刪除。如果給出了
      <b>-</b> 選項，每個 <i>jobspec</i>
      並不從表中刪除，而是被標記，使得在
      shell 接到 <b>SIGHUP</b>
      信號時，不會向作業發出
      <small><b>SIGHUP</b></small>
      信號。如果沒有給出
      <i>jobspec，</i> 也沒有給出 <b>-a</b>
      或者 <b>-r</b>
      選項，將使用當前作業
      (<i>current
      job</i>)。如果沒有給出
      <i>jobspec，</i> 選項 <b>-a</b>
      意味着刪除或標記所有作業；選項
      <b>-r</b> 不帶 <i>jobspec</i>
      參數時限制操作只對正在運行的作業進行。返回值是
      0，除非 <i>jobspec</i>
      不指定有效的作業。</dd>
  <dt><b>echo</b> [<b>-neE</b>] [<i>arg</i> ...]</dt>
  <dd>輸出
      <i>arg</i>，以空格分開，最後加一個新行符。返回值總是
      0。 如果指定了
      <b>-n</b>，將不在尾部添加新行符。如果給出了
      <b>-e</b> 選項，
      將允許解釋下列反斜槓轉義的字符。
      <b>-E</b>
      選項禁止這些轉義字符的解釋，即使在默認解釋它們的系統中也是如此。
      shell 選項 <b>xpg_echo</b>
      可以用來在運行時判斷
      <b>echo</b> 是否默認
      展開這些轉義字符。
      <b>echo</b> 不將 <b>--</b>
      作爲選項的結束。
      <b>echo</b>
      解釋下列轉義序列：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>\a</b></dt>
  <dd>alert (bell) 響鈴</dd>
  <dt><b>\b</b></dt>
  <dd>backspace 回退</dd>
  <dt><b>\c</b></dt>
  <dd>suppress trailing newline
      刪除尾部新行符</dd>
  <dt><b>\e</b></dt>
  <dd>an escape character 字符 Esc</dd>
  <dt><b>\f</b></dt>
  <dd>form feed 進紙</dd>
  <dt><b>\n</b></dt>
  <dd>new line 新行符</dd>
  <dt><b>\r</b></dt>
  <dd>carriage return 回車</dd>
  <dt><b>\t</b></dt>
  <dd>horizontal tab 水平跳格</dd>
  <dt><b>\v</b></dt>
  <dd>vertical tab 豎直跳格</dd>
  <dt><b>\\</b></dt>
  <dd>backslash 反斜槓</dd>
  <dt><b>\0<i>nnn</i></b></dt>
  <dd>一個八比特字符，它的值是八進制值
      <i>nnn</i>
      (零到三個八進制數字)。</dd>
  <dt><b>\<i>nnn</i></b></dt>
  <dd>一個八比特字符，它的值是八進制值
      <i>nnn</i>
      (一到三個八進制數字)。</dd>
  <dt><b>\x<i>HH</i></b></dt>
  <dd>一個八比特字符，它的值是十六進制值
      <i>HH</i>
      (一到兩個十六進制數字)。</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>enable</b> [<b>-adnps</b>] [<b>-f</b> <i>filename</i>] [<i>name</i>
    ...]</dt>
  <dd>允許或禁止 shell
      內建命令。禁止一個內建命令使得磁盤上的與內建命令同名
      的文件得以運行，不必使用它的全路徑，即使
      shell
      一般在搜索磁盤上的命令之前
      搜索內建命令。如果使用了
      <b>-n</b> 選項，每個 <i>name</i>
      都被禁止；否則，
      <i>name</i>
      被允許。例如，要使用
      <small><b>PATH</b></small> 中搜索到的
      <b>test</b> 命令而不是 shell
      內建的那一個，可以運行
      ``enable -n test&#39;&#39;. 選項 <b>-f</b>
      意味着從共享庫 <i>filename</i>
      中加載新的內建命令
      <i>name，</i>
      如果系統支持動態加載的話。選項
      <b>-d</b> 將刪除曾經用 <b>-f</b>
      加載的內建命令。如果沒有給出
      <i>name</i>
      參數，或者給出了 <b>-p</b>
      選項，將顯示 shell
      內建命令的列表。如果沒有其他選項參數，
      這個列表只包含所有被允許的
      shell
      內建命令；如果給出了
      <b>-n</b>，將只顯示被禁止的內建命令；如果給出了
      <b>-a</b>，顯示的列表中包含所有內建命令，還有命令是否被允許的指示；
      如果給出了
      <b>-s</b>，輸出被限制爲 POSIX
      <i>special</i> 內建命令。
      返回值是 0，除非 <i>name</i>
      不是 shell
      內建命令，或者從共享庫中加載新的內建命令時出錯。</dd>
  <dt><b>eval</b> [<i>arg</i> ...]</dt>
  <dd><i>arg</i>
      被讀取並連結爲單一的命令。這個命令然後被
      shell 讀取並執行，
      它的退出狀態被作爲
      <b>eval</b>
      的值返回。如果沒有
      <i>args</i>，
      或僅僅包含空參數，
      <b>eval</b> 返回 0。</dd>
  <dt><b>exec</b> [<b>-cl</b>] [<b>-a</b> <i>name</i>] [<i>command</i>
    [<i>arguments</i>]]</dt>
  <dd>如果指定了 <i>command，</i>
      它將替換
      shell。不會產生新的進程。
      <i>arguments</i> 成爲 <i>command</i>
      的參數。如果給出了
      <b>-l</b> 選項，shell
      將在傳遞給 <i>command</i> 的第 0
      個參數前面加上一個連字符
      (dash,`-&#39;)。這樣做和 <a href="../../buster/login/login.1.zh_CN.html">login(1)</a>
      相同。選項 <b>-c</b>
      使得命令 <i>command</i>
      在一個空環境中執行。如果給出了
      <b>-a，</b> shell 會將 <i>name</i>
      作爲第 0
      個參數傳遞給要執行的命令。如果由於某種原因
      as the zeroth argument to the executed command. If <i>command</i>
      不能被執行，非交互的
      shell 將退出，除非 shell
      選項 <b>execfail</b>
      被設置爲允許，這種情況下它返回失敗。如果命令不能執行，交互的
      shell 返回失敗。
      如果沒有指定 <i>command</i>
      任何重定向對當前 shell
      發生作用，返回值是
      0。如果發生重定向錯誤，返回狀態是
      1。</dd>
  <dt><b>exit</b> [<i>n</i>]</dt>
  <dd>使得 shell 以狀態值 <i>n</i>
      退出。如果忽略了
      <i>n，</i>
      退出狀態是最後執行的命令的退出狀態。在
      shell 終止前，對 <small><b>EXIT</b></small>
      的陷阱將被執行。</dd>
  <dt><b>export</b> [<b>-fn</b>] [<i>name</i>[=<i>word</i>]] ...</dt>
  <dd></dd>
  <dt><b>export -p</b></dt>
  <dd>給出的名稱 <i>names</i>
      被標記爲自動地導出到後續執行的命令的環境中。如果給出了
      <b>-f</b> 選項，名稱 <i>names</i>
      指的是函數。如果沒有給出
      <i>names，</i>
      或者如果給出了 <b>-p</b>
      選項，將打印在這個
      shell
      中被導出的所有名字的列表。選項
      <b>-n</b>
      使得以此爲名的變量的導出屬性被刪除。
      <b>export</b> 返回
      0，除非遇到了非法的選項，<i>name</i>
      之一不是有效的 shell
      變量名， 或者給出了
      <b>-f</b> 選項，而 <i>name</i>
      不是一個函數。</dd>
  <dt><b>fc</b> [<b>-e</b> <i>ename</i>] [<b>-nlr</b>] [<i>first</i>]
    [<i>last</i>]</dt>
  <dd></dd>
  <dt><b>fc</b> <b>-s</b> [<i>pat</i>=<i>rep</i>] [<i>cmd</i>]</dt>
  <dd>命令修復。第一種形式中，歷史列表中從
      <i>first</i> 到 <i>last</i>
      範圍內的命令都被選取。
      <i>First</i> 和 <i>last</i>
      可以指定爲字符串
      (可以定位最後一個以此字符串開始的命令)
      或者數字 (歷史列表中
      的索引，負數被當作相對當前命令號的偏移)。如果沒有指定
      <i>last，</i>
      它在列舉時被設爲當前命令
      (因此 ``fc -l -10&#39;&#39; 將輸出最後
      10
      條命令)，其他情況下被設爲
      <i>first。</i> 如果沒有指定
      <i>first，</i>
      它在編輯時被設爲前一個命令，列舉是設爲
      -16。
    <p class="Pp">選項 <b>-n</b>
        使得列舉時不顯示命令號碼。選項
        <b>-r</b>
        將命令順序進行掉換。如果給出了
        <b>-l</b>
        選項，命令將列舉在標準輸出上。否則，將啓動
        <i>ename</i>
        給出的編輯器，編輯包含這些命令的文件。如果沒有給出
        <i>ename，</i> 將使用變量
        <small><b>FCEDIT</b></small> 的值，如果
        <small><b>FCEDIT</b></small>
        沒有定義就使用
        <small><b>EDITOR</b></small>
        的值。如果仍然沒有定義，將使用
        <i>vi。</i>
        編輯結束後，被編輯的命令將回顯並執行。</p>
    <p class="Pp">第二種形式中，<i>command</i>
        在每個 <i>pat</i> 的實例被
        <i>rep</i> 替換後
        都被重新執行。使用這種特性時可以起一個有用的別名：
        ``r=fc -s&#39;&#39;, 這樣輸入 ``r cc&#39;&#39;
        將運行最後的以 ``cc&#39;&#39;
        開頭的命令，輸入 ``r&#39;&#39;
        將重新執行上一個命令。</p>
    <p class="Pp">如果使用第一種形式，返回值是
        0，除非遇到了非法的選項，或
        <i>first</i> 或 <i>last</i>
        指定的歷史行數超出了範圍。如果給出了
        <b>-e</b>
        選項，返回值是最後執行的命令的返回值，或着是失敗，如果臨時文件中的命令
        執行出錯。如果使用第二種形式，返回狀態是重新執行的命令，除非
        <i>cmd</i>
        沒有指定一個有效的歷史行，這種情況下
        <b>fc</b> 返回失敗。</p>
  </dd>
  <dt><b>fg</b> [<i>jobspec</i>]</dt>
  <dd>將 <i>jobspec</i>
      恢復至前臺，使它成爲當前作業。如果
      <i>jobspec</i> 不存在，將使用
      shell 意義上的當前作業
      <i>current job</i>。返回值是
      被放到前臺的命令的狀態，或者是失敗，如果在禁用作業控制時運行，或者
      在啓用作業控制時運行，但
      <i>jobspec</i>
      沒有指定有效的作業，或
      <i>jobspec</i>
      指定了沒有使用作業控制的作業。</dd>
  <dt><b>getopts</b> <i>optstring</i> <i>name</i> [<i>args</i>]</dt>
  <dd><b>getopts</b> 由 shell
      程序用來處理位置參數。
      <i>optstring</i>
      包含要識別的選項字符；如果某個字符跟隨着冒號，那麼這個選項需要一個參數，
      需要用空白和它隔離開。冒號和問號字符不能用作選項字符。每次它執行時，
      <b>getopts</b>
      將下一個選項放在 shell
      變量 <i>name</i> 中，如果 <i>name</i>
      不存在就初始化它；下一個要處理的參數的索引放在變量
      <b>OPTIND</b> 中。每次 shell 或 shell
      腳本被執行的時候
      <small><b>OPTIND</b></small> 被初始化爲
      1。當某個選項需要參數時，
      <b>getopts</b>
      將那個參數放到變量
      <b>OPTARG</b> 中。shell
      不會自動重置
      <small><b>OPTIND；</b></small> 在相同的
      shell
      中，如果要使用新的參數集合而需要多次調用
      <b>getopts</b>
      時，必須手動重置它。
    <p class="Pp">當遇到選項結束的時候，<b>getopts</b>
        以大於 0 的值退出。
        <b>OPTIND</b>
        被設置爲第一個非選項的參數的索引，<i>name</i>
        被設置爲 ?。</p>
    <p class="Pp"><b>getopts</b>
        通常解釋位置參數，但是如果
        <i>args</i>
        中給出了更多參數，
        <b>getopts</b> 將解釋它們。</p>
    <p class="Pp"><b>getopts</b>
        能以兩種方式報告錯誤。如果
        <i>optstring</i>
        的第一個字符是冒號，將使用
        <i>silent</i>
        安靜的錯誤報告。通常的操作中，遇到非法選項或缺少選項的參數時將打印出
        診斷信息。如果變量
        <small><b>OPTERR</b></small> 被設置爲
        0，不會顯示錯誤消息，即使
        <i>optstring</i>
        的第一個字符不是冒號。</p>
    <p class="Pp">如果發現了一個非法的選項，
        <b>getopts</b> 向 <i>name</i> 中置入
        ?，並且如果不是安靜模式的話，打印錯誤消息並取消
        <b>OPTARG</b> 的定義。如果
        <b>getopts</b>
        是安靜模式，找到的選項字符將置入
        <small><b>OPTARG，</b></small>
        不會打印診斷消息。</p>
    <p class="Pp">如果沒有找到需要的參數，並且
        <b>getopts</b>
        不是安靜模式，將向
        <i>name</i> 置入一個問號
        (<b>?</b>)，取消 <small><b>OPTARG</b></small>
        的定義，打印出診斷消息。如果
        <b>getopts</b>
        是安靜模式，那麼將向
        <i>name</i> 置入一個冒號 (<b>:</b>)
        並且 <small><b>OPTARG</b></small>
        將設置爲找到的選項字符。</p>
    <p class="Pp"><b>getopts</b>
        返回真，如果找到了指定的/未被指定的選項。它返回假，如果遇到了選項結束
        或者發生了錯誤。</p>
  </dd>
  <dt><b>hash</b> [<b>-lr</b>] [<b>-p</b> <i>filename</i>] [<b>-dt</b>]
    [<i>name</i>]</dt>
  <dd>對於每個 <i>name</i>,
      通過搜索 <b>$PATH</b>
      中的目錄，找到命令的全路徑名並記錄它。如果給出了
      <b>-p</b>
      選項，不會進行路徑搜索，直接將
      <i>filename</i>
      作爲命令的全路徑名。選項
      <b>-r</b> 使得 shell
      忘記所有已記錄的位置。選項
      <b>-d</b> 使得 shell
      忘記已記錄的 <i>name</i>
      的位置。如果給出了
      <b>-t</b> 選項，每個 <i>name</i>
      對應的全路徑名被打印出來。如果給出多個
      <i>name</i> 作爲 <b>-t</b>
      的參數，<i>name</i>
      將在已記錄的全路徑名
      之前被打印出來。選項
      <b>-l</b>
      使得輸出以一種可以重用爲輸入的格式顯示。如果沒有給出參數，
      或者只給出了 <b>-l</b>
      選項，已記錄的命令的信息將被打印出來。
      返回真，除非 <i>name</i>
      沒有找到或給出了非法的選項。</dd>
  <dt><b>help</b> [<b>-s</b>] [<i>pattern</i>]</dt>
  <dd>顯示關於內建命令的有用的信息。如果指定了
      <i>pattern (模式)，</i> <b>help</b>
      給出關於所有匹配
      <i>pattern</i>
      的命令的詳細幫助；否則所有內建命令的幫助和
      shell
      控制結構將被打印出來。
      選項 <b>-s</b>
      限制信息顯示爲簡短的用法概要。
      返回 0，除非沒有匹配
      <i>pattern</i> 的命令。</dd>
  <dt><b>history [</b><i>n</i><b>]</b></dt>
  <dd></dd>
  <dt><b>history</b> <b>-c</b></dt>
  <dd></dd>
  <dt><b>history -d</b> <i>offset</i></dt>
  <dd></dd>
  <dt><b>history</b> <b>-anrw</b> [<i>filename</i>]</dt>
  <dd></dd>
  <dt><b>history</b> <b>-p</b> <i>arg</i> [<i>arg ...</i>]</dt>
  <dd></dd>
  <dt><b>history</b> <b>-s</b> <i>arg</i> [<i>arg ...</i>]</dt>
  <dd>不帶選項的話，顯示帶行號的命令歷史列表。列出的行中含有
      <b>*</b>
      的已經被修改過。參數
      <i>n</i> 使得只顯示最後 <i>n</i>
      行。如果給出了
      <i>filename</i>，它被用做歷史文件名；沒有的話，將使用
      <small><b>HISTFILE</b></small>
      的值作爲歷史文件名。選項如果給出，則具有下列意義：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-c</b></dt>
  <dd>清空歷史列表，刪除所有條目。</dd>
  <dt><b>-d</b> <i>offset</i></dt>
  <dd>刪除 <i>offset</i>
      位置的歷史條目。</dd>
  <dt><b>-a</b></dt>
  <dd>將 ``新&#39;&#39; 的歷史條目
      (自當前 <b>bash</b>
      會話開始輸入的歷史命令)
      追加到歷史文件中。</dd>
  <dt><b>-n</b></dt>
  <dd>將尚未從歷史文件中讀取的歷史條目讀入當前歷史列表。這些行是當前
      <b>bash</b>
      會話開始之後，才追加到歷史文件中的行。</dd>
  <dt><b>-r</b></dt>
  <dd>讀取歷史文件的內容，使用它們作爲當前歷史。</dd>
  <dt><b>-w</b></dt>
  <dd>將當前歷史列表寫入歷史文件，覆蓋歷史文件的原有內容。</dd>
  <dt><b>-p</b></dt>
  <dd>對後續的 <i>args</i>
      進行歷史替換，在標準輸出上顯示結果。
      不會將結果存入歷史列表。每個
      <i>args</i>
      都必須被引用，來禁止
      普通的命令擴展。</dd>
  <dt><b>-s</b></dt>
  <dd>將 <i>args</i>
      保存到歷史列表中，作爲單獨的條目。歷史列表中的最後一個命令在添加
      <i>args</i> 之前被刪除。</dd>
</dl>
<p class="Pp">返回
    0，除非遇到了非法的選項，讀/寫歷史文件發生錯誤，在
    <b>-d</b> 的
    參數中給出了無效的
    <i>offset</i>，或者對 <b>-p</b>
    的後續參數進行歷史擴展失敗。</p>
</div>
<dl class="Bl-tag">
  <dt><b>jobs</b> [<b>-lnprs</b>] [ <i>jobspec</i> ... ]</dt>
  <dd></dd>
  <dt><b>jobs</b> <b>-x</b> <i>command</i> [ <i>args</i> ... ]</dt>
  <dd>第一種形式列出正在運行的作業。選項具有下列意義：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-l</b></dt>
  <dd>普通信息之外，列出進程ID。</dd>
  <dt><b>-p</b></dt>
  <dd>只列出作業的進程組
      leader 的進程ID。</dd>
  <dt><b>-n</b></dt>
  <dd>只顯示從上次用戶得知它們的狀態之後，狀態發生改變的作業的信息。</dd>
  <dt><b>-r</b></dt>
  <dd>限制只輸出正在運行的作業。</dd>
  <dt><b>-s</b></dt>
  <dd>限制只輸出停止的作業。</dd>
</dl>
<p class="Pp">如果給出了 <i>jobspec</i>
    輸出被限制爲僅此作業的信息。
    返回
    0，除非遇到了非法的選項或給出了非法的
    <i>jobspec。</i></p>
<p class="Pp">如果給出了 <b>-x</b>
    選項，作業 <b>jobs</b> 將 <i>command</i>
    或 <i>args</i> 中的任何 <i>jobspec</i>
    替換爲相應的進程組ID，執行
    <i>command，</i> 傳遞參數 <i>args</i>
    給它並返回它的退出狀態。</p>
</div>
<dl class="Bl-tag">
  <dt><b>kill</b> [<b>-s</b> <i>sigspec</i> | <b>-n</b> <i>signum</i> |
    <b>-</b><i>sigspec</i>] [<i>pid</i> | <i>jobspec</i>] ...</dt>
  <dd></dd>
  <dt><b>kill</b> <b>-l</b> [<i>sigspec</i> | <i>exit_status</i>]</dt>
  <dd>向以 <i>pid</i> 或 <i>jobspec</i>
      爲名的進程發送名爲
      <i>sigspec</i> 或 <i>signum</i> 的信號。
      <i>sigspec</i>
      可以是一個信號名稱，類似
      <small><b>SIGKILL</b></small>
      或信號編號； <i>signum</i>
      是一個信號編號。如果
      <i>sigspec</i>
      是一個信號名稱，那麼可以有，也可以沒有
      <small><b>SIG</b></small>
      前綴。如果沒有給出
      <i>sigspec，</i> 那麼假設是
      <small><b>SIGTERM。</b></small> 參數 <b>-l</b>
      將列出所有信號的名稱。如果給出
      <b>-l</b>
      時還有任何參數，將列出參數對應的信號名稱，返回狀態
      0。 <b>-l</b> 的 <i>exit_status</i>
      參數是一個數字，指定了一個信號編號或被信號
      終止的進程的退出狀態值。
      <b>kill</b>
      返回真，如果至少成功發送了一個信號，或者返回假，如果發生了錯誤或遇到了
      非法的選項。</dd>
  <dt><b>let</b> <i>arg</i> [<i>arg</i> ...]</dt>
  <dd>每個 <i>arg</i>
      都是要求值的算術表達式
      (參見 <b>算術求值 (ARITHMETIC
      EVALUATION)</b>
      章節)。如果最後一個參數
      <i>arg</i> 求值結果是 0， <b>let</b>
      返回 1；否則返回 0。</dd>
  <dt><b>local</b> [<i>option</i>] [<i>name</i>[=<i>value</i>] ...]</dt>
  <dd>對每個參數將創建一個名爲
      <i>name</i>
      的局部變量並賦予值
      <i>value。</i> <i>option</i>
      可以是任何 <b>declare</b>
      接受的值。當 <b>local</b>
      用於函數內部時，它使得變量
      <i>name</i>
      作用域侷限於函數和它的子進程。沒有操作數時，
      <b>local</b>
      將局部變量的列表寫到標準輸出。不在函數內部使用
      <b>local</b>
      會導致出錯。返回
      0，除非在函數之外使用了
      <b>local，</b> 給出了非法的
      <i>name，</i> 或者 <i>name</i>
      是一個只讀的變量。</dd>
  <dt><b>logout</b></dt>
  <dd>退出登錄 shell。</dd>
  <dt><b>popd</b> [-<b>n</b>] [+<i>n</i>] [-<i>n</i>]</dt>
  <dd>從目錄棧中刪除條目。沒有參數的話，從棧中刪除頂層目錄，執行
      <b>cd</b>
      切換到新的頂層目錄。如果給出了參數，有下列的含義：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>+</b><i>n</i></dt>
  <dd>刪除 <b>dirs</b>
      給出的列表中從左數第
      <i>n</i> 個條目 (從 0
      算起)。例如： ``popd +0&#39;&#39;
      刪除第一個目錄， ``popd
      +1&#39;&#39; 第二個。</dd>
  <dt><b>-</b><i>n</i></dt>
  <dd>刪除 <b>dirs</b>
      給出的列表中從右數第
      <i>n</i> 個條目 (從 0
      算起)。例如： ``popd -0&#39;&#39;
      刪除最後一個目錄，
      ``popd -1&#39;&#39;
      刪除倒數第二個。</dd>
  <dt><b>-n</b></dt>
  <dd>阻止從棧中刪除目錄之後改變目錄，這時只對棧進行操作。</dd>
</dl>
<p class="Pp">如果命令 <b>popd</b>
    成功，還要執行一個
    <b>dirs，</b> 返回 0。 <b>popd</b>
    返回假，如果遇到了非法的選項，目錄棧爲空，指定了目錄棧中不存在的條目，
    或者改變目錄失敗。</p>
</div>
<dl class="Bl-tag">
  <dt><b>printf</b> <i>format</i> [<i>arguments</i>]</dt>
  <dd>在 <i>format</i>
      控制下將格式化的
      <i>arguments</i> 寫到標準輸出。
      <i>format</i>
      是一個字符串，包含三種類型的對象：普通字符，被簡單地
      複製到標準輸出，轉義字符，被轉換並複製到標準輸出，格式說明，每一個
      都使得相鄰的下一個
      <i>argument</i> 被打印出來。
      在標準的 <a href="../../buster/manpages-zh/printf.1.zh_TW.html">printf(1)</a>
      格式之外，<b>%b</b> 使得
      <b>printf</b> 展開相應 <i>arguments</i>
      中的反斜槓轉義序列，<b>%q</b>
      使得 <b>printf</b> 將 相應的
      <i>argument</i>
      以一種可以重用爲 shell
      輸入的格式輸出。
    <p class="Pp"><i>format</i>
        在需要時被重用，以處理所有的
        <i>arguments</i>。 如果 <i>format</i>
        需要比所提供的更多的
        <i>arguments</i>，
        多出的格式說明視爲已經提供了相應的
        0 值或空字符串。
        成功的話返回值是
        0，失敗則是非 0 值。</p>
  </dd>
  <dt><b>pushd</b> [<b>-n</b>] [<i>dir</i>]</dt>
  <dd></dd>
  <dt><b>pushd</b> [<b>-n</b>] [+<i>n</i>] [-<i>n</i>]</dt>
  <dd>將目錄推入目錄棧，或者輪換棧中的內容，使棧的頂部成爲當前工作目錄。
      沒有參數時，交換頂部兩個目錄，返回
      0，除非目錄棧爲空。如果給出了參數，
      它們有如下含義：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>+</b><i>n</i></dt>
  <dd>輪換棧中內容，使得
      <b>dirs</b>
      給出的列表中從左數第
      <i>n</i> 個目錄 (從 0 數起)
      成爲目錄棧的頂部。</dd>
  <dt><b>-</b><i>n</i></dt>
  <dd>輪換棧中內容，使得
      <b>dirs</b>
      給出的列表中從右數第
      <i>n</i> 個目錄 (從 0 數起)
      成爲目錄棧的頂部。</dd>
  <dt><b>-n</b></dt>
  <dd>阻止向棧中添加目錄之後改變目錄，這時只對棧進行操作。</dd>
  <dt><i>dir</i></dt>
  <dd>添加 <i>dir</i>
      到棧頂，使得它成爲新的當前工作目錄。</dd>
</dl>
<p class="Pp">如果命令 <b>pushd</b>
    成功，還要執行一個
    <b>dirs。</b>
    如果使用第一種形式，
    <b>pushd</b> 返回 0，除非 cd
    切換到目錄 <i>dir</i>
    失敗。使用第二中形式時，
    <b>pushd</b> 返回
    0，除非目錄棧爲空，指定了目錄棧中不存在的元素，或者
    切換到指定的新的當前目錄失敗。</p>
</div>
<dl class="Bl-tag">
  <dt><b>pwd</b> [<b>-LP</b>]</dt>
  <dd>打印當前工作目錄的絕對路徑名。如果給出了
      <b>-P</b>
      選項，或者設置了內建命令
      <b>set</b> 的 <b>-o physical</b>
      選項，打印出的路徑名中不會包含符號鏈接。如果使用了
      <b>-L</b>
      選項，打印出的路徑中可能包含符號鏈接。
      返回
      0，除非在讀取當前目錄名時出錯或給出了非法的選項。</dd>
  <dt><b>read</b> [<b>-ers</b>] [<b>-u</b> <i>fd</i>] [<b>-t</b> <i>timeout</i>]
    [<b>-a</b> <i>aname</i>] [<b>-p</b> <i>prompt</i>] [<b>-n</b> <i>nchars</i>]
    [<b>-d</b> <i>delim</i>] [<i>name</i> ...]</dt>
  <dd>從標準輸入讀入一行，或從
      <b>-u</b>
      選項的參數中給出的文件描述符
      <i>fd</i> 中
      讀取，第一個詞被賦予第一個
      <i>name</i>,
      第二個詞被賦予第二個
      <i>name</i>,
      以此類推，多餘的詞和其間的分隔符被賦予最後一個
      <i>name</i>.
      如果從輸入流讀入的詞數比名稱數少，剩餘的名稱被賦予空值。
      <small><b>IFS</b></small>
      中的字符被用來將行拆分成詞。
      反斜槓字符 (<b>\</b>)
      被用於刪除讀取的下一字符的特殊含義，以及續行。
      如果給出了選項，將包含下列含義：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-a <i>aname</i></b></dt>
  <dd>詞被賦以數組變量
      <i>aname</i>
      的連續的下標，從 0
      開始。在賦新值之前，
      <i>aname</i>
      被取消定義。其他
      <i>name</i> 參數被忽略。</dd>
  <dt><b>-d <i>delim</i></b></dt>
  <dd><i>delim</i>
      的第一個字符被用於結束輸入行，而不是新行符。</dd>
  <dt><b>-e</b></dt>
  <dd>如果標準輸入來自終端，將使用
      <b>readline</b> (參見上面的
      <small><b>READLINE</b></small> 章節)
      來獲得輸入行。</dd>
  <dt><b>-n <i>nchars</i></b></dt>
  <dd><b>read</b> 讀入 <i>nchars</i>
      個字符後返回，而不是等待一整行輸入。</dd>
  <dt><b>-p <i>prompt</i></b></dt>
  <dd>讀取任何輸入之前，在標準錯誤顯示提示
      <i>prompt</i>，末尾沒有新行符。
      提示只有在輸入來自終端時纔會顯示。</dd>
  <dt><b>-r</b></dt>
  <dd>反斜槓不作爲轉義字符。反斜槓被認爲行的一部分。特殊地，一對反斜槓-新行符不作爲續行。</dd>
  <dt><b>-s</b></dt>
  <dd>安靜模式。如果輸入來自終端，字符將不會回顯。</dd>
  <dt><b>-t <i>timeout</i></b></dt>
  <dd>使得 <b>read</b>
      超時並返回失敗，如果在
      <i>timeout</i>
      秒內沒有讀入完整的一行輸入。
      如果 <b>read</b>
      不是從終端或管道讀取輸入，那麼這個選項無效。</dd>
  <dt><b>-u <i>fd</i></b></dt>
  <dd>從文件描述符 <i>fd</i>
      中讀取輸入。</dd>
</dl>
<p class="Pp">如果沒有給出
    <i>names，</i>
    讀取的一行將賦予變量
    <b>REPLY</b>。 返回值是
    0，除非遇到了 EOF，<b>readP
    超時，或給出了非法的文件描述符作爲
    </b> <b>-u</b><b> 的參數。</b></p>
</div>
<dl class="Bl-tag">
  <dt><b>readonly</b> [<b>-apf</b>] [<i>name</i> ...]</dt>
  <dd>給出的 <i>name</i>
      將被標記爲只讀的；
      <i>names</i>
      的值不能被後來的賦值語句改變。如果給出了
      <b>-f</b> 選項，<i>names</i>
      對應的函數也被標記。選項
      <b>-a</b>
      限制變量只能是數組類型。如果沒有給出
      <i>name</i>
      參數，或者如果給出了
      <b>-p</b>
      選項，將打印所有隻讀的名稱。選項
      <b>-p</b>
      使得輸出以一種可以被重新用作輸入的格式顯示。
      返回值是
      0，除非遇到了非法的選項，
      <i>names</i> 之一不是有效的
      shell 變量名，或選項 <b>-f</b>
      中給出的 <i>name</i>
      不是一個函數。</dd>
  <dt><b>return</b> [<i>n</i>]</dt>
  <dd>使得一個函數以指定值
      <i>n</i> 退出。如果忽略了
      <i>n，</i>
      返回狀態是函數體中執行的最後一個命令的退出狀態。如果在函數外使用，但是是在一個以
      <b>.</b> (<b>source</b>)
      命令執行的腳本內，它使得
      shell
      中止執行腳本，返回
      <i>n</i>
      或腳本中執行的最後一個命令的退出狀態。如果在函數外使用，並且不是在以
      <b>.</b>
      執行的腳本內，返回狀態是假。</dd>
  <dt><b>set</b> [<b>--abefhkmnptuvxBCHP</b>] [<b>-o</b> <i>option</i>]
    [<i>arg</i> ...]</dt>
  <dd>不帶選項時，shell
      變量的名稱和值將以一種可以重用爲輸入的格式顯示。
      輸出根據當前語言環境進行排序。指定了選項的時候，它們設置或取消了
      shell 的屬性。
      處理完選項之後剩餘的任何參數都被作爲位置參數的值被賦值，分別賦予
      <b>$1</b>, <b>$2</b>, <b>...</b> <b>$<i>n</i></b>.
      如果給出了選項，那麼具有以下含義：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-a</b></dt>
  <dd>自動將被修改或創建的變量和函數標誌爲導出至後續命令的環境中。</dd>
  <dt><b>-b</b></dt>
  <dd>後臺作業結束時立即報告狀態，而不是在下次顯示主提示符前報告。只有在啓用作業控制時纔有效。</dd>
  <dt><b>-e</b></dt>
  <dd>立即退出，如果 <i>simple
      command</i>
      (簡單命令，參見上面的
      <small><b>SHELL GRAMMAR 語法)</b></small>
      以非零值退出。shell
      不會退出，如果失敗的命令是
      <i>until</i> 或 <i>while</i>
      循環的一部分， <i>if</i>
      語句的一部分， <b>&amp;&amp;</b>
      或 <b>⎪⎪</b>
      序列的一部分，或者命令的返回值是由
      <b>!</b> 翻轉得到。針對
      <b>ERR</b>
      的陷阱，如果設置的話，將在
      shell 退出前執行。</dd>
  <dt><b>-f</b></dt>
  <dd>禁止路徑擴展。</dd>
  <dt><b>-h</b></dt>
  <dd>在查找並執行命令時，記住它們的位置。這是默認啓用的。</dd>
  <dt><b>-k</b></dt>
  <dd>所有以賦值語句形式出現的參數都被加入到命令執行的環境中，不僅是命令名前面那些。</dd>
  <dt><b>-m</b></dt>
  <dd>監視模式。作業控制被啓用。在支持這個選項的系統中，它在交互
      shell 中是默認啓用的
      (參見上面的 <small><b>JOB CONTROL
      作業控制)。</b></small>
      後臺進程在單獨的進程組中運行，結束時將打印出包含它們退出狀態的一行信息。</dd>
  <dt><b>-n</b></dt>
  <dd>讀取命令，但不執行。這可以用在檢查
      shell
      腳本中的語法錯誤。交互
      shell 中它被忽略。</dd>
  <dt><b>-o <i>option-name</i></b></dt>
  <dd><i>option-name</i>
      可以是如下之一：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>allexport</b></dt>
  <dd>與 <b>-a</b> 相同。</dd>
  <dt><b>braceexpand</b></dt>
  <dd>與 <b>-B</b> 相同。</dd>
  <dt><b>emacs</b></dt>
  <dd>使用 emacs
      樣式的命令行編輯界面。這個選項在交互
      shell 中默認啓用，除非
      shell 以 <b>--noediting</b>
    選項啓動。</dd>
  <dt><b>errexit</b></dt>
  <dd>與 <b>-e</b> 相同。</dd>
  <dt><b>hashall</b></dt>
  <dd>與 <b>-h</b> 相同。</dd>
  <dt><b>histexpand</b></dt>
  <dd>與 <b>-H</b> 相同。</dd>
  <dt><b>history</b></dt>
  <dd>允許記錄命令歷史，如上述
      <b>HISTORY</b>
      中的描述。這個選項在交互
      shell 中默認啓用。</dd>
  <dt><b>ignoreeof</b></dt>
  <dd>它的效果是好像已經執行了
      shell 命令 ``IGNOREEOF=10&#39;&#39; 一樣
      (參見上面的 <b>Shell Variables
      變量)。</b></dd>
  <dt><b>keyword</b></dt>
  <dd>與 <b>-k</b> 相同。</dd>
  <dt><b>monitor</b></dt>
  <dd>與 <b>-m</b> 相同。</dd>
  <dt><b>noclobber</b></dt>
  <dd>與 <b>-C</b> 相同。</dd>
  <dt><b>noexec</b></dt>
  <dd>與 <b>-n</b> 相同。</dd>
  <dt><b>noglob</b></dt>
  <dd>與 <b>-f</b> 相同。 <b>nolog</b>
      當前被忽略。</dd>
  <dt><b>notify</b></dt>
  <dd>與 <b>-b</b> 相同。</dd>
  <dt><b>nounset</b></dt>
  <dd>與 <b>-u</b> 相同。</dd>
  <dt><b>onecmd</b></dt>
  <dd>與 <b>-t</b> 相同。</dd>
  <dt><b>physical</b></dt>
  <dd>與 <b>-P</b> 相同。</dd>
  <dt><b>posix</b></dt>
  <dd>如果默認操作與 POSIX 1003.2
      不同的話，改變 <b>bash</b>
      的行爲，來滿足標準
      (<i>posix mode</i>)。</dd>
  <dt><b>privileged</b></dt>
  <dd>與 <b>-p</b> 相同。</dd>
  <dt><b>verbose</b></dt>
  <dd>與 <b>-v</b> 相同。</dd>
  <dt><b>vi</b></dt>
  <dd>使用 vi
      樣式的命令行編輯界面。</dd>
  <dt><b>xtrace</b></dt>
  <dd>與 <b>-x</b> 相同。
    <p class="Pp"></p>
  </dd>
</dl>
<p class="Pp">如果給出了不帶
    <i>option-name</i> 的 <b>-o</b>
    選項，當前選項的值將被打印出來。如果給出了不帶
    <i>option-name</i> 的 <b>+o</b>
    選項，將在標準輸出顯示一系列可以重建當前選項設定的
    <b>set</b> 命令。</p>
</div>
<dl class="Bl-tag">
  <dt><b>-p</b></dt>
  <dd>打開 <i>privileged mode
      (特權模式)。</i>
      在這個模式中，不會處理
      <small><b>$ENV</b></small> 和 <small><b>$BASH_ENV</b></small>
      文件，shell
      函數不會從環境中繼承，環境中如果有變量
      <small><b>SHELLOPTS，</b></small>
      也將被忽略。如果 shell
      啓動時的有效用戶(組)
      ID 與真實用戶(組) ID
      不同，並且沒有給出
      <b>-p</b> 選項，
      將執行這些操作，有效用戶
      ID 將設置爲真實用戶
      ID。如果啓動是給出了
      <b>-p</b> 選項，有效用戶 ID
      不會
      被重置。將這個選項關閉使得有效用戶和組
      ID
      被設置爲真實用戶和組
      ID。</dd>
  <dt><b>-t</b></dt>
  <dd>讀取並執行一個命令之後退出。</dd>
  <dt><b>-u</b></dt>
  <dd>在進行參數擴展時，將未定義的變量作爲錯誤。如果試圖擴展未定義的變量，shell
      將輸出一條錯誤消息;
      如果是非交互的
      shell，shell
      將以非零值退出。</dd>
  <dt><b>-v</b></dt>
  <dd>在讀取輸入的同時打印出來。</dd>
  <dt><b>-x</b></dt>
  <dd>擴展每個簡單命令之後，顯示
      <b>PS4</b>
      的值，接着顯示命令和它擴展後的參數。</dd>
  <dt><b>-B</b></dt>
  <dd>shell 執行花括號擴展
      (參見上面的 <b>Brace Expansion)。</b>
      這是默認允許的。</dd>
  <dt><b>-C</b></dt>
  <dd>如果設置的話， <b>bash</b>
      使用重定向操作符
      <b>&gt;</b>, <b>&gt;&amp;</b>, 和 <b>&lt;&gt;</b>
      時，不會覆蓋已存在的文件。可以使用重定向操作符
      <b>&gt;|</b> 代替 <b>&gt;</b>
      來創建輸出文件，從而繞過這個限制。</dd>
  <dt><b>-H</b></dt>
  <dd>允許 Enable <b>!</b>
      樣式的歷史替換。在交互
      shell
      中這個選項是默認啓用的。</dd>
  <dt><b>-P</b></dt>
  <dd>如果設置的話，shell
      在執行類似 <b>cd</b>
      的，改變當前工作目錄的命令時，不會跟隨符號連接。它將使用物理的目錄結構來代替。默認情況下，
      <b>bash</b>
      在執行改變當前目錄的命令時跟隨路徑的邏輯鏈。</dd>
  <dt><b>--</b></dt>
  <dd>如果這個選項沒有參數，將取消位置參數的定義。否則，位置參數將設置爲
      <i>arg</i>，即使它們以 <b>-</b>
      開始。</dd>
  <dt><b>-</b></dt>
  <dd>通知信號的結束，使得所有剩餘的
      <i>arg</i>
      被賦予位置參數。 <b>-x</b>
      和 <b>-v</b>
      選項被關閉。如果沒有
      <i>arg</i>，位置參數將不會改變。</dd>
</dl>
<p class="Pp">這個選項默認是關閉的，除非另外說明。使用
    + 而不是 -
    使得這些選項被關閉。選項都可以作爲參數，
    在 shell
    啓動時指定。當前的選項集合可以從
    <b>$-</b>
    找到。返回值總是真，除非遇到了非法的選項。</p>
</div>
<dl class="Bl-tag">
  <dt><b>shift</b> [<i>n</i>]</dt>
  <dd>從 <i>n</i>+1 ...
      開始的選項被重命名爲
      <b>$1</b> <b>....</b> 從 <b>$#</b> 向下直到
      <b>$#</b>-<i>n</i>+1
      的選項被取消定義。
      <i>n</i>
      必須是非負整數，小於或等於
      <b>$#</b>。如果 <i>n</i> 是
      0，不會改變參數。如果沒有給出
      <i>n，</i> 就假定它是
      1。如果 <i>n</i> 比 <b>$#</b>
      大，位置參數不會改變。返回值大於
      0，如果 <i>n</i> 比 <b>$#</b>
      大或小於 0；否則返回
      0。</dd>
  <dt><b>shopt</b> [<b>-pqsu</b>] [<b>-o</b>] [<i>optname</i> ...]</dt>
  <dd>對於控制可選的 shell
      行爲的變量，改變它們的值。沒有選項或者有
      <b>-p</b>
      選項時，將顯示所有可設置的選項列表，以及它們是否已經設置的指示。
      <b>-p</b>
      使得輸出以一種可以被重用爲輸入的形式顯示。
      其他選項有如下含義：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-s</b></dt>
  <dd>允許(設置) 每個
    <i>optname</i>。</dd>
  <dt><b>-u</b></dt>
  <dd>禁止(取消) 每個
    <i>optname</i>。</dd>
  <dt><b>-q</b></dt>
  <dd>禁止通常的輸出
      (安靜模式)；返回狀態指示了
      <i>optname</i> 是否被設置。
      如果對 <b>-q</b>
      給出了多個 <i>optname</i>
      參數，如果所有 <i>optname</i>
      都被允許，返回值就是
      0；
    否則返回非零值。</dd>
  <dt><b>-o</b></dt>
  <dd>限制 <i>optname</i>
      的值爲內建命令 <b>set</b>
      的 <b>-o</b>
      選項定義的值。</dd>
</dl>
<p class="Pp">如果使用 <b>-s</b> 或 <b>-u</b>
    時沒有給出 <i>optname</i>
    參數，顯示將分別限於被設置或被取消的選項。
    除非另外說明，<b>shopt</b>
    選項默認被禁止(取消)。</p>
<p class="Pp">返回值在列出選項時是
    0，如果所有 <i>optname</i>
    都被允許的話，否則是非零值。
    當設置或取消選項時，返回值是
    0，除非 <i>optname</i> 是非法的
    shell 選項。</p>
<p class="Pp"><b>shopt</b>
    選項的列表是：</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>cdable_vars</b></dt>
  <dd>如果設置的話，內建命令
      <b>cd</b>
      的參數如果不是目錄，就假定是一個變量，它的值是要切換到的目錄名。</dd>
  <dt><b>cdspell</b></dt>
  <dd>如果設置的話， <b>cd</b>
      命令中目錄的細微拼寫錯誤能夠得以糾正。檢查的錯誤包括字符錯位，缺字符，
      重複輸入同一字符。如果找到了正確的值，將打印正確的文件名，命令將繼續。
      這個選項只能在交互
      shell 中使用。</dd>
  <dt><b>checkhash</b></dt>
  <dd>如果設置的話，<b>bash</b>
      在執行命令前檢測散列表中的命令是否存在。
      如果一個被散列的命令不再存在，將進行正常的路徑搜索。</dd>
  <dt><b>checkwinsize</b></dt>
  <dd>如果設置的話，<b>bash</b>
      在每條命令執行後檢測窗口大小，如果需要的話就更新
      <small><b>LINES</b></small> 和 <b>COLUMNS</b>
      的值。</dd>
  <dt><b>cmdhist</b></dt>
  <dd>如果設置的話， <b>bash</b>
      試着將一個多行命令的所有行放到同一個歷史條目中。這樣使得
      多行命令可以容易地重新修改。</dd>
  <dt><b>dotglob</b></dt>
  <dd>如果設置的話， <b>bash</b>
      會把以 `.&#39;
      開始的文件名包含在路徑名擴展的結果中。</dd>
  <dt><b>execfail</b></dt>
  <dd>如果設置的話，非交互的
      shell
      如果不能執行作爲參數提供給內建命令
      <b>exec</b>
      的文件時將不會退出。交互的
      shell 在 <b>exec</b>
      失敗時不會退出。</dd>
  <dt><b>expand_aliases</b></dt>
  <dd>如果設置的話，別名被擴展，就像上面
      <b>ALIASES</b>
      中講到的一樣。這個選項在交互
      shell
    中是默認啓用的。</dd>
  <dt><b>extglob</b></dt>
  <dd>如果設置的話，將允許上面
      <b>Pathname Expansion</b>
      中提到的擴展模式匹配特性。</dd>
  <dt><b>histappend</b></dt>
  <dd>如果設置的話，在 shell
      退出時，歷史列表將追加到以
      <b>HISTFILE</b>
      的值爲名的文件之後，而不是覆蓋文件。</dd>
  <dt><b>histreedit</b></dt>
  <dd>如果設置的話，並且正在使用
      <b>readline，</b>
      用戶可以重新修改失敗的歷史替換。</dd>
  <dt><b>histverify</b></dt>
  <dd>如果設置的話，並且正在使用
      <b>readline，</b>
      歷史替換的結果不會立即傳給
      shell
      解釋器。結果行被加載到
      <b>readline</b>
      編輯緩衝區，允許進行進一步的修改。</dd>
  <dt><b>hostcomplete</b></dt>
  <dd>如果設置的話，並且正在使用
      <b>readline，</b> <b>bash</b>
      將試着對正在進行補全的包含
      <b>
      的詞進行主機名補全</b>
      <b>(參見上面的</b>
      <small><b>READLINE</b></small> 中的 <b>Completing</b>
      段落)。這是默認允許的。</dd>
  <dt><b>huponexit</b></dt>
  <dd>如果設置的話，在交互的登錄
      shell 退出時 <b>bash</b>
      將向所有作業發出
      <small><b>SIGHUP</b></small> 信號。</dd>
  <dt><b>interactive_comments</b></dt>
  <dd>如果設置的話，將允許在交互
      shell 中遇到以 <b>#</b>
      開頭的詞時忽略這個詞和一行中所有剩餘的字符
      (參見上面的 <small><b>COMMENTS
      註釋)。</b></small>
      這個選項是默認允許的。</dd>
  <dt><b>lithist</b></dt>
  <dd>如果設置的話，並且允許了
      <b>cmdhist</b>
      選項，多行的命令在保存到歷史中時將包含新行符，而不是在可能的地方使用分號。</dd>
  <dt><b>login_shell</b></dt>
  <dd>如果 shell 作爲登錄 shell
      啓動，將設置這個選項
      (參見上面的
      <small><b>啓動(INVOCATION) )。</b></small>
      這個值不可修改。</dd>
  <dt><b>mailwarn</b></dt>
  <dd>如果設置的話，並且
      <b>bash</b>
      正在檢測上次檢測以來被存取過的郵件，
      將顯示 ``The mail in <i>mailfile</i> has been
      read&#39;&#39;(<i>mailfile</i>
      中的郵件已被讀取)。</dd>
  <dt><b>no_empty_cmd_completion</b></dt>
  <dd>如果設置的話，並且正在使用
      <b>readline，</b>
      試圖在空行上執行補全時，
      <b>bash</b> 不會搜索 <b>PATH</b>
      來查找可能的補全。</dd>
  <dt><b>nocaseglob</b></dt>
  <dd>如果設置的話， <b>bash</b>
      進行路徑擴展時使用大小寫不敏感方式匹配文件名(參見上面的
      <b>Pathname Expansion 路徑擴展)。</b></dd>
  <dt><b>nullglob</b></dt>
  <dd>如果設置的話， <b>bash</b>
      將允許不匹配任何文件的模式擴展爲空字符串而不是它們自身(參見上面的
      <b>Pathname Expansion 路徑擴展)。</b></dd>
  <dt><b>progcomp</b></dt>
  <dd>如果設置的話，將啓用可編程補全功能
      (參見上面的 <b>Programmable
      Completion</b>)。
      這個選項是默認啓用的。</dd>
  <dt><b>promptvars</b></dt>
  <dd>如果設置的話，提示字符串要經過上面
      <small><b>PROMPTING</b></small>
      中描述的擴展，然後還要經過變量和參數擴展。這個選項是默認啓用的。</dd>
  <dt><b>restricted_shell</b></dt>
  <dd>shell
      設置這個選項，如果它是以受限模式啓用的
      (參見下面的
      <small><b>受限的shell(RESTRICTED SHELL)</b></small>
      章節)。這個值不能修改。在執行啓動文件時，它不會被重置，使得啓動文件可以
      得知 shell
      是否是受限的。</dd>
  <dt><b>shift_verbose</b></dt>
  <dd>如果設置的話，內建命令
      <b>shift</b>
      在偏移量超過位置參數的個數時打印一條錯誤消息。</dd>
  <dt><b>sourcepath</b></dt>
  <dd>如果設置的話，內建命令
      <b>source</b> (<b>.</b>) 使用 <small><b>PATH</b></small>
      中的值來查找包含作爲參數給出的文件。這個選項默認是啓用的。</dd>
  <dt><b>xpg_echo</b></dt>
  <dd>如果設置的話，內建命令
      <b>echo</b>
      默認擴展反斜槓轉義序列。</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>suspend</b> [<b>-f</b>]</dt>
  <dd>掛起 shell
      的執行，直到收到一個
      <small><b>SIGCONT</b></small> 信號。選項
      <b>-f</b>
      表示如果這是一個登錄
      shell，那麼不要提示，直接掛起。返回值是
      0，除非 shell 是登錄 shell
      並且沒有指定 <b>-f，</b>
      或者沒有啓用作業控制。</dd>
  <dt><b>test</b> <i>expr</i></dt>
  <dd></dd>
  <dt><b>[</b> <i>expr</i> <b>]</b></dt>
  <dd>返回狀態值 0 或
      1，根據條件表達式
      <i>expr</i>
      的求值而定。每個操作符和操作數都必須是一個單獨的參數。表達式使用上面
      <b>條件表達式 (CONDITIONAL EXPRESSIONS)</b>
      中的操作構造。
    <p class="Pp">表達式可以用下列操作符結合，以優先級的降序列出。</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>! <i>expr</i></b></dt>
  <dd>值爲真，如果 <i>expr</i>
      爲假。</dd>
  <dt><b>( <i>expr</i> )</b></dt>
  <dd>返回 <i>expr</i>
      的值。括號可以用來超越操作符的一般優先級。</dd>
  <dt><i>expr1</i> -<b>a</b> <i>expr2</i></dt>
  <dd>值爲真，如果 <i>expr1</i> 和
      <i>expr2</i> 都爲真。</dd>
  <dt><i>expr1</i> -<b>o</b> <i>expr2</i></dt>
  <dd>值爲真，如果 <i>expr1</i> 或
      <i>expr2</i> 爲真。</dd>
</dl>
<p class="Pp"><b>test</b> 和 <b>[</b>
    使用基於參數個數的一系列規則，對條件表達式進行求值。</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt>0 arguments</dt>
  <dd>表達式爲假。</dd>
  <dt>1 argument</dt>
  <dd>表達式爲真，當且僅當參數非空。</dd>
  <dt>2 arguments</dt>
  <dd>如果第一個參數是
      <b>!</b>，表達式爲真，當且僅當第二個參數爲空。
      如果第一個參數是上面
      <b>條件表達式 (CONDITIONAL EXPRESSIONS)</b>
      中列出的單目條件運算符之一，表達式爲真，當且僅當單目測試爲真。
      如果第一個參數不是合法的單目條件運算符，表達式爲假。</dd>
  <dt>3 arguments</dt>
  <dd>如果第二個參數是上面
      <b>條件表達式 (CONDITIONAL EXPRESSIONS)</b>
      中列出的二進制條件操作符之一，表達式的結果是使用第一和第三個參數作爲操作數的二進制測試的結果。
      如果第一個參數是
      <b>!</b>，表達式值是使用第二和第三個參數進行雙參數測試的結果取反。
      如果第一個參數是
      <b>(</b>，第三個參數是
      <b>)</b>，結果是對第二個參數進行單參數測試的結果。
      否則，表達式爲假。這種情況下
      <b>-a</b> 和 <b>-o</b>
      操作符被認爲二進制操作符。</dd>
  <dt>4 arguments</dt>
  <dd>如果第一個參數是
      <b>!</b>，結果是由剩餘參數組成的三參數表達式結果取反。
      否則，表達式被根據上面列出的優先級規則解釋並執行。</dd>
  <dt>5 或更多 arguments</dt>
  <dd>表達式被根據上面列出的優先級規則解釋並執行。</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>times</b></dt>
  <dd>對 shell 以及 shell
      運行的進程，打印累計的用戶和系統時間。
      返回狀態是 0。</dd>
  <dt><b>trap</b> [<b>-lp</b>] [<i>arg</i>] [<i>sigspec</i> ...]</dt>
  <dd>當 shell 收到信號 <i>sigspec</i>
      時，命令 <i>arg</i>
      將被讀取並執行。如果沒有給出
      <i>arg</i> 或者給出的是 <b>-</b>,
      所有指定的信號被設置爲它們的初始值
      (進入 shell
      時它們的值)。如果
      <i>arg</i> 是空字符串， <i>sigspec</i>
      指定的信號被 shell
      和它啓動的命令忽略。如果
      <i>arg</i>
      不存在，並且給出了
      <b>-p</b> 那麼與每個 <i>sigspec</i>
      相關聯的陷阱命令將被顯示出來。如果沒有給出任何參數，或只給出了
      <b>-p，</b> <b>trap</b>
      將打印出與每個信號編號相關的命令列表。每個
      <i>sigspec</i> 可以是 &lt;<i>signal.h</i>&gt;
      定義的信號名，或是一個信號編號。
      如果 <i>sigspec</i> 是 <small><b>EXIT</b></small>
      (0)，命令 <i>arg</i> 將在 shell
      退出時執行。如果
      <i>sigspec</i> 是 <b>DEBUG</b>, 命令 <i>arg</i>
      將在每個簡單命令
      (<i>simple command</i>，參見上面的
      <small><b>SHELL GRAMMAR)</b></small>
      之後執行。如果 <i>sigspec</i>
      是 <b>ERR</b>, 命令 <i>arg</i>
      將在任何命令以非零值退出時執行。如果失敗的命令是
      <i>until</i> 或 <i>while</i>
      循環的一部分， <i>if</i>
      語句的一部分， <b>&amp;&amp;</b>
      或 <b>⎪⎪</b>
      序列的一部分，或者命令的返回值是通過
      <b>!</b> 轉化而來， <b>ERR</b>
      陷阱將不會執行。選項
      <b>-l</b> 使得 shell
      打印信號名和對應編號的列表。
      shell
      忽略的信號不能被捕捉或重置。在子進程中，被捕捉的信號在進程創建時被重置爲初始值。
      返回值爲假，如果
      <i>sigspec</i> 非法；否則 <b>trap</b>
      返回真。</dd>
  <dt><b>type</b> [<b>-aftpP</b>] <i>name</i> [<i>name</i> ...]</dt>
  <dd>沒有選項時，指示每個
      <i>name</i>
      將如何被解釋，如果用作一個命令名。如果使用了
      <b>-t</b> 選項， <b>type</b>
      打印一個字符串，內容是如下之一：
      <i>alias</i>, <i>keyword</i>, <i>function</i>, <i>builtin</i>, 或
      <i>file ，</i> 如果 <i>name</i>
      分別是一個別名，shell
      保留字，函數，內建命令或磁盤文件。如果沒有找到
      <i>name，</i>
      那麼不會打印任何東西，返回退出狀態假。如果使用了
      <b>-p</b> 選項， <b>type</b>
      返回如果 <i>name</i>
      作爲命令名，將被執行的磁盤文件名；或者返回空，如果
      ``type -t name&#39;&#39; 不會返回 <i>file</i>.
      選項 <b>-P</b>
      選項強制對每個 <i>name</i>
      搜索 <small><b>PATH，</b></small> 即使
      ``type -t name&#39;&#39; 不會返回 <i>file</i>.
      如果命令在散列中，
      <b>-p</b> 和 <b>-P</b>
      將打印散列的值，而不是
      <b>PATH</b>
      中首先出現的那一個文件。如果使用了
      <b>-a</b> 選項， <b>type</b>
      打印所有包含可執行的名稱
      <i>name</i>
      的場合。結果包括別名和函數，當且僅當沒有同時使用
      <b>-p</b> 選項。使用 <b>-a</b>
      時不會查找散列中的命令表。選項
      <b>-f</b> 阻止 shell
      進行查找，就像在內建命令
      <b>command</b> 中一樣。 <b>type</b>
      返回真，如果找到了任何參數。什麼都沒找到則返回假。</dd>
  <dt><b>ulimit</b> [<b>-SHacdflmnpstuv</b> [<i>limit</i>]]</dt>
  <dd>在支持它的系統上，對
      shell
      和它啓動的進程，提供對可用資源的控制。
      選項 <b>-H</b> 和 <b>-S</b>
      指定爲所給資源設定的硬性和柔性限額。
      硬性限額在設置後不能增加；柔性限額可以增加，直到與硬性限額相等。
      如果沒有給出 <b>-H</b> 或
      <b>-S</b>
      選項，將同時設置硬性和柔性限額。
      <i>limit</i>
      的值可以是一個數字，單位是指定資源的單元值，或者是特殊值
      <b>hard</b>, <b>soft</b>, 或 <b>unlimited</b>
      之一，意思分別是當前硬性限額，當前柔性限額和沒有限額。如果忽略了
      <i>limit，</i>
      將打印出當前對資源的柔性限額值，除非給出了
      <b>-H</b>
      選項。當指定多於一個
      資源時，限額名稱和單位將在值之前打印出來。其他選項按照如下意義解釋：</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>-a</b></dt>
  <dd>報告所有當前限額</dd>
  <dt><b>-c</b></dt>
  <dd>core 文件的最大值</dd>
  <dt><b>-d</b></dt>
  <dd>進程數據段的最大值</dd>
  <dt><b>-f</b></dt>
  <dd>shell
      創建的文件的最大值</dd>
  <dt><b>-l</b></dt>
  <dd>內存中可以鎖定的最大值</dd>
  <dt><b>-m</b></dt>
  <dd>常駐內存的最大值</dd>
  <dt><b>-n</b></dt>
  <dd>打開的文件描述符最大個數
      (大多數系統不允許設置這個值)</dd>
  <dt><b>-p</b></dt>
  <dd>管道大小，以 512
      字節的塊爲單位
      (這個值可能不能設置)</dd>
  <dt><b>-s</b></dt>
  <dd>棧的最大值</dd>
  <dt><b>-t</b></dt>
  <dd>cpu
      時間總數的最大值，以秒計</dd>
  <dt><b>-u</b></dt>
  <dd>用戶可以運行的最大進程數</dd>
  <dt><b>-v</b></dt>
  <dd>shell
      可用的虛擬內存總量的最大值</dd>
</dl>
<p class="Pp">如果給出了 <i>limit，</i>
    它將是指定資源的新限額
    (選項 <b>-a</b>
    只顯示它們)。如果沒有給出選項，則假設有
    <b>-f。</b> 值的遞增間隔是
    1024 字節，除了 <b>-t</b>
    單位是 秒， <b>-p</b> 單位是
    512 字節的塊個數， <b>-n</b>
    和 <b>-u</b>
    是不可調節的值。返回
    0，除非給出了非法的選項或參數，或者在設置新的限額時發生了錯誤。</p>
</div>
<dl class="Bl-tag">
  <dt><b>umask</b> [<b>-p</b>] [<b>-S</b>] [<i>mode</i>]</dt>
  <dd>用戶創建文件的掩碼被設置爲
      <i>mode</i>. 如果 <i>mode</i>
      以數字開始，它被解釋爲一個八進制數；否則被解釋爲類似於
      <a href="../../buster/manpages-zh/chmod.1.zh_TW.html">chmod(1)</a>
      接受的符號形式的模式掩碼。如果忽略了
      <i>mode，</i>
      將打印當前掩碼值。選項
      <b>-S</b>
      使得掩碼以符號形式打印；默認輸出是八進制數。如果給出了
      <b>-p</b> 選項，並且忽略了
      <i>mode，</i>
      輸出將是一種可以重用爲輸入的形式。返回值是
      0，如果成功改變了模式，或者沒有給出
      <i>mode</i>。
      其他情況返回假。</dd>
  <dt><b>unalias</b> [-<b>a</b>] [<i>name</i> ...]</dt>
  <dd>從已定義的別名列表中刪除
      <i>name</i>。如果給出了 <b>-a</b>
      將刪除所有別名定義。返回值是真，除非給出的
      <i>name</i>
      不是已定義的別名。</dd>
  <dt><b>unset</b> [-<b>fv</b>] [<i>name</i> ...]</dt>
  <dd>將每個 <i>name</i>
      對應的變量或函數刪除。如果沒有給出選項，或者給出了
      <b>-v</b> 選項， <i>name</i> 僅包括
      shell
      變量。只讀的變量不能被取消定義。如果給出了
      <b>-f</b> 選項， <i>name</i> 僅包括
      shell
      函數，函數的定義將被刪除。每個被取消定義的變量或函數都被從後續命令的環境中刪除。
      如果 <b>RANDOM</b>, <b>SECONDS</b>, <b>LINENO</b>,
      <b>HISTCMD</b>, <b>FUNCNAME</b>, <b>GROUPS</b>, 或者
      <small><b>DIRSTACK</b></small>
      中的任何一個被取消定義，它們將喪失特殊的屬性，即使它們後來被重新定義。
      退出狀態是真，除非
      <i>name</i>
      不存在或是隻讀的。</dd>
  <dt><b>wait</b> [<i>n</i>]</dt>
  <dd>等待指定的進程，返回它的終止狀態。
      <i>n</i> 可以是進程 ID
      或一個作業號；如果給出的是作業號，將等待作業的管道中所有進程。如果沒有給出
      <i>n，</i>
      將等待所有當前處於激活狀態的子進程，返回狀態是
      0。如果 <i>n</i>
      指定了不存在的進程或作業，返回狀態是
      127。否則，返回狀態是所等待的最後一個進程或作業的退出狀態。</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="受限的shell(RESTRICTED_SHELL)">受限的shell(RESTRICTED SHELL)<a class="anchor" href="#%E5%8F%97%E9%99%90%E7%9A%84shell(RESTRICTED_SHELL)">¶</a></h1>
如果 <b>bash</b> 以 <b>rbash</b>
  名稱啓動，或者啓動時使用了
  <b>-r</b>
  選項，那麼它成爲受限的
  shell。 受限的 shell
  一般用來建立一個比標準的
  shell
  受到更多控制的環境。
  它的行爲與 <b>bash</b>
  一致，除了下列行爲是不允許的
  (disallowed) 或不會運行的 (not
  performed)。
<ul class="Bl-bullet">
  <li>使用 <b>cd</b>
      來改變路徑；</li>
  <li>設置或取消 <b>SHELL</b>, <b>PATH</b>,
      <b>ENV</b>, 或 <b>BASH_ENV</b>
      變量的值；</li>
  <li>指定的命令名中包含
      <b>/</b> ；</li>
  <li>指定包含 <b>/</b>
      的文件名作爲傳遞給內建命令
      <b>.</b> 的參數；</li>
  <li>指定包含斜槓 (slash)
      的文件名作爲 <b>-p</b>
      選項的參數，傳遞給
      <b>hash</b> 內建命令；</li>
  <li>啓動時從 shell
      環境中導入 (import)
      函數定義；</li>
  <li>啓動時解釋 shell 環境中
      <b>SHELLOPTS</b> 的值；</li>
  <li>使用 &gt;, &gt;|, &lt;&gt;, &gt;&amp;, &amp;&gt;, 和
      &gt;&gt;
      等重定向操作符重定向輸出；</li>
  <li>使用 <b>exec</b>
      內建命令來以另一個命令替換
      shell；</li>
  <li>使用 <b>enable</b> 內建命令的
      <b>-f</b> 和 <b>-d</b>
      選項來增加和刪除內建命令；</li>
  <li>使用 <b>enable</b>
      內建命令來允許和禁止
      shell 內建命令；</li>
  <li>指定 <b>command</b> 內建命令的
      <b>-p</b> 選項；</li>
  <li>使用 <b>set +r</b> 或 <b>set +o restricted</b>
      來關閉受限模式。</li>
</ul>
<p class="Pp">這些限制在所有啓動文件讀取之後纔會生效。</p>
<p class="Pp">當一個 shell
    腳本作爲一個命令執行時
    (參見上面的
    <small><b>命令執行(COMMAND EXECUTION)</b></small>
    章節)， <b>rbash</b>
    關閉爲執行腳本而孵化
    (spawn) 的 shell 的所有限制。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="參見(&#34;SEE_ALSO&#34;)">參見(&#34;SEE ALSO&#34;)<a class="anchor" href="#%E5%8F%83%E8%A6%8B(%22SEE_ALSO%22)">¶</a></h1>
<dl class="Bl-tag">
  <dt><i>Bash Reference Manual</i>, Brian Fox and Chet Ramey</dt>
  <dd></dd>
  <dt><i>The Gnu Readline Library</i>, Brian Fox and Chet Ramey</dt>
  <dd></dd>
  <dt><i>The Gnu History Library</i>, Brian Fox and Chet Ramey</dt>
  <dd></dd>
  <dt><i>Portable Operating System Interface (POSIX) Part 2: Shell and
    Utilities</i>, IEEE</dt>
  <dd></dd>
  <dt><a href="../../buster/dash/sh.1.en.html">sh(1)</a>, <a href="../../buster/mksh/ksh.1.en.html">ksh(1)</a>, <a href="../../buster/tcsh/csh.1.en.html">csh(1)</a></dt>
  <dd></dd>
  <dt><a href="../../buster/manpages-zh/emacs.1.zh_TW.html">emacs(1)</a>, <a href="../../buster/manpages-zh/vi.1.zh_TW.html">vi(1)</a></dt>
  <dd></dd>
  <dt><a href="../../buster/readline-common/readline.3readline.en.html">readline(3)</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="文件(FILES)">文件(FILES)<a class="anchor" href="#%E6%96%87%E4%BB%B6(FILES)">¶</a></h1>
<dl class="Bl-tag">
  <dt><i>/bin/bash</i></dt>
  <dd><b>bash</b> 可執行文件</dd>
  <dt><i>/etc/profile</i></dt>
  <dd>系統範圍的初始化文件，登錄
      shell 會執行它</dd>
  <dt><i>~/.bash_profile</i></dt>
  <dd>個人初始化文件，登錄
      shell 會執行它</dd>
  <dt><i>~/.bashrc</i></dt>
  <dd>個人的每個交互式 shell
      啓動時執行的文件</dd>
  <dt><i>~/.bash_logout</i></dt>
  <dd>個人的登錄 shell
      清理文件，當一個登錄
      shell 退出時會執行它</dd>
  <dt><i>~/.inputrc</i></dt>
  <dd>個人的 <i>readline</i>
      初始化文件</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="作者(AUTHORS)">作者(AUTHORS)<a class="anchor" href="#%E4%BD%9C%E8%80%85(AUTHORS)">¶</a></h1>
Brian Fox, Free Software Foundation
<br/>
bfox@gnu.org
<p class="Pp">Chet Ramey, Case Western Reserve University
  <br/>
  chet@ins.CWRU.Edu</p>
</section>
<section class="Sh">
<h1 class="Sh" id="報告BUGS_(BUG_REPORTS)">報告BUGS (BUG REPORTS)<a class="anchor" href="#%E5%A0%B1%E5%91%8ABUGS_(BUG_REPORTS)">¶</a></h1>
如果你發現一個 <b>bash</b>
  中的
  bug，你應當報告它。但是首先，
  你應當確定它真的是一個
  bug，並且它在你使用的最新版本的
  <b>bash</b> 中存在。
<p class="Pp">一旦你認定存在那樣一個
    bug，使用 <i>bashbug</i>
    命令來提交一個錯誤報告。
    如果你有固定住址，鼓勵你用郵政的方式提交一份！
    建議和有關 <b>bash</b>
    “哲學” (`philosophical&#39;) 的
    “錯誤報告”
    可以寄給 <i>bug-bash@gnu.org</i>
    或者貼到 Usenet 新聞組
    <b>gnu.bash.bug</b> 之上。</p>
<p class="Pp">所有錯誤報告應當包括：</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>bash</b> 的版本號</dt>
  <dd></dd>
  <dt>硬件信息和操作系統</dt>
  <dd></dd>
  <dt>用來編譯的編譯器</dt>
  <dd></dd>
  <dt>對 bug 行爲的描述</dt>
  <dd></dd>
  <dt>可以激活這個 bug
    的一個短小的腳本或者什麼
    “祕訣” (recipe)</dt>
  <dd></dd>
</dl>
<p class="Pp"><i>bashbug</i>
    會自動在它提供的錯誤報告模板中插入前三項。</p>
<p class="Pp">關於這份手冊頁的評論和錯誤報告請直接提交到
    <i>chet@ins.CWRU.Edu</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS">BUGS<a class="anchor" href="#BUGS">¶</a></h1>
它太大了，並且有點慢。
<p class="Pp"><b>bash</b> 和傳統版本的
    <b>sh</b>
    之間有一些細微的差別，大部分是因爲
    <small><b>POSIX</b></small>
  規約的要求。</p>
<p class="Pp">別名機制在一些應用中會混淆。</p>
<p class="Pp">Shell
    內建命令和函數不可終止/重新開始。</p>
<p class="Pp">組合的命令和使用
    `a ; b ; c&#39;
    形式的命令序列在進程試圖暫停時不能很好處理。
    當一個進程中止，shell
    會立即執行序列中的下一條命令。
    也可以將命令的序列放在圓括號中，來強制啓動子
    shell，這樣就可以將它們作爲一個單元中止了。</p>
<p class="Pp">在 <b>$(</b>...<b>)</b>
    命令替換中的註釋不會被解釋，直到執行替換的時候。
    這將延遲報錯，直到命令開始執行之後的一段時間。</p>
<p class="Pp">數組變量還不能導出
    (export)。</p>
</section>
<section class="Sh">
<h1 class="Sh" id="[中文版維護人]">[中文版維護人]<a class="anchor" href="#%5B%E4%B8%AD%E6%96%87%E7%89%88%E7%B6%AD%E8%AD%B7%E4%BA%BA%5D">¶</a></h1>
<b>袁乙鈞 &lt;bbbush@163.com&gt;</b>
</section>
<section class="Sh">
<h1 class="Sh" id="[中文版最新更新]">[中文版最新更新]<a class="anchor" href="#%5B%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%80%E6%96%B0%E6%9B%B4%E6%96%B0%5D">¶</a></h1>
<b>2004.03.05</b>
</section>
<section class="Sh">
<h1 class="Sh" id="《中國linux論壇man手冊頁翻譯計劃》:">《中國linux論壇man手冊頁翻譯計劃》:<a class="anchor" href="#%E3%80%8A%E4%B8%AD%E5%9C%8Blinux%E8%AB%96%E5%A3%87man%E6%89%8B%E5%86%8A%E9%A0%81%E7%BF%BB%E8%AD%AF%E8%A8%88%E5%8A%83%E3%80%8B:">¶</a></h1>
<b><a href="../..//cmpp.linuxforum.net</a></b>
</section>
<section class="Sh">
<h1 class="Sh" id="跋">跋<a class="anchor" href="#%E8%B7%8B">¶</a></h1>
本頁面中文版由中文 man
  手冊頁計劃提供。
<br/>
中文 man
  手冊頁計劃：<b><a href="../../man-pages-zh/manpages-zh">../../man-pages-zh/manpages-zh</a></b>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">2002 July 15</td>
    <td class="foot-os">GNU Bash-2.05b</td>
  </tr>
</tbody></table>
</div>
</div>
</div>
<div id="footer">

<p><table>
<tr>
<td>
Source file:
</td>
<td>
history.1.zh_TW.gz (from <a href="../../package/manpages-zh/1.6.3.3-1/">manpages-zh 1.6.3.3-1</a>)
</td>
</tr>

<tr>
<td>
Source last updated:
</td>
<td>
2018-04-28T10:54:36Z
</td>
</tr>

<tr>
<td>
Converted to HTML:
</td>
<td>
2019-12-26T21:44:36Z
</td>
</tr>
</table></p>

<hr>
<div id="fineprint">
<p>debiman HEAD, see <a
href="../../Debian/debiman/">github.com/Debian/debiman</a>.
Found a problem? See the <a href="../../faq.html">FAQ</a>.</p>
</div>
</div>
<script type="text/javascript">
(function(a){"use strict";var b=function(b,c,d){var e=a.document;var f=e.createElement("link");var g;if(c)g=c;else{var h=(e.body||e.getElementsByTagName("head")[0]).childNodes;g=h[h.length-1];}var i=e.styleSheets;f.rel="stylesheet";f.href=b;f.media="only x";function j(a){if(e.body)return a();setTimeout(function(){j(a);});}j(function(){g.parentNode.insertBefore(f,(c?g:g.nextSibling));});var k=function(a){var b=f.href;var c=i.length;while(c--)if(i[c].href===b)return a();setTimeout(function(){k(a);});};function l(){if(f.addEventListener)f.removeEventListener("load",l);f.media=d||"all";}if(f.addEventListener)f.addEventListener("load",l);f.onloadcssdefined=k;k(l);return f;};if(typeof exports!=="undefined")exports.loadCSS=b;else a.loadCSS=b;}(typeof global!=="undefined"?global:this));
(function(a){if(!a.loadCSS)return;var b=loadCSS.relpreload={};b.support=function(){try{return a.document.createElement("link").relList.supports("preload");}catch(b){return false;}};b.poly=function(){var b=a.document.getElementsByTagName("link");for(var c=0;c<b.length;c++){var d=b[c];if(d.rel==="preload"&&d.getAttribute("as")==="style"){a.loadCSS(d.href,d);d.rel=null;}}};if(!b.support()){b.poly();var c=a.setInterval(b.poly,300);if(a.addEventListener)a.addEventListener("load",function(){a.clearInterval(c);});if(a.attachEvent)a.attachEvent("onload",function(){a.clearInterval(c);});}}(this));
</script>

<script type="application/ld+json">
"{\"@context\":\"../../contents-buster.html\",\"name\":\"buster\"}},{\"@type\":\"ListItem\",\"position\":2,\"item\":{\"@type\":\"Thing\",\"@id\":\"/buster/manpages-zh/index.html\",\"name\":\"manpages-zh\"}},{\"@type\":\"ListItem\",\"position\":3,\"item\":{\"@type\":\"Thing\",\"@id\":\"\",\"name\":\"history(1)\"}}]}"
</script>
